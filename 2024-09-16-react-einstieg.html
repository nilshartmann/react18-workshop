<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React Einf√ºhrung</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2024-09-16-react-einstieg</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg"
                  >https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p style="margin-top: 2rem">
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>
          <p></p>
          <p style="margin-top: 5rem">Java | JavaScript, TypeScript | React | GraphQL</p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>
        <!-- ============================================================================= -->

        <section>
          <h2>Agenda</h2>
          <h3>React</h3>
          <ul style="font-size: 85%">
            <li>
              <a href="#/t1">Teil I: React Einf√ºhrung</a>
            </li>
            <li>
              <a href="#/t2">Teil II: React-Komponenten (Details)</a>
            </li>
            <li>
              <a href="#/t3">Teil III: React-Komponenten: Hierarchien und Anwendungen</a>
            </li>
            <li style="margin-top: 20px">
              <a href="#/t-server">Teil IV: Seiteneffekte und Server-Zugriffe</a>
            </li>

            <li style="margin-top: 20px">
              <a href="#/t-typescript">Teil V: React mit TypeScript</a>
            </li>

            <li>
              <h4>Aus- und √úberblick (bei Interesse und Zeit)</h4>

              <ul>
                <li>
                  <a href="#/t-router">Client-seitiges Routing</a>
                </li>

                <li>
                  <a href="#/t-test">Testen</a>
                </li>
                <li style="margin-top: 20px">
                  <a href="#/t-state">Globales Zustandsmanagement mit Redux Toolkit</a>
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section id="t1">
          <h1>Teil 1</h1>
          <h2>React</h2>
        </section>

        <section>
          <h3>Beispiel-Anwendung</h3>
          <a target="_blank" href="http://localhost:3000">
            <img src="slides/images/blog-example.png" style="height: 850px" />
          </a>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Dokumentation</h3>

          <ul class="xx-list">
            <li>
              Dokumentation
              <a href="https://react.dev/">https://react.dev/</a>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### React im Umbruch?

* Bislang wurden und werden mit React Single-Page-Anwendungen (SPA) gebaut
* Mit Single-Page-Anwendungen l√§uft der Anwendungscode ausschlie√ülich im Browser
  * Man kann die Anwendung im (JavaScript-)Server vorrendern lassen (SSR)
* Seit M√§rz 2023 empfiehlt das React-Team ein "Fullstack Framework" wie Next.js zu verwenden
* Im Gegensatz zur "klassischen" Single-Page-Anwendung wird dabei ein Teil der Anwendung auf 
  einem (JavaScript-) Server ausgef√ºhrt
* Man kann aber weiterhin mit React SPAs bauen
* In dieser Schulung besch√§ftigen wir uns auch nur mit den SPAs
* Alles was wir sehen, w√§re auch Grundlage f√ºr Fullstack-Anwendungen 
  * Falls ihr also sp√§ter "Fullstack"-Anwendungen mit React bauen wollt, habt
  ihr auch daf√ºr schon die Grundlagen gelernt
  * Fullstack-Anwendungen bauen auf dem auf, was wir in uns in dieser Schulung ansehen
          </textarea>
        </section>

        <section>
          <h2>Unsere erste React-Komponente</h2>

          <ul>
            <li>
              <em>Sehen wir uns die wichtigsten Konzepte einer React-Komponente im Code an</em>
            </li>
            <li>Ihr k√∂nnt mir zugucken, √úbungen machen wir danach</li>
            <li>Schritt-f√ºr-Schritt (<code>react-intro/workspace</code>)</li>
          </ul>
        </section>

        <section id="interaktiv-hellomessage">
          <h3>Hello World React</h3>
          <code>PostEditor.js</code>
          <pre><code>
  import React from "react";
  
  export default function PostEditor() {
    const [title, setTitle] = React.useState("");
  
    return (
      &lt;div>
        &lt;label>
          Title
          &lt;input onChange={event => setTitle(event.target.value)} value={title} />
        &lt;/label>
      &lt;/div>
    );
  }
            </code></pre>
        </section>

        <section>
          <h3>Einbinden der Anwendung in die HTML-Seite</h3>
          <div>
            <p>
              <code>index.html</code>
            </p>
            <pre><code>
  &lt;html>
    &lt;-- ... -->
    &lt;body>
      <div id="root"></div>
    &lt;/body>
  &lt;/html>
  </code></pre>
          </div>
          <div>
            <p>
              <code>index.tsx</code>
            </p>
            <pre><code class="javascript">
  import React from 'react';

  import { createRoot } from 'react-dom/client';
  import PostEditor from './PostEditor';
  
  const root = createRoot(document.getElementById('root')!);
  root.render(&lt;PostEditor />);
  </code></pre>
            <p>Im Workspace ist die Root-Komponente die <code>App</code>-Komponente</p>
          </div>
        </section>

        <section>
          <h3>Der Trainingsworkspace</h3>
          <ul class="x-list">
            <li style="margin-bottom: 40px">
              <code>2024-09-16-react-einstieg.html</code>: Die Slides
            </li>
            <li style="margin-bottom: 40px">
              Der Code ist im <code><b>react-intro</b></code> Verzeichnis
            </li>

            <li style="margin-bottom: 40px">
              <code>react-intro/<b>workspace</b></code
              >: Verzeichnis f√ºr Eure √úbungen <br />üëâ&nbsp;<b>Empfehlung</b>: nur diesen Ordner in
              IDE/Editor √∂ffnen
            </li>
            <li>
              <code>react-intro/<b>steps</b></code
              >: Fertiger Source-Code nach jeder √úbung
            </li>
          </ul>
        </section>
        <section>
          <h2>√úbung #1: Hello-World</h2>
          <h3>
            <em>Mit Tools, Workspace und React vertraut machen</em>
          </h3>
        </section>
        <section>
          <h3>Schritt #1: Tool Chain starten</h3>
          <p>Gemeinsam, Schritt-f√ºr-Schritt:</p>
          <ol class="x-list" style="font-size: 85%">
            <li>Verzeichnis <code>react-intro/workspace</code> im Editor √∂ffnen</li>

            <li>
              <code>cd react-intro/workspace</code>
            </li>
            <li>
              <code>npm install</code>
            </li>
            <li>
              <code>npm run dev</code>
            </li>

            <li>
              Der Browser sollte automatisch
              <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>
              √∂ffnen
            </li>

            <li>Wenn Du "Hello, World" im Browser siehst, ist alles gut!</li>
            <li>Dann bitte in Teams "Hand heben" üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <p>
            <em
              >Ein kleiner Schritt f√ºr die PostEditor-Komponente, ein gro√üer Schritt f√ºr dich auf
              deinem Weg, React zu lernen!</em
            >
          </p>
          <ul>
            <li>Ersetze den "statischen" Code in <code>PostEditor.tsx</code></li>
            <li>Die Komponente soll <b>PostEditor</b> hei√üen</li>
            <li>
              Sie sollte einen Zustand/State (<code>title</code>) und ein Eingabefeld daf√ºr haben
            </li>
            <li>
              Als Hilfe kannst Du den Code aus den
              <a href="#interaktiv-hellomessage">vorherigen Slides</a> ansehen.
            </li>
            <li>
              Eine m√∂gliche L√∂sung findest Du auch in
              <code>react-intro/steps/02_hello_world_editor</code>
            </li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
## Ein React Projekt beginnen

* Wenn ihr Single-Page-Anwendungen mit React bauen wollt, habt ihr zwei M√∂glichkeiten, euer Projekt aufzusetzen:
  * [Vite](https://vitejs.dev/) mit dem `react-ts` Template
  * [Create React App (CRA)](https://create-react-app.dev/). 
    * Das war lange das Standard-Tool zum Aufsetzen von React-Projekten, wird aber kaum noch weiterentwickelt
    * Wenn ihr bestehende React-Projekte seht, ist die Wahrscheinlichkeit aber hoch, dass das CRA aufgesetzt wurde
  * üëâ vite ist das Mittel der Wahl und wird auch hier im Workspace verwendet
  </textarea
          >
        </section>

        <section id="t2">
          <h1>Teil II</h1>
          <h2>React Komponenten</h2>
        </section>

        <section>
          <h3>React: JSX</h3>
          <ul>
            <li style="font-size: 80%">
              Wird wie HTML hingeschrieben, inkl Attribute:
              <pre><code class="xml"  >
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Achtung! <code>class</code>-Attribut hei√üt <code>className</code>:
              <pre><code class="xml"  >
&lt;h1 className="title">...&lt;/h1>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Attribute, die keine Strings sind, m√ºssen in {} eingeschlossen werden:
              <pre><code class="xml"  >
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              CSS-Eigenschaften werden als Objekt √ºbergeben in Camel-Case-Notation:
              <pre><code class="xml"  >
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>React: JSX #2</h3>
          <ul>
            <li style="font-size: 80%">
              Fragmente (rendern selber kein Element in den DOM, nur ihre Kind-Elemente):
              <pre><code class="xml"  >
function Choice() { 
  return &lt;&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt;/>              
}  
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              null oder boolean (false oder true), um nichts zu rendern:
              <pre><code class="xml"  >
function ErrorMessage() {
  const hasError = someCondition(); // returns true or false

  return <div>
    {hasError && "Error!"}
    {hasError || "Everything fine"}
  </div>
}              
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              Kommentare
              <pre><code class="xml"  >
  function MyComponent() {
    return <div>
      { /* hier ist javascript, deswegen block-kommentare erlaubt */ }
    </div>;
  }              
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Zustand einer Komponente und der useState-Hook (Zusammenfassung)</h3>
          <ul class="fragement">
            <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server, Menu offen oder zu</li>
            <li><b>Werte</b> √ºblicherweise immutable</li>
            <li>Arbeiten mit Zustand √ºber <b>useState</b>-Hook</li>
            <li>
              useState liefert Array mit zwei Werten zur√ºck: aktuellen Zustand, und setter-Funktion
              um Zustand zu ver√§ndern
            </li>
            <li>
              <pre><code class="javascript"  >
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  return &lt;input onChange={e => setTitle(e.target.value) value={title} />;
}
                  </code></pre>
            </li>

            <li>
              Aufruf des Setters <b>l√∂st erneutes rendern der <i>gesamten</i> Komponente aus</b>
            </li>
            <li>
              Es k√∂nnen mehrere States erzeugt werden, durch Verwendung mehrerer useState-Aufrufe
            </li>
            <li><b>Zustand</b> ist eines der <b>zentralen</b> Konzepte von React</li>
          </ul>
        </section>

        <section data-markdown="">
          <textarea data-template>
### useState: Komplexer Zustand
* Ihr k√∂nnt in einer Komponente mehrere useState-Aufrufe machen
* Dann k√∂nnt ihr die einzelnen Zust√§nde getrennt aktualisieren
* Wenn ihr "komplexen" Zustand habt, k√∂nnt ihr nat√ºrlich auch Objekte und Listen in einen Zustand aufnehmen
* ```typescript
  const [address, setAddress] = useState({ street: "Hauptstra√üe", city: "N√ºrnberg" });
  ```
* Dann aber bitte daran denken, dass der **Zustand immutable** ist.
* Das bedeutet, wenn ihr den Zustand √§ndert, m√ºsst ihr das Objekt/die Liste kopieren und dann die Kopie aktualisieren:
* ```typescript
  const onStreetChange = (newStreet) => {
    setAddress(
      // kopieren, bzw. alten Zustand hier einf√ºgen
      ...address,
      // neue Stra√üe setzen:
      street: newStreet
    );
  }
  ```
* Achtung! Der Spread-Operator macht eine flache Kopie. Bei Unterobjekten etc. m√ºsst ihr entsprechend mehr Kopieren.
* Eine gro√üe Hilfe bei komplexen Zustand ist die Bibliothek [Immer](https://immerjs.github.io/immer/)
---
### Ausblick: useReducer als Alternative zu useState
* Mit [useReducer](https://react.dev/reference/react/useReducer) k√∂nnt ihr die Verwaltung des Zustands von der Komponente trennen.
* Damit implementiert ihr eine "Reducer-Funktion", die React aufruft, wenn sich der Zustand √§ndern soll
* React √ºbergibt euch dann den aktuellen Zustand, sowie eine "Action", die beschreibt, was gerade passiert ist
  (z.B. Texteingabe erfolgt)
* In der Reducer-Funktion k√∂nnt ihr dann abh√§ngig vom bisherigen Zustand und der Action den neuen Zustand ermitteln
  </textarea
          >
        </section>

        <section>
          <h3>React Hooks API</h3>
          <em
            >Mit der React Hooks API kann sich eine Komponente in Zustand und Lebenszyklus
            "einhaken"</em
          >
          <ul>
            <li>
              Hooks sind "normale" Funktionen, m√ºssen aber mit <code>use</code> beginnen (useState,
              useEffect, ...)
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks API</h3>
          <em
            >Bei der Verwendung von Hooks gibt es einige Regeln ("Rules of Hooks") zu beachten Ô∏è</em
          >üëÆ‚Äç‚ôÄÔ∏è
          <p style="font-size: 75%; margin-top: 0">
            <a href="https://react.dev/reference/rules/rules-of-hooks"
              >(https://react.dev/reference/rules/rules-of-hooks)</a
            >
          </p>
          <div>
            <p>Einschr√§nkungen:</p>
            <ul>
              <li>
                Hooks k√∂nnen nur in Funktionskomponenten (und anderen Hooks) aufgerufen werden
              </li>
              <li>
                Hooks m√ºssen immer in derselben Reihenfolge und auf Top-Level-Ebene verwendet werden
                <ul>
                  <li>Verboten z.B. in Schleifen, if-Abfragen oder in anderen Funktionen</li>
                </ul>
              </li>
              <li>
                Es gibt ein
                <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint Plug-in</a>
                zur korrekten Verwendung der Hooks
              </li>
              <li>
                <em
                  >Der Hooks-Mechanismus basiert intern darauf, dass React sich die Reihenfolge der
                  <code>useXyz</code>-Aufrufe merkt!</em
                >
              </li>
            </ul>
          </div>
        </section>
        <section>
          <h3>React Hooks</h3>

          <em>Beispiele f√ºr korrekte und unerlaubte Verwendung</em>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const [name, setName] = React.useState("");
  // ...
}
                                </code></pre>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const uppercaseGreeting = greeting.toUpperCase(); 
  const [name, setName] = React.useState("");
  // ...
}
                                                      </code></pre>

          <pre><code class="javascript"  >
// VERBOTEN:
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  function onSaveClick() {
    const [loading, setIsLoading] = React.useState(true);
    // ...
  }

  // ...
}
                                                      </code></pre>
        </section>

        <section>
          <h2>√úbung: Post-Editor f√ºr unsere Anwendung</h2>
          <em><b>Erweitere deine Komponente um neue Features</b></em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li>
              Zus√§tzlich zum "title", sollte es einen weiteren Zustand und eine Textarea geben:
              <code>body</code>. Ein <code>textarea</code>-Element hat dieselbe API wie ein
              <code>input</code>-Feld, du kannst also auch hier mit <code>onChange</code> und
              <code>value</code> arbeiten.
            </li>

            <li>
              F√ºge einen "Clear"-Button hinzu, der beide Eingabefeld leert. Das Property auf dem
              Button ist <code>onClick</code>.
            </li>
            <li>
              Der "Clear"-Button soll <b>disabled</b> sein, wenn beide Eingabefelder leer sind
            </li>
            <li>
              Optional: f√ºge unter beiden Feldern eine Fehler-Meldung hinzu, wenn das jeweilige Feld
              leer ist (z.B. "Please fill in Xyz")
            </li>
            <li>M√∂gliche L√∂sung: <code>steps/03_post_editor</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <section id="t3">
          <h1>Teil III</h1>
          <h2>React: Hierarchien und Anwendungen</h2>
        </section>

        <!-- - - - - - - - - - - - - - - - PROPS HIER ERST - - - - - - - - - - - - - - -  -->
        <section>
          <h3>React: Properties</h3>
          <p>Live: Die TagChooser-Komponente einbinden</p>
          <ul>
            <li>
              Mit <b>Properties</b> k√∂nnen einer Komponente von <b>au√üen</b> Werte und Eigenschaften
              √ºbergeben werden

              <pre><code class="javascript"  >
function PostEditor() {
    // type, onChange und value sind Properties!

    return (
      &lt;input type="text" onChange={() => setTitle("...")} value={title}&lt;/h1>
    );
  }
}
            </code></pre>
            </li>
            <li><b>Properties</b> k√∂nnen innerhalb der Komponente nicht ver√§ndert werden</li>
            <li>
              Zum Vergleich: <b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der
              Komponente (die ver√§ndert werden kann)
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties ("Props") einer Komponente</h3>
          <ul>
            <li>Komponenten k√∂nnen beliebig eigene Properties definieren</li>
            <li>
              Bei der Angabe der Properties bei der Verwendung einer Komponente werden die
              Properties wie von HTML gewohnt in der Notiation
              <code>name=value</code> hingeschrieben
            </li>
            <li>
              <pre><code class="javascript"  >
&lt;TagChooser title="Select tags for your post" availableTags={["JS", "Web Development" ]} />
               </code></pre>
            </li>
            <li>
              ...alle angegebenen Properties werden von React "gesammelt" und in
              <b>einem Objekt</b> an die Komponente √ºbergeben
            </li>
            <li>Das Objekt ist immer das <b>erste Funktionsargument</b> einer Komponente</li>
            <li>
              <pre><code class="javascript"  >
function TagChooser(props) {
    // props:
    //  {
    //     title: "Select tags for your post",
    //     availableTags: ["JS", "Web Development" ]
    // }

    return ...;
}
              </code></pre>
            </li>
            <li>
              <pre><code class="javascript"  >
// Mit Destructuring
function PostEditor( {title, availableTags} ) {

    return ...;
}
                                </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Properties mit TypeScript
<!-- .slide: class="left" -->
- Der erste Parameter einer Komponente ist immer ein `object`
- Mit TypeScript kannst du beschreiben, welche Properties deine Komponente darin erwartet und von welchem Typ die sind
  - Daran ist aus TypeScript-Sicht nichts React-spezifisch
- Dazu musst du mit `type` (oder `interface`) das `props`-Objekt beschreiben
- Wie du den Typen nennst, spielt keine Rolle.
  - In der Regel ist die Konvention entweder nur `Props` oder `KomponentenNameProps`
  * ```typescript
    type TagChooserProps = {
      // optionales Property:
      title?: string;

      // Liste mit Strings:
      availableTags: string[]

      // Auch (Callback-)Funktionen sind erlaubt:
      onTagSelected(tag: string): void
    }
    ```

* In der Funktionssignatur eurer Komponente gebt ihr denn Typen dann an:
  * ```typescript
    export default function TagChooser(props: TagChooserProps) { /* ... */ }
    ```
  * ```typescript
    // Mit Destructuring:
    export default function TagChooser({title, availableTags}: TagChooserProps) { /* ... */ }
    ```

          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Properties: Default-Werte</h3>

          <p>
            Mit dem Object Destructuring-Operator k√∂nnen <b>Default-Werte</b> angegeben werden, f√ºr
            Eigenschaften, die aus einem Objekt gelesen werden, aber dort nicht angegeben (bzw.
            undefined) sind:
          </p>
          <p>
            F√ºr den Aufrufer sind die Properties dann optional, innerhalb der Komponente wei√ü
            TypeScript aber, dass ein Wert vorhanden ist (und kennt auch dessen Typ)
          </p>

          <pre><code class="javascript">
function TagChooser({title = "Select Tag", availableTags}: TagChooserProps) {
  // 'title' ist hier in jedem Fall vom Typ 'string', auch wenn
  //  das vom Aufrufer nicht gesetzt wird

  // ...
}
          </code></pre>
          <pre><code class="javascript">
// title in der Komponente ist "Select Tag"
&lt;TagChooser availableTags={["JS", "React"]} />
          </code></pre>
        </section>

        <!--        <section>-->
        <!--          <h3>Virtual DOM</h3>-->
        <!--          <p>"Rendern" hat leider doppelte Bedeutung!</p>-->
        <!--          <img src="slides/images/vdom.png" style="height: 650px" />-->
        <!--        </section>-->
        <!--        <section>-->
        <!--          <h3>Virtual DOM</h3>-->
        <!--          <p>Beispiel: <code>react-intro/steps/2b-rendering</code></p>-->
        <!--        </section>-->

        <section data-markdown>
          <textarea data-template>
<!-- .slide: class="left" -->

### Listen in React

* JSX hat keine eigene Syntax zum Erzeugen von Listen-Darstellungen (im Gegensatz zu anderen Template-Sprachen, z.B. `ng:for` in Angular)
* Stattdessen verwendet man das normale [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) um Listen mit "Daten" auf Listen mit "UI" abzubilden
* ```typescript
  // Beispiel: eine Liste mit Tags
  const availableTags = [ "JavaScript", "React" ];
  ```
* ```typescript
  // Beispiel JavaScript: Mappen von Werten auf neue Werte
  const t = availableTags.map( t => t.toUpperCase());
    // t: [ "JAVASCRIPT", "REACT" ]
  ```
* Beim Erzeugen von Listen in React muss jedes Element ein [`key`-Property](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) bekommen, das innerhalb der Liste eindeutig sein muss

* ```typescript
  // Beispiel: In React zur Erzeugung von Listen:
  const list = availableTags.map(t => <li key={t}>Tag: {t}</li>
    // <li key="JavaScript">Tag: JavaScript</li>
    // <li key="React">Tag: React</li>
  ```
* ```typescript
  // Komplettes Beispiel:
  function TagChooser({availableTags}: TagChooserProps) {
    // ...
    return <ul>
      {availableTags.map(t => <li key={t}>Tag: {t}</li>}
    </ul>;
  }
  ```

* Doku: https://react.dev/learn/rendering-lists

  </textarea
          >
        </section>

        <section>
          <h2>√úbung: Ein TagChooser</h2>
          <em>Schritt 1 f√ºr den TagChooser: Darstellung der "available" Tags</em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="xx-list">
            <li>In <code>TagChooser.tsx</code> gibt es bereits eine TagChooser-Komponente.</li>
            <li>Diese Komponente musst du um Properties erweitern</li>
            <li>Au√üerdem musst du darin die √ºbergebenen (<code>availableTags</code>) anzeigen</li>
            <li>Du findest dazu Hinweise direkt in der Datei.</li>

            <li>M√∂gliche L√∂sung: <code>steps/05_props</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <section data-state="js-exkurs">
          <h2>React Devtools</h2>
          <em>React Developer Tools f√ºr Chrome und Firefox</em>
          <p>Untersuchen der React Anwendung zur Laufzeit</p>
          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/"
                target="_blank"
                >Firefox</a
              >
            </li>
          </ul>

          <p><img src="slides/images/screenshot-react-dev-tools.png" /></p>
        </section>
        <!-- <section>
          <h3>Render Zyklus</h3>
          <img src="slides/images/render-cycle.png" height="550px" />
        </section> -->

        <section>
          <h2>Komponenten-Hierarchien</h2>
        </section>

        <section data-markdown="">
          <textarea data-template>
## Komponenten-Hierarchien
* Wie k√∂nnen Komponenten untereinander kommunizieren?
* üëâ `PostEditor` und `TagChooser`
          </textarea>
        </section>

        <!--        <section>-->
        <!--          <h3>Smart und Dumb-Komponenten #1</h3>-->

        <!--          <p>-->
        <!--            Zur Erinnerung: in React bauen wir Komponenten. Komponenten bestehen aus Logik, Zustand-->
        <!--            und UI (HTML-Elemente und Styling)-->
        <!--          </p>-->
        <!--          <p>-->
        <!--            Ein bekanntes Muster ist, die Komponenten in zwei Arten aufzuteilen:-->
        <!--            <b>Smart (oder Controller)</b>- und <b>Dumb oder (Presentation-)</b>-Komponenten-->
        <!--          </p>-->
        <!--          <p>Technisch sind die Komponenten identisch, also "normale" React-Komponenten</p>-->
        <!--          <p>Nur ihre <b>Aufgabe</b> ist anders definiert...</p>-->
        <!--        </section>-->

        <section>
          <h3>Datenfluss in React-Anwendungen</h3>
          <p>
            <em
              >In React erfolgt der Datenfluss zwischen Komponenten
              <b>immer von oben nach unten</b>:</em
            >
          </p>
          <ol>
            <li>
              Eine Parent-Komponente hat <b>Zustand (State)</b> und ggf. Logik, um mit dem Zustand
              zu arbeiten
            </li>
            <li>
              Die Parent-Komponente reicht Daten per Properties an ihre Kind-Komponenten weiter
              (z.B. Daten aus dem Zustand)
            </li>
            <li>
              Au√üerdem gibt die Parent-Komponente <b>Callback-Funktionen als Properties</b> an ihre
              Kind-Komponenten (als eine Art Event-Handler)
            </li>
            <li>
              Bei einem Ereignis (zum Beispiel neues Tag ausgew√§hlt) ruft die Kind-Komponente die
              Callback-Funktion der Parent-Komponente auf
            </li>
            <li>
              In der Callback-Funktion findet dann die fachliche Verarbeitung des Events statt.
              Dabei kann die Parent-Komponente zum Beispiel ihren <b>State aktualisieren</b>
            </li>
            <li>
              Das √Ñndern des States triggert das <b>erneute Rendern der Komponenten-Hierarchie</b>,
              so dass sowohl Parent- als auch Kind-Komponente ihre Darstellung gem√§√ü den
              aktualisierten Daten anzeigen k√∂nnen
            </li>
          </ol>
          <ul>
            <li>
              Dieses Verhalten haben wir bei der eingebauten <code>input</code>-Komponente bereits
              gesehen. (<code>value</code> und <code>onChange</code>-Property)
            </li>
            <li>
              üëâ Durch das pauschale neurendern auch aller Kind-Komponenten kann es nicht zu
              <b>Inkonsistenzen</b> in der Darstellung durch "vergessenes" Rendern kommen.
            </li>
          </ul>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Kontrollierte" und "unkontrollierte" Komponenten
* Komponenten, die von einer anderen Komponente "kontrolliert" werden, werden **controlled components** in React genannt
* Diese Komponenten verlassen sich darauf, dass ihre Parent-Komponente den Zustand verwalten
* Beispiele f√ºr `controlled components`:
    * `input` (mit `onChange` und `value`): Oberkomponenten h√§lt den Inhalt des Eingabefelds und steuert, wann bzw. wie dieser ge√§ndert werden soll.
    * `TagChooser` (mit `selectedTags` und `onSelectionChange`): PostEditor kontrolliert, welche Tags ausgew√§hlt sind und was passieren soll, wenn sich die Auswahl √§ndert
    (PostEditor k√∂nnte sich zum Beispiel entschliessen, eine Auswahl zu ignorieren, oder unabh√§ngig vom TagChooser die Tags zur√ºckzusetzen)
* Beispiel f√ºr eine unkontrollierte Komponente:
    * `TagChooser` (in der bisherigen Form mit lokalem Zustand): Der PostEditor hat keinen Einfluss auf die Auswahl der Tags
    * `PostEditor`
  </textarea
          >
        </section>

        <section>
          <h3>Komponenten-Hierarchie mit Properties und Callback-Funktionen</h3>
          <img src="slides/images/posteditor-tagchooser-hierarchy.png" height="1000px" />
        </section>
        <section data-markdown="">
          <textarea data-template>
### Beispiel: PostEditor und TagChooser
* Der PostEditor enth√§lt die Liste aller Tags, sowie die aktuell f√ºr den neuen Post ausgew√§hlten Tags
* Der PostEditor gibt die ausgew√§hlten Tags an die TagChooser-Komponenten
* Der PostEditor gibt au√üerdem eine Callback-Funktion an den TagChooser
* Der TagChooser ruft diese Callback-Funktion auf, sobald sich die Auswahl der Tags ge√§ndert hat
* ```typescript
  function PostEditor() {
    const [tags, setTags] = useState<string[]>([]);

    return <>
      { /* ... */ }
      <TagChooser selectedTags={tags} onSelectionChange={setTags} />
    </>
  }
  function TagChooser({selectedTags, onSelectionChange}) {
    // kein State mehr!

    const handleTagClick = () => {
      // wenn ein Tag angeklickt wird, neue Auswahl ermitteln
      // und damit die Oberkomponente informieren
      const newSelectedTags = ...;

      onSelectionChange(newSelectedTags);
    }

    return /* ... */;
  }

  ```
  </textarea
          >
        </section>

        <section>
          <h2>√úbung: Mache den TagChooser zu einer "kontrollierten" Komponente</h2>
          <p>
            <em> Der PostEditor soll die Liste der ausgew√§hlten Tags verwalten </em>
          </p>
          <ol class="xx-list">
            <li>
              In <code>react-intro/material/06_hierarchien</code> findest du eine
              <code>TagChooser.tsx</code>-Datei
            </li>
            <li>In dieser Datei findest du eine Beschreibung der erforderlichen Schritte</li>
            <li>
              Du kannst die √Ñnderungen entweder an deinem eigenen TagChooser im Workspace
              vornehmen...
            </li>
            <li>
              ...oder du kopierst dir die <code>TagChooser.tsx</code>-Datei in einen Workspace als
              Ausgangsbasis
            </li>
            <li>M√∂gliche L√∂sung: <code>steps/06-hierarchien</code></li>
            <li>Wenn Du fertig bist, bitte in Teams "Hand heben" üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Lifting State up"
* Der Zustand ist an eine Komponente und deren Lebenszyklus gebunden
* Wenn eine Komponente von React aus dem DOM entfernt wird ("unmount"), geht auch deren Zustand verloren
* Wenn der PostEditor also entfernt wird gehen auch alle Eingaben und die ausgew√§hlten Tags verloren
* Dazu ein Beispiel
* <!-- .element: class="demo" --> PostPreview in 07_exkurs_lifting_state_up
---
### "Lifting State up"
* Wenn ihr Zustand ben√∂tigt, der das Entfernen einer Komponente √ºberlebt, m√ºsst ihr den Zustand in der Komponente nach oben schieben
* Dasselbe gilt auch, wenn ihr Zustand habt, der von mehr als einer Komponente verwendet werden soll
  * Erinnerung: Kommunikation erfolgt immer von oben nach unten, nie auf gleicher Ebene
* Soweit nach oben, bis ihr zu einer Komponente kommt, die √ºber den Komponenten steht, die den Zustand ben√∂tigen
* Dieses Pattern wird als ["Lifting State up"](https://react.dev/learn/sharing-state-between-components#lifting-state-up-by-example) bezeichnet
* Im `PostPreview`-Beispiel wird der Zustand aus dem `PostEditor` auch in `PostPreview` ben√∂tigt und wird dem entsprechend in
            `PostEditorPage` hochgeschoben
* <img src="slides/images/lifting-state-up.png" height="500px"/>

          </textarea>
        </section>

        <section id="t-server">
          <h1>Teil IV</h1>
          <h2>Data Fetching</h2>
          <em>Lesen und Schreiben von Daten von einem Backend (REST/HTTP)</em>
          <p><code>react-intro/steps/20_data_fetching</code></p>
          <p><code>react-intro/steps/25_mutations</code></p>
        </section>

        <!-- =================================================================================================== -->
        <!-- ==   Promises und Speichern                                                                                          == -->
        <!-- =================================================================================================== -->
        <section>
          <h2>Server-Zugriffe</h2>
          <ul class="x-list">
            <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
            <li>
              In der Regel braucht man zwei Dinge:
              <ol>
                <li>Eine (low-level) Bibliothek zum Ausf√ºhren der eigentlichen Requests</li>
                <li>
                  Eine (high-level) Bibliothek zum Arbeiten mit den Daten mit erweiterten Features
                  wie Caching und Fehlerbehandlung
                </li>
              </ol>
            </li>
            <li>
              H√§ufig in React verwendet: <b>fetch</b> API
              <ul>
                <li>Browser-API zum Ausf√ºhren von HTTP Requests</li>
                <li>
                  Dokumentation:
                  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"
                    >Fetch API (MDN)</a
                  >
                </li>
              </ul>
            </li>
            <li>
              Im Workshop verwenden wir <a href="https://github.com/sindresorhus/ky">ky</a>
              <ul>
                <li>Kleine Bibliothek, die auf fetch basiert</li>
                <li>
                  Abstraktion f√ºr typische Anwendungsf√§lle macht die Bedienung etwas einfacher
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Die ky Bibliothek

* Auf dem `ky`-Objekt sind Funktionen definiert, mit denen ihr Requests mit unterschiedlichen HTTP Methoden machen k√∂nnt (`get`, `post`, ...)
* Die Methoden haben jeweils zwei Parameter:
  1. Die Methoden erwarten die URL, die ihr aufrufen wollt
  2. (optional) Ein Objekt mit weiteren Einstellungen f√ºr einen Request, z.B. der Payload
* Die Funktionen liefern jeweils ein Promise mit einem `Response`-Objekt zur√ºck
  * Dabei handelt es sich um eine Erweiterung des standardisierten [Response-Objektes des Browsers](https://developer.mozilla.org/en-US/docs/Web/API/Response).
  * In ky gibt es darauf noch Hilfsmethoden, die es vereinfachen mit dem Payload der Antwort zu arbeiten
* Als Typ-Argument kann jeweils der erwartete R√ºckgabe-Typ in TypeScript definiert werden
  * Achtung! Nur Build-Zeit-Pr√ºfung, zur Laufzeit findet keine Pr√ºfung statt, ob die Antwort vom Server dem angegebenen
    Typen entspricht.

* ```typescript
  // HTTP GET Request
  const blogPosts = await ky
          .get<BlogPost[]>(`http://localhost:7000/posts`)
          .json();
  // ...
  ```
* ```typescript
  // HTTP POST Request mit Objekt als Body
  const newBlogPosts = await ky.post("http://localhost:7000/posts", {
          json: { title, body, tags }
  // ...
  });
  ```
  </textarea
          >
        </section>

        <section data-state="exkurs" id="t-promises">
          <h3>Hintergrund: Promises in JavaScript</h3>

          <p class="fragment">
            Ein Promise liefert einen "Versprechen" auf einen Wert zur√ºck, der evtl. erst in der
            Zukunft ermittelt werden kann
          </p>
          <p class="fragment">
            Damit k√∂nnen wir asynchrones Verhalten in JavaScript Applikation abbilden
          </p>
          <pre class="fragment"><code class="javascript" contenteditable>
// "getNameAsync" ist eine ausgedachte Funktion, 
// die ein Promise zur√ºckliefert, 
// das "irgendwann" den String "Klaus" zur√ºckgibt
const promise = getNameAsync();
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise.then(name => console.log(name));
// Ausgabe "irgendwann": "Klaus"
  </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>Promises</h3>
          <p>Promises k√∂nnen verkettet werden</p>
          <pre><code class="javascript" contenteditable>
// Annahme: 'getNameAsync' liefert "irgendwann" den String "Klaus" zur√ºck
const promise = getNameAsync()

// Wird mit dem ersten Wert aufgerufen und gibt neuen Wert zur√ºck
.then(name => getGreetingAsync(name)) 

// wird mit dem zweiten Wert (aus vorherigem then) aufgerufen
.then(greeting => console.log(greeting));

// Ausgabe "irgendwann": 
// "Hello, Klaus"

  </code></pre>
          <p class="fragment">
            Die <code>then</code>-Funktion gibt <b>immer</b> ein Promise zur√ºck
          </p>
        </section>

        <section data-state="exkurs">
          <h3>Fehlerbehandlung</h3>
          <h4>Mit <code>catch()</code> kann man Fehler fangen und darauf reagieren</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
  const promise = getNameAsync()

    .then(name => { if (name === null) throw new Error("No name found") })

    .then(greeting => console.log(greeting));

    .catch(error => console.error(`Greeting failed: ${error}`))
  
    // Wenn 'getNameAsync' null zur√ºckliefert ist die Ausgabe:
    //   Greeting failed: No name found
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section data-state="exkurs">
          <h3>Finally</h3>

          <p class="fragment">
            Eine <code>finally</code>-Callback-Funktion wird nach dem letzten <code>then</code> bzw.
            <code>catch</code>-Block ausgef√ºhrt.
          </p>

          <p class="fragment">
            Die finally-Funktion wird <b>immer</b> ausgef√ºhrt (unabh√§ngig davon, ob vorher ein
            Fehler aufgetreten ist oder nicht
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              const promise = getNameAsync();

                .then(name => { if (name === null) throw new Error("No name found") })

                .then(greeting => console.log(greeting));

                .catch(error => console.error(`Greeting failed: ${error}`))

                .finally( () => console.log("Goodbye!") );
              
                // Output (error): Greeting failed: No name found
                // Output (log): Goodbye!
                </code></pre>
        </section>

        <section data-state="exkurs">
          <h2>async / await</h2>
          <p>"Wrapper" um Promises</p>
          <p>Erlaubt es, asynchronen Code "linear" hinzuschreiben</p>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>await</code> wartet bis ein Promise aufgel√∂st wird</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }
    
    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);
    
      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>async</code> machen eine Funktion zu einer "async function"</p>
          <p class="fragment">
            Eine <code>async</code> Funktion gibt &nbsp; <b>immer</b> ein Promise zur√ºck
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }
  
  const greeting = greet('Klaus');
  
  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> Funktion als Fat Arrow Funktionen:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;                
    
  const greeting = greet('Klaus');
    
  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>async / await</h3>
          <p>
            Anstatt <code>then</code> oder <code>catch</code>-Ketten kannst Du einfach mehrere
            <code>await</code> Statements verwenden und try/catch f√ºr die Fehlerbehandlung:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};
  
  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
                      </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>Die fetch API</h3>
          <p>Schreiben von Daten mit HTTP POST</p>
          <p>
            <code>fetch</code> nimmt als 2. Parameter optional ein Konfigurationsobjekt entgegen:
          </p>
          <ul>
            <li>
              <code>method</code>: HTTP Methode (<code>PUT</code>, <code>POST</code>,
              <code>DELETE</code>, ...)
            </li>
            <li><code>headers</code>: HTTP Header f√ºr den Request (z.B. Authorization)</li>
            <li><code>body</code>: Der Payload (als String!)</li>
            <li>
              <p>Der Returnwert ist derselbe wie bei GET</p>
              <pre><code class="javascript"  >
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
  })
  // ... 
      </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Daten laden mit ky
* In einer ganz einfachen Variante k√∂nnen wir wie folgt Daten vom Backend in unsere Komponente laden:
* ```typescript
  export default function PostList() {
    const [posts, setPosts] = useState<BlogPost[]>([]);

    const handleLoadPosts = async () => {

      // Achtung! get() bzw. json() liefert Promise zur√ºck!
      //   -> mit await warten!
      const recivedPosts = await ky.get<BlogPost[]>("http://localhost:7000/posts")
            .json();

      // geladene Posts in den State packen:
      setPosts(recivedPosts);
    }

    return <div>
      <button onClick={handleLoadPosts}>Load Posts</button>
      // ...Posts rendern...
      </div>
  }
  ```
* Hier fehlen aber wichtige Features:
  * Fehlerhandling
  * Verhindern doppelter Requests
  * Caching
  * Zugriff auf die Daten in weiteren Komponenten
* üëâ deswegen verwendet man fetch bzw. ky √ºblicherweise mit einer Data Fetching Bibliothek
---
## Data Fetching Bibliotheken
* Es gibt spezialisierte Bibliotheken f√ºr React, die typische Anwendungsf√§lle und Probleme beim Lesen von Daten adressieren
  * [TanStack Query](https://tanstack.com/query/latest): Prominenteste Bibliothek zum Laden/Speichern von Daten inklusive Cache-Funktion
  * [SWR](https://swr.vercel.app/)
  * [Redux Toolkit Query](https://redux-toolkit.js.org/rtk-query/overview): Arbeiten mit APIs in Redux-Anwendungen
  * [Apollo GraphQL Client](https://www.apollographql.com/docs/react/): Client f√ºr GraphQL APIs mit Cache und Statemanagement M√∂glichkeiten
* Diese Bibliotheken haben alle √§hnliche Konzepte:
  * Hooks zum Laden/Speichern von Daten
  * globales Caching von Daten (auch zur Sicherstellung der konsistenten Darstellung)
    * Strategien zur Aktualisierung von Daten (auch automatisch im Hintergrund)
  * Unterst√ºtzung f√ºr das [Suspense-Feature von React](https://react.dev/reference/react/Suspense) (mit Ausnahme von RTK Query)

---
## TanStack Query
### Schritt-f√ºr-Schritt: Laden von Daten mit "TanStack Query"

* üëâ `PostListPage`
* üëâ sp√§ter: `PostEditorPage`
* üëâ sp√§ter: Custom Hooks
* üëâ sp√§ter: zod


---
### Der QueryClient

* Zentrales Konfigurationsobject: `QueryClient`
* React-unabh√§ngig
* Wird beim Starten der Anwendung initialisiert
* Oft reichen Default-Einstellung
* Es k√∂nnen aber z.B. globale Refetch-Policies eingestellt werden
* Das Objekt wird per QueryClientProvider in die Anwendung gereicht
* ```typescript
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false
      }
    }
  });

  root.render(
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  );
  ```
* In unserem Workspace wird der QueryClient in `create-query-client.ts` erzeugt

---
### Laden von Daten: useQuery

* [Queries](https://tanstack.com/query/latest/docs/react/guides/queries) werden mit dem `useQuery`-Hook ausgef√ºhrt
* [Der `useQuery`-Hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) erwartet ein Konfigurationsobjekt
  * `queryKey`: Array mit Query Keys (zur Interaktion mit dem Cache)
  * `queryFn`: Funktion zum Laden der Daten
  * Weitere Konfigurationen (optional)
* ```typescript
  import { useQuery } from "react-query";

  function BlogListPage() {

    const result = useQuery({
            queryKey: ['posts'],
            queryFn() { /* ... */ }
    );

    // ...
  }
  ```
---
### Query Function

* `useQuery` erwartet eine [Query-Function](https://tanstack.com/query/latest/docs/react/guides/query-functions), die den eigentlichen Request ausf√ºhrt
* Diese Funktion m√ºsst ihr selbst implementieren, z.B. mit ky oder fetch
* Die Funktion muss ein Promise mit den gelesenen Daten zur√ºckliefern
* Wenn es einen Fehler gab, muss die Funktion einen Fehler werfen
  * Wenn ihr `ky` benutzt, passiert das automatisch bei allen HTTP Status Codes die nicht im 200er-Bereich liegen
  * Wenn ihr `fetch` benutzt, m√ºsst ihr selber den Status Code √ºberpr√ºfen und ggf. einen Fehler werden
* Aus dem R√ºckgabe-Typ der Query-Funktion leitet `useQuery` den TypeScript-Typ f√ºr die gelesenen Daten ab.
* ```typescript
  import { useQuery } from "react-query";

  function BlogListPage() {

    const result = useQuery({
        queryKey: ['posts'],
        queryFn(): {
          return ky.get("http://...").json();
        }
    );

    // ...
  }
  ```

---

### R√ºckagebwert von `useQuery` (Query Ergebnis)

* `useQuery` liefert ein Objekt zur√ºck, das u.a. folgende Informationen umfasst:
  * `isLoading`: Der Query l√§dt noch (und es sind keine Daten im Cache)
  * `isSuccess`: Daten sind geladen
  * `isError`: Es ist ein Fehler aufgetreten
  * `data` enth√§lt die geladenen Daten (wenn `isSuccess` `true` ist)
  * `error`: Fehlerobjekt aus der Query-Funktion (wenn `isError` auf `true` gesetzt ist)
* Weitere [siehe Doku](https://tanstack.com/query/latest/docs/react/reference/useQuery)

---
### Query Keys

* [Query Keys](https://tanstack.com/query/latest/docs/react/guides/query-keys) werden verwendet, um das Ergebnis eines Queries identifizieren und cachen zu k√∂nnen
* Ein Query Key besteht aus einem Array von Werten
* √úblicherweise ist es ein Name (z.B. "posts") und dann ggf. weitere Parameter, zum Beispiel die Id eines Posts ("P1")
  oder die Sortierreihenfolge
  * Also alle Daten, die den Query exakt beschreiben
* ```typescript
  import { useQuery } from "react-query";

  function BlogPage({postId}) {

    // F√ºr jeden Aufruf mit einer neuen postId
    //  wird das Ergebnis separat in den Cache gelegt
    const result = useQuery({
      queryKey: ['blogPost', postId],
      queryFn: () => ky.get(`http://localhost:7000/posts/${postId}`).json()
    });

    // ...
  }
  ```
* Wenn ein Query mit denselben Query Keys in mehr als einer Komponente ausgef√ºhrt wird...
  * ...stellt TanStack Query sicher, dass der Query nur einmal ausgef√ºhrt wird
  * ...wenn sich das Ergebnis √§ndert, werden alle Komponenten, die den Query verwenden, automatisch aus dem Cache aktualisiert
---
### TanStack Query: Mutations

* [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) werden verwendet, um Daten auf dem Server zu *ver√§ndern* (speichern, l√∂schen)
* √úblicherweise werden dabei HTTP POST, PATCH, PUT oder DELETE Requests ausgef√ºhrt
* Der entsprechende Hook hei√üt [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
* Dessen API ist vergleichbar mit `useQuery`
* Auch der `useMutation`-Hook liefert Informationen √ºber den Zustand der Mutation zur√ºck
* ```typescript
  import { useMutation } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const mutation = useMutation({
      mutationFn() { ky.post("http://....", {json: { title, body } } ) },
      onSuccess() {
        // optional: wird aufgerufen, wenn die Mutation erfolgreich war
        // ...
      }
    });

    if (mutation.isSuccess) {
      return <h1>Blog Post saved!</h1>;
    }

    if (mutation.isError) {
      return <h1>Error: {mutation.error.toString()}</h1>;
    }

    // ...
  }
  ```
---
### TanStack Query: Mutations
* Im Gegensatz zu `useQuery` wird eine Mutation aber nicht automatisch ausgef√ºhrt, sondern wird explizit gestartet
* Dazu liefert `useMutation` die Funktion `mutate` zur√ºck
* √úbergeben wird der Funktion die zu schreibenden Daten
* ```typescript
  function PostEditor() {
    const [title, setTitle]  = useState("");

    const mutation = useMutation(/* ... */ );

    function saveBlogPost(newPost: NewBlogPost) {
      mutation.mutate();
    }

    // ...
  }
  ```
---
### Parameter f√ºr die Mutations
* Es gibt Szenarien, in denen ben√∂tigt eine Mutation Daten, die erst bei der Ausf√ºhrung von `mutate()` feststehen
  * Informationen, die beim Aufruf von `useMutation()` noch nicht vorliegen
* Dazu kann der `mutate`-Funktion genau **ein** Parameter √ºbergeben werden
* Wie dieser aussieht bestimmt ihr in der Definition der Mutation selbst
* Dieser Parameter entspricht n√§mlich dem ersten Parameter der `mutationFn`:
  * ```typescript
    const addPostMutation = useMutation({
      mutationFn(newBlogPost: NewBlogPost) { /* ... */ }
    })
    ```
* Wenn ihr mehr als einen "logischen" Parameter ben√∂tigt, m√ºsst ihr ein Objekt verwenden:
* ```typescript
  type AddCommentParam = { postId: string, comment: string };

  const addCommentMutation = useMutation({
    mutationFn(param: AddCommentParam) {
      const url = `/api/posts/${postId}/comments;
      return ky.post(url, { json: { comment: param.comment } });
    }
  });
  ```

---
### Arbeiten mit dem Ergebnis

* Wenn eine Mutation ausgef√ºhrt wurde, bekommt ihr `data` bzw. `error` zur√ºck
* Damit k√∂nnt ihr - wie bei `useQuery` - nach der Ausf√ºhrung einer Mutation die UI aktualisieren, um zum Beispiel Fehlermeldungen anzuzeigen
* ```typescript
  function PostEditor() {
    const savePostMutation = useMutation(/*...*/);

    return <form>
      { /* ... */}

      {saveMutation.isError && <p>Fehler beim Speichern des Posts: {String(saveMutation.error)}</p>}
      {saveMutation.isSuccess && <p>Der Blogpost wurde erfolgreich gespeichert!</p>}
    </form>
  }
  ```
---
### Aktionen nach einer Mutation ausf√ºhren
* Um direkt nach Beendingung einer Mutation weitere Aktionen auszuf√ºhren, gibt es zwei Wege:
  1.  [`mutateAsync`](https://tanstack.com/query/latest/docs/framework/react/guides/mutations#promises) statt `mutate` zum Ausf√ºhren der Mutation nutzewn
  2.  `on`-Callback-Funktionen verwenden
* Mit `mutateAsync` k√∂nnt ihr _in einer Komponente_ auf das Ergebnis der Mutation warten. Das ist sinnvoll, wenn man Komponenten-spezfische Aktionen ausf√ºhren m√∂chte.
  * `mutateAsync` liefert ein Promise mit den Daten der Mutation zur√ºck.
  * Schl√§gt die Mutation fehl, wird das Promise verworfen (rejected)
* Beispiel:
* ```typescript
  function PostEditor() {
    const navigate = useNavigate(); // vom React Router

    const savePostMutation = useMutation({ /* ... */ });

    async function savePost(newPost: NewPost) {
      const result = await savePostMutation.mutate(newPost);
      // result ist hier das Ergebnis der (erfolgreichen) Mutation

      navigate("/"); // nach erfolgreicher Mutation zur√ºck auf die Landingpage
    }

    // ...

  }
  ```
---
### Manuelles Aktualisieren von Queries

* Queries k√∂nnen per API manuell erneut ausgef√ºhrt werden
* Das kann zum Beispiel nach einer Mutation sinnvoll sein, um die ge√§nderten/gespeicherten Daten im Cache zu aktualisieren
* Dazu wird die Funktion [`invalidateQueries`](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientinvalidatequeries) vom `QueryClient` verwendet
* √úbergeben werden die Query Keys, deren Queries erneut ausgef√ºhrt werden sollen
* ```typescript
  import { useMutation, useQueryClient } from "react-query";

  function PostEditorPage() {
    const queryClient = useQueryClient();
    const mutation = useMutation({
      mutationFn() { /* ... */ },
      onSuccess() {
        // PostListPage-Query erneut ausf√ºhren, wenn Mutation erfolgreich war
        queryClient.invalidateQueries(['posts']);
      }
    });

    // ...
  }
  ```

---
### Zur√ºcksetzen einer Mutation

* Wenn eine Mutation ausgef√ºhrt wurde, ist `status`, `data`, `error` usw. gesetzt
* Mit `reset` kann man diese Informationen zur√ºcksetzen
* Das kann zum Beispiel nach einem Fehler sinnvoll sein, um die Fehlermeldung wieder verschwinden zu lassen
  * Zum Beispiel nach einer Benutzer-Interaktion
* Dann ist die Mutation "wie neu"
* ```typescript
  function PostEditor() {
    const addPostMutation = useMutation(/* ... */);

    return <form>
      { /* ... */ }

      <input onChange={e => {
        addPostMutaton.reset();
        // ...
      }} />

      { /* ... */ }
    </form>
  }
  ```
---
### √úbung: TanStack Query
- Implementiere das Laden der Blog Posts sowie das Speichern eines neuen Blog Posts
- Vorbereitung:
  - Bitte zuerst das "Backend starten
  - Dazu im Verzeichnis `backend` ausf√ºhren: `npm install` und  `npm start`
  - Der "Blog-Server" l√§uft dann unter http://localhost:3000
- Damit die Anwendung einfach bleibt, zeigen wir die Blog-Liste und den PostEditor gemeinsam auf einer Seite an
- Das **Lesen der Blog-Posts** musst du in der Komponenten `PostListPage` implementieren
  - dort findest du weitere Hinweise
  - m√∂gliche L√∂sung: `steps/20_data_fetching`
- Zum **Speichern des neuen Blog-Posts** musst du die Komponente `PostEditor` erweitern
  - im Verzeichnis `material/25_mutions` findest du eine `PostEditor`-Komponente mit weiteren Informationen dazu
  - du kannst die Anpassungen in deinem eigenen PostEditorm machen oder du kopierst `PostEditor.tsx` in deinen Workspace
  - m√∂gliche L√∂sung: `steps/25_mutation`
---
<!-- .slide: id="t-router" -->
## Routing in React

* Anforderungen:
  * URLs auf Komponenten abbilden
  * (Interne) Links, die die Anwendung neu rendern, ohne zum Server zu gehen
* React bringt keinen Router mit
* In der Regel wird der **React Router** verwendet

---

## Der React Router

* Homepage: [https://reactrouter.com/](https://reactrouter.com/)
* Aktuelle Version v6
* Achtung: Verhalten und API haben sich in Version 4, 5 und 6 ge√§ndert.
  * Bei Beispielen/Dokumentation/Tutorial etc. die Version beachten!
* Alternative (noch ganz neu): [TanStack Router](https://tanstack.com/router/latest/docs/framework/react/overview)
  - √úberragender TypeScript Support
  - Sehr komfortables Arbeiten mit Search Params
  - Code Generator und File-basierte Routen
---

## Der React Router

### Beispiel

```tsx
const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    children: [
      {
        index: true,
        element: <PostListPage />
      },
      {
        path: "/editor",
        element: <PostEditorPage />
      },

      { path: "*", element: <NotFoundPage /> }
    ]
  }
]);

export default function App() {
  return <RouterProvider router={router} />;
}
```

---

### Der BrowserRouter

* Es gibt mehrere Implementierungen des Routers, der Stadard ist der `BrowserRouter`
* Beim navigieren wird dabei der Pfad im Browser ver√§ndert (analog zum normalen Browser-Verhalten bei serverseitigen Anwendungen)
* üëâ Demo im Browser, Netzwerkverkehr untersuchen
* Wenn ihr den Router in Produktion verwendet, m√ºsst ihr euren Webserver so konfigurieren, dass bei allen angefragten Routen
            jeweils die `index.html`-Datei ausgeliefert wird

---

### Konfiguration der Routen: Welche Komponente soll f√ºr welche Route angezeigt werden?

* Mit dem `Route`-Objekt wird die Konfiguration beschrieben, welche Pfade es in Eurer Anwendung gibt, und welche Komponenten jeweils gerendert werden sollen.
* Es gibt zwei Notationen, eine Objekt- und eine Komponenten-Form
  * Beide sind identisch
  * Wenn ihr die Komponenten-Form verwendet, m√ºsst ihr die Komponenten an die Funktion `createRoutesFromElements` √ºbergeben
---
### Routen als Objekt

```typescript
  const routerConfig = createBrowserRouter([
    {
      path: "/",
      element: <RootLayout />,
      children: [
        {
          index: true,
          element: <PostListPage />
        },

        {
          path: "post/:postId",
          element: <PostPage />
        },
      ]
    }
  ]);
```
---
### Routen als Komponenten

```typescript
  const routerConfig = createBrowserRouter(
    createRoutesFromElements(
      &lt;Route path="/" element={&lt;RootLayout />}>

        &lt;Route index element={&lt;BlogListPage /> } />

        &lt;Route path="post/:postId" element={&lt;PostPage />}>

      &lt;/Route>
    )
  );
```

---
### Outlet

* Eine Komponente f√ºr eine Route kann die Komponenten f√ºr die Unter-Routen einbinden
* Auf diese Weise kann eine Oberkomponente zum Beispiel ein gemeinsames Layout implementieren
* Die Oberkomponente muss dann jeweils die Unterkomponenten rendern
  * Das funktioniert mit der [`<Outlet />`](https://reactrouter.com/en/main/components/outlet)-Komponente
  * ```javascript
    function App() {
      return &lt;div className="App">
        &lt;h1>Blog App</h1>
        &lt;Outlet />
      &lt;/div>
  }
```

---

### Index Routes

* Bei verschachtelten Routen muss f√ºr die Ober-Route eine Index Route gerendert werden
* Beispiel:
* ```typescript
  export const router = createBrowserRouter([
    {
      path: "/",
      element: <Layout />,
      children: [
        { path: "/editor",  element: <PostEditor /> }
      ]
    }
  ]);
  ```
* Hier wird `Blog` als `Outlet` in `App` f√ºr `/blog` gesetzt. Aber kein Outlet f√ºr `/`
* Dazu muss eine Index-Route definiert werden. Die wird unterhalb der Ober-Route eingesetzt und
  wird dann gerendert, wenn genau der Pfad der Ober-Route aufgerufen wird
* Statt `path` wird darin einfach `index` angegeben:
* ```typescript
  export const router = createBrowserRouter([
    {
      path: "/",
      element: <Layout />,
      children: [
        // "Index-Route" f√ºr /:
        { element: <PostListPage />, index: true },
        { path: "/editor",  element: <PostEditor /> }
      ]
    }
  ]);
  ```

---

### Fallback Route

* Mit `path="*"` kann eine Fallback-Route angegeben werden, die aktiv ist, wenn keine andere Route passt
* Beispiel:
* ```javascript
    &lt;Route path="/" element={&lt;App />}>
      &lt;Route path="blog" element={&lt;Blog />} />

      &lt;Route path="*" element={&lt;NotFound />} /> &lt;!-- F√ºr alle Route, au√üer / und /blog -->
    &lt;/Route>
  ```

---

### Links

* Links m√ºssen mit der [`Link`](https://reactrouter.com/docs/en/v6/components/link)-Komponente gerendert werden
* ```javascript
  function PostTeaser({post}) {
    return &lt;div>
      &lt;h1>{post.title}&lt;/h1>
      &lt;Link to={`/post/${post.id}`}>Read more&lt;/Link>
    &lt;/div>
  }
```
* Die `Link`-Komponente rendert ein `a`-Element, verhindert aber, dass der Browser Serveraufrufe durchf√ºhrt,
  wenn darauf geklickt wird
* Das gilt nur f√ºr interne Links, externe Links wie gewohnt mit HTML `a`-Element
* Alternative: [`NavLink`](https://reactrouter.com/docs/en/v6/components/nav-link) wei√ü, ob der `to`-Pfad
  der gerade aktiven Route entspricht und kann sich dann anders darstellen ("Aktiver Link", "Aktiver Tab", ...)
  * ```javascript
    function NavBar() {
      return &lt;div>
        &lt;NavLink to={`/home}`} className={active => active ? "Tab--active":"Tab--default" }>Home&lt;/Link>
        &lt;NavLink to={`/about}`} className={active => active ? "Tab--active":"Tab--default" }>About&lt;/Link>
        &lt;NavLink to={`/profile}`} className={active => active ? "Tab--active":"Tab--default" }>Profile&lt;/Link>
      &lt;/div>
    }
```
* Mit `className` und `style` k√∂nnen Callback-Funktionen √ºbergeben werden, die das konkrete Styling/CSS Klasse je nach Zustand
  (active bzw not-active) zur√ºckliefern.

---

### Navigation per API

* Die [`Navigate`](https://reactrouter.com/docs/en/v6/components/navigate)-Komponente kann gerendert werden,
  wenn eine Komponente beim Rendern einen Redirect machen m√∂hcte
* ```javascript
  function BlogPost() {
    const [error, setError] = useState(false);
    const [post, setPost] = useState(null);

    useEffect( () => fetch(...).catch(e => setError(true)), [] );

    if (error) {
      return &lt;Navigate to="/error" />
    }

    return &lt;BlogPost post={post} />
  }
  ```
* Mit [`useNavigate`](https://reactrouter.com/en/6.16.0/hooks/use-navigate) kann auch per API, z.B. in einem Event Handler, ein Redirect gemacht werden:
* ```javascript
  function LogoutButton() {
    const useNaviate = useNavigate();

    function handleClick() {
      navigate("/");
    }

    return &lt;button onClick={handleClick}>Logout&lt;/button>
  }
  ```

---
### √úbung: Router

* **Stelle die Anwendung auf den React Router um**
* Die beiden bekannten Seiten (Post Liste und Post Editor) sollen jeweils eine Route werden
* Au√üerdem soll es ein globales "Layout" geben, das den Anwendungstitel sowie zwei Links anzeigt
* Schreibe daf√ºr die Router-Definition in `create-router.tsx`. Dort findest du auch weitere Informationen
* Eine m√∂gliche L√∂sung findest Du in `30_router`



</textarea
          >
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p><a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p><a href="https://www.linkedin.com/in/nils-hartmann-2a5738252/">LinkedIn</a></p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
