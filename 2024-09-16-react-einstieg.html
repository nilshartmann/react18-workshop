<!doctype html>
<!--suppress ALL -->
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div id="nils-clipboard">
      <svg
        width="100%"
        height="100%"
        viewBox="0 0 16 16"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M14.15 3.30005L11.525 0.700049C11.35 0.525049 11.1 0.425049 10.85 0.425049H6.30004C5.57504 0.425049 4.97504 1.02505 4.97504 1.75005V10.875C4.97504 11.6 5.57504 12.2 6.30004 12.2H13.1C13.825 12.2 14.425 11.6 14.425 10.875V3.97505C14.425 3.72505 14.325 3.47505 14.15 3.30005ZM11.575 2.35005L12.525 3.30005H11.575V2.35005ZM13.1 11.075H6.30004C6.20004 11.075 6.10004 10.975 6.10004 10.875V1.75005C6.10004 1.65005 6.20004 1.55005 6.30004 1.55005H10.45V3.85005C10.45 4.15005 10.7 4.42505 11.025 4.42505H13.3V10.9C13.3 11 13.2 11.075 13.1 11.075Z"
          fill="#d1d5db"
        />
        <path
          d="M11.025 5.62506H7.72502C7.42502 5.62506 7.15002 5.87506 7.15002 6.20006C7.15002 6.52506 7.40002 6.77506 7.72502 6.77506H11.025C11.325 6.77506 11.6 6.52506 11.6 6.20006C11.6 5.87506 11.325 5.62506 11.025 5.62506Z"
          fill="#d1d5db"
        />
        <path
          d="M11.025 7.72498H7.72502C7.42502 7.72498 7.15002 7.97498 7.15002 8.29998C7.15002 8.59998 7.40002 8.87498 7.72502 8.87498H11.025C11.325 8.87498 11.6 8.62498 11.6 8.29998C11.575 7.97498 11.325 7.72498 11.025 7.72498Z"
          fill="#d1d5db"
        />
        <path
          d="M10.45 13.0001C10.15 13.0001 9.87501 13.2501 9.87501 13.5751V14.2501C9.87501 14.3501 9.77501 14.4501 9.67501 14.4501H2.90001C2.80001 14.4501 2.70001 14.3501 2.70001 14.2501V5.10006C2.70001 5.00006 2.80001 4.90006 2.90001 4.90006H3.75001C4.05001 4.90006 4.32501 4.65006 4.32501 4.32506C4.32501 4.00006 4.07501 3.75006 3.75001 3.75006H2.90001C2.17501 3.75006 1.57501 4.35006 1.57501 5.07506V14.2501C1.57501 14.9751 2.17501 15.5751 2.90001 15.5751H9.70001C10.425 15.5751 11.025 14.9751 11.025 14.2501V13.5751C11.025 13.2501 10.775 13.0001 10.45 13.0001Z"
          fill="#d1d5db"
        />
      </svg>
    </div>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React Einführung</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2024-09-16-react-einstieg</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg"
                  >https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p style="margin-top: 2rem">
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>
          <p></p>
          <p style="margin-top: 5rem">Java | JavaScript, TypeScript | React | GraphQL</p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>
        <!-- ============================================================================= -->
        <section data-markdown="">
          <textarea data-template>
## Agenda

* [Teil 1: Hello World, React!](#/t1)
* [Teil 2: React-Komponenten und Hooks API](#/t2)
* [Teil 3: React-Komponenten mit TypeScript](#/t-3-typescript)
* [Teil 4: Komponenten-Hierarchien](#/t4)
* [Teil 5: Data Fetching](#/t5-data-fetching)
* [Teil 6: Clientseitiges Routing](#/t6-routing)
* Ausblick
  * [Seiteneffekte mit useEffect](#/seiteneffekte)
  * [Validieren von Daten mit zod](#/t-zod)
* Wenn ihr weitere Themen und Wünsche habt, jederzeit gerne. Einfach Bescheid sagen!


  </textarea
          >
        </section>

        <section id="t1">
          <h1>Teil 1</h1>
          <h2>React</h2>
        </section>

        <section>
          <h3>Beispiel-Anwendung</h3>
          <a target="_blank" href="http://localhost:3000">
            <img src="slides/images/blog-example.png" style="height: 850px" />
          </a>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Dokumentation</h3>

          <ul class="xx-list">
            <li>
              Dokumentation
              <a href="https://react.dev/">https://react.dev/</a>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### React im Umbruch?

* Bislang wurden und werden mit React Single-Page-Anwendungen (SPA) gebaut
* Mit Single-Page-Anwendungen läuft der Anwendungscode ausschließlich im Browser
  * Man kann die Anwendung im (JavaScript-)Server vorrendern lassen (SSR)
* Seit März 2023 empfiehlt das React-Team ein "Fullstack Framework" wie Next.js zu verwenden
* Im Gegensatz zur "klassischen" Single-Page-Anwendung wird dabei ein Teil der Anwendung auf 
  einem (JavaScript-) Server ausgeführt
* Man kann aber weiterhin mit React SPAs bauen
* In dieser Schulung beschäftigen wir uns auch nur mit den SPAs
* Alles was wir sehen, wäre auch Grundlage für Fullstack-Anwendungen 
  * Falls ihr also später "Fullstack"-Anwendungen mit React bauen wollt, habt
  ihr auch dafür schon die Grundlagen gelernt
  * Fullstack-Anwendungen bauen auf dem auf, was wir in uns in dieser Schulung ansehen
          </textarea>
        </section>

        <section>
          <h2>Unsere erste React-Komponente</h2>

          <ul>
            <li>
              <em>Sehen wir uns die wichtigsten Konzepte einer React-Komponente im Code an</em>
            </li>
            <li>Ihr könnt mir zugucken, Übungen machen wir danach</li>
            <li>Schritt-für-Schritt (<code>react-intro/workspace</code>)</li>
          </ul>
        </section>

        <section id="interaktiv-hellomessage">
          <h3>Hello World React</h3>
          <code>PostEditor.js</code>
          <pre><code>
  import React from "react";
  
  export default function PostEditor() {
    const [title, setTitle] = React.useState("");
  
    return (
      &lt;div>
        &lt;label>
          Title
          &lt;input onChange={event => setTitle(event.target.value)} value={title} />
        &lt;/label>
      &lt;/div>
    );
  }
            </code></pre>
        </section>

        <section>
          <h3>Einbinden der Anwendung in die HTML-Seite</h3>
          <div>
            <p>
              <code>index.html</code>
            </p>
            <pre><code>
  &lt;html>
    &lt;-- ... -->
    &lt;body>
      <div id="root"></div>
    &lt;/body>
  &lt;/html>
  </code></pre>
          </div>
          <div>
            <p>
              <code>index.tsx</code>
            </p>
            <pre><code class="javascript">
  import React from 'react';

  import { createRoot } from 'react-dom/client';
  import PostEditor from './PostEditor';
  
  const root = createRoot(document.getElementById('root')!);
  root.render(&lt;PostEditor />);
  </code></pre>
            <p>Im Workspace ist die Root-Komponente die <code>App</code>-Komponente</p>
          </div>
        </section>

        <section>
          <h3>Der Trainingsworkspace</h3>
          <ul class="x-list">
            <li style="margin-bottom: 40px">
              <code>2024-09-16-react-einstieg.html</code>: Die Slides
            </li>
            <li style="margin-bottom: 40px">
              Der Code ist im <code><b>react-intro</b></code> Verzeichnis
            </li>

            <li style="margin-bottom: 40px">
              <code>react-intro/<b>workspace</b></code
              >: Verzeichnis für Eure Übungen <br />👉&nbsp;<b>Empfehlung</b>: nur diesen Ordner in
              IDE/Editor öffnen
            </li>
            <li>
              <code>react-intro/<b>steps</b></code
              >: Fertiger Source-Code nach jeder Übung
            </li>
          </ul>
        </section>
        <section>
          <h2>Übung #1: Hello-World</h2>
          <h3>
            <em>Mit Tools, Workspace und React vertraut machen</em>
          </h3>
        </section>
        <section>
          <h3>Schritt #1: Tool Chain starten</h3>
          <p>Gemeinsam, Schritt-für-Schritt:</p>
          <ol class="x-list" style="font-size: 85%">
            <li>Verzeichnis <code>react-intro/workspace</code> im Editor öffnen</li>

            <li>
              <code>cd react-intro/workspace</code>
            </li>
            <li>
              <code>npm install</code>
            </li>
            <li>
              <code>npm run dev</code>
            </li>

            <li>
              Der Browser sollte automatisch
              <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>
              öffnen
            </li>

            <li>Wenn Du "Hello, World" im Browser siehst, ist alles gut!</li>
            <li>Dann bitte in Teams "Hand heben" 🙋‍♀️</li>
          </ol>
        </section>
        <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <p>
            <em
              >Ein kleiner Schritt für die PostEditor-Komponente, ein großer Schritt für dich auf
              deinem Weg, React zu lernen!</em
            >
          </p>
          <ul>
            <li>Ersetze den "statischen" Code in <code>PostEditor.tsx</code></li>
            <li>Die Komponente soll <b>PostEditor</b> heißen</li>
            <li>
              Sie sollte einen Zustand/State (<code>title</code>) und ein Eingabefeld dafür haben
            </li>
            <li>
              Als Hilfe kannst Du den Code aus den
              <a href="#interaktiv-hellomessage">vorherigen Slides</a> ansehen.
            </li>
            <li>
              Eine mögliche Lösung findest Du auch in
              <code>react-intro/steps/02_hello_world_editor</code>
            </li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams 🙋‍♀️</li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
## Hintergrund: Ein React Projekt beginnen

* Wenn ihr Single-Page-Anwendungen mit React bauen wollt, habt ihr zwei Möglichkeiten, euer Projekt aufzusetzen:
  * [Vite](https://vitejs.dev/) mit dem `react-ts` Template
  * [Create React App (CRA)](https://create-react-app.dev/). 
    * Das war lange das Standard-Tool zum Aufsetzen von React-Projekten, wird aber kaum noch weiterentwickelt
    * Wenn ihr bestehende React-Projekte seht, ist die Wahrscheinlichkeit aber hoch, dass das CRA aufgesetzt wurde
  * 👉 vite ist das Mittel der Wahl und wird auch hier im Workspace verwendet
  </textarea
          >
        </section>

        <section id="t2">
          <h1>Teil II</h1>
          <h2>React Komponenten und Hooks API</h2>
        </section>

        <section>
          <h3>React: JSX</h3>
          <ul>
            <li style="font-size: 80%">
              Wird wie HTML hingeschrieben, inkl Attribute:
              <pre><code class="xml"  >
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Achtung! <code>class</code>-Attribut heißt <code>className</code>:
              <pre><code class="xml"  >
&lt;h1 className="title">...&lt;/h1>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Attribute, die keine Strings sind, müssen in {} eingeschlossen werden:
              <pre><code class="xml"  >
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              CSS-Eigenschaften werden als Objekt übergeben in Camel-Case-Notation:
              <pre><code class="xml"  >
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>React: JSX #2</h3>
          <ul>
            <li style="font-size: 80%">
              Fragmente (rendern selber kein Element in den DOM, nur ihre Kind-Elemente):
              <pre><code class="xml"  >
function Choice() { 
  return &lt;&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt;/>              
}  
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              null oder boolean (false oder true), um nichts zu rendern:
              <pre><code class="xml"  >
function ErrorMessage() {
  const hasError = someCondition(); // returns true or false

  return <div>
    {hasError && "Error!"}
    {hasError || "Everything fine"}
  </div>
}              
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              Kommentare
              <pre><code class="xml"  >
  function MyComponent() {
    return <div>
      { /* hier ist javascript, deswegen block-kommentare erlaubt */ }
    </div>;
  }              
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Zustand einer Komponente und der useState-Hook (Zusammenfassung)</h3>
          <ul class="fragement">
            <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server, Menu offen oder zu</li>
            <li><b>Werte</b> üblicherweise immutable</li>
            <li>Arbeiten mit Zustand über <b>useState</b>-Hook</li>
            <li>
              useState liefert Array mit zwei Werten zurück: aktuellen Zustand, und setter-Funktion
              um Zustand zu verändern
            </li>
            <li>
              <pre><code class="javascript"  >
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  return &lt;input onChange={e => setTitle(e.target.value) value={title} />;
}
                  </code></pre>
            </li>

            <li>
              Aufruf des Setters <b>löst erneutes rendern der <i>gesamten</i> Komponente aus</b>
            </li>
            <li>
              Es können mehrere States erzeugt werden, durch Verwendung mehrerer useState-Aufrufe
            </li>
            <li><b>Zustand</b> ist eines der <b>zentralen</b> Konzepte von React</li>
          </ul>
        </section>

        <section data-markdown="">
          <textarea data-template>
### useState: Komplexer Zustand
* Ihr könnt in einer Komponente mehrere useState-Aufrufe machen
* Dann könnt ihr die einzelnen Zustände getrennt aktualisieren
* Wenn ihr "komplexen" Zustand habt, könnt ihr natürlich auch Objekte und Listen in einen Zustand aufnehmen
* ```typescript
  const [address, setAddress] = useState({ street: "Hauptstraße", city: "Nürnberg" });
  ```
* Dann aber bitte daran denken, dass der **Zustand immutable** ist.
* Das bedeutet, wenn ihr den Zustand ändert, müsst ihr das Objekt/die Liste kopieren und dann die Kopie aktualisieren:
* ```typescript
  const onStreetChange = (newStreet) => {
    setAddress(
      // kopieren, bzw. alten Zustand hier einfügen
      ...address,
      // neue Straße setzen:
      street: newStreet
    );
  }
  ```
* Achtung! Der Spread-Operator macht eine flache Kopie. Bei Unterobjekten etc. müsst ihr entsprechend mehr Kopieren.
* Eine große Hilfe bei komplexen Zustand ist die Bibliothek [Immer](https://immerjs.github.io/immer/)
---
### Ausblick: useReducer als Alternative zu useState
* Mit [useReducer](https://react.dev/reference/react/useReducer) könnt ihr die Verwaltung des Zustands von der Komponente trennen.
* Damit implementiert ihr eine "Reducer-Funktion", die React aufruft, wenn sich der Zustand ändern soll
* React übergibt euch dann den aktuellen Zustand, sowie eine "Action", die beschreibt, was gerade passiert ist
  (z.B. Texteingabe erfolgt)
* In der Reducer-Funktion könnt ihr dann abhängig vom bisherigen Zustand und der Action den neuen Zustand ermitteln
  </textarea
          >
        </section>

        <section>
          <h3>React Hooks API</h3>
          <em
            >Mit der React Hooks API kann sich eine Komponente in Zustand und Lebenszyklus
            "einhaken"</em
          >
          <ul>
            <li>
              Hooks sind "normale" Funktionen, müssen aber mit <code>use</code> beginnen (useState,
              useEffect, ...)
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks API</h3>
          <em
            >Bei der Verwendung von Hooks gibt es einige Regeln ("Rules of Hooks") zu beachten ️</em
          >👮‍♀️
          <p style="font-size: 75%; margin-top: 0">
            <a href="https://react.dev/reference/rules/rules-of-hooks"
              >(https://react.dev/reference/rules/rules-of-hooks)</a
            >
          </p>
          <div>
            <p>Einschränkungen:</p>
            <ul>
              <li>
                Hooks können nur in Funktionskomponenten (und anderen Hooks) aufgerufen werden
              </li>
              <li>
                Hooks müssen immer in derselben Reihenfolge und auf Top-Level-Ebene verwendet werden
                <ul>
                  <li>Verboten z.B. in Schleifen, if-Abfragen oder in anderen Funktionen</li>
                </ul>
              </li>
              <li>
                Es gibt ein
                <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint Plug-in</a>
                zur korrekten Verwendung der Hooks
              </li>
              <li>
                <em
                  >Der Hooks-Mechanismus basiert intern darauf, dass React sich die Reihenfolge der
                  <code>useXyz</code>-Aufrufe merkt!</em
                >
              </li>
            </ul>
          </div>
        </section>
        <section>
          <h3>React Hooks</h3>

          <em>Beispiele für korrekte und unerlaubte Verwendung</em>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const [name, setName] = React.useState("");
  // ...
}
                                </code></pre>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const uppercaseGreeting = greeting.toUpperCase(); 
  const [name, setName] = React.useState("");
  // ...
}
                                                      </code></pre>

          <pre><code class="javascript"  >
// VERBOTEN:
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  function onSaveClick() {
    const [loading, setIsLoading] = React.useState(true);
    // ...
  }

  // ...
}
                                                      </code></pre>
        </section>

        <section>
          <h2>Übung: Post-Editor für unsere Anwendung</h2>
          <em><b>Erweitere deine Komponente um neue Features</b></em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li>
              Zusätzlich zum "title", sollte es einen weiteren Zustand und eine Textarea geben:
              <code>body</code>. Ein <code>textarea</code>-Element hat dieselbe API wie ein
              <code>input</code>-Feld, du kannst also auch hier mit <code>onChange</code> und
              <code>value</code> arbeiten.
            </li>

            <li>
              Füge einen "Clear"-Button hinzu, der beide Eingabefeld leert. Das Property auf dem
              Button ist <code>onClick</code>.
            </li>
            <li>
              Der "Clear"-Button soll <b>disabled</b> sein, wenn beide Eingabefelder leer sind
            </li>
            <li>
              Optional: füge unter beiden Feldern eine Fehler-Meldung hinzu, wenn das jeweilige Feld
              leer ist (z.B. "Please fill in Xyz")
            </li>
            <li>Mögliche Lösung: <code>steps/03_post_editor</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom 🙋‍♀️</li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
### Ausblick: Formulare mit React

* Wenn ihr viel mit Formularen arbeitet, lohnt sich ein Blick auf spezialisierte Bibliotheken dafür
* Eine verbreitete Bibliothek ist [React Hook Form](https://react-hook-form.com/)
* Die bringt auch fortgeschrittene Features mit:
    - Validierung der Daten
    - Fehlerzustände
    - Tracking, welche Felder ausgeführt bzw. fokussiert wurden
* In React 19 wird es einen neuen Hook geben: [useActionState](https://19.react.dev/reference/react/useActionState)
  - Wahrscheinlich aber eher relevant wenn man auch serverseitig React verwendet
  </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-3-typescript" -->
# Teil 3
## React Anwendungen mit TypeScript
          </textarea>
        </section>

        <!-- ######################################################  -->
        <section>
          <h2>TypeScript</h2>
          <ol>
            <li><a href="#/t-typescript-grundlagen">Einführung in TypeScript</a></li>
            <li><a href="#/t-typescript-react">React mit TypeScript</a></li>
          </ol>
        </section>

        <section id="t-typescript-grundlagen">
          <h2>Einführung: Die Sprache TypeScript</h2>
          <p class="fragment">
            <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
            <a href="http://www.typescriptlang.org/" target="_blank"
              >http://www.typescriptlang.org/</a
            >)
          </p>
          <ul>
            <li class="fragment">Erweitert JavaScript um ein Typen System</li>
            <li class="fragment">
              Jeder gültige JavaScript Code ist auch gültiger TypeScript Code
            </li>
            <li class="fragment">
              Mittels des TypeScript Compilers wird aus TS Code JavaScript Code
            </li>
          </ul>
        </section>

        <section>
          <h3>TypeScript Grundlagen</h3>
          <p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Variablen können Typ-Informationen bekommen
  let foo: string;
  foo = 'yo';
  // Error: number: This type is incompatible with string
  foo = 10;
                 </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Funktionen
  function sayIt(what: string): string {
    return `Saying: ${what}`;
  }

  sayIt('Klaus'); // ok
  sayIt(10); // error
  </code></pre>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Arrow Funktionen
  const sayIt = (what: string): string => `Saying: ${what}`;

  sayIt('Moin');
  sayIt(123); // Error: Argument of type '123' is not assignable
              // to parameter of type 'string'.
  </code></pre>
        </section>

        <section>
          <h2>Eingebaute Typen</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // string
  let city: string = 'Hamburg';

  // boolean
  let isDone: boolean = false;

  // number
  let theAnswer: number = 42;

  // array (note the [])
  let cities: string[] = ['Hamburg', 'Barcelona'];
  // alternative:
  let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

  // void
  function log(s: string): void { /* ... */ }
              </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // any: kann alle Typen aufnehmen, Typ-Prüfung ist ausgeschaltet
  let theUnknown: any = 'Who cares';
  theUnknown = 666; // ok
  theUnknown = true; // ok
  let a: number = theUnknown; // ok
  function loadData(): any { return "" // ok }
  let b:number = loadData(); // ok

              </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // unknown: kann ebefalls alle Typen aufnehmen, erzwingt aber vor der Verwendung Typ-Prüfung
  function loadData(): unknown { return "" // ok }
  let b = loadData();
  b.toUpperCase(); // ERROR
  if (typeof b === "string") {
    // b ist jetzt string (typeof ist Laufzeitprüfung!)
    b.toUpperCase(); // OK
  }
              </code></pre>
        </section>
        <section>
          <h2>Typen können abgeleitet (inferred) werden</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  let city = 'Hamburg'; // city ist ein String

  city = 42;
  // Fehler: [ts] Type '42' is not assignable to type 'string'.
  </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Explizite Angabe eines Types (parameter)
  // und abgeleiteter Typ (Return Type der Funktion)

  function sayIt(what: string) {
    return `Saying: ${what}`;
  }

  const said: string = sayIt('Hello TypeScript'); // ok
  const saidItWrong: number = sayIt('Hello TypeScript'); // error!


  </code></pre>
        </section>

        <section>
          <h2>Type Check ausschalten</h2>
          <p>
            Mit <code>@ts-ignore</code> (als Kommentar) kann wird die Überprüfung der nächsten Zeile
            ausgeschaltet:
          </p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = "Hamburg";

  city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

  // @ts-ignore
  city = 20259; // ok
  </code></pre>
          <p class="fragment">
            Nützlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei
            Migration
          </p>
        </section>
        <section>
          <h2>null und undefined</h2>
          <div class="fragment">
            <p><code>null</code> muss explizit zugelassen werden <em>(strictNullChecks</em>):</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = null; //Type 'null' is not assignable to type 'string'.

  let optionalCity:string|null = null; // OK
              </code></pre>
          </div>
          <div class="fragment">
            <p><code>undefined</code> muss ebenfalls explizit zugelassen werden:</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
    let city:string = undefined; //Type 'undefined' is not assignable to type 'string'.

    let optionalCity:string|undefined = undefined; // OK
    let optionalCity:string|undefined|null = null; // OK
                </code></pre>
          </div>
          <div class="fragment">
            <p>
              Optionale Parameter können mit ? gekennzeichnet werden (erlauben dann auch
              <code>undefined</code>)
            </p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  function greet(name: string, greeting?: string) {
    console.log(`${greeting || 'Hello'}, {name}`);
  }

  greet('Susi', 'Moin')// Moin, Susi

  // 2. Parameter ist optional:
  greet('Klaus'); // Hello, Klaus

  greet('Peter', null); // Argument of type 'null' is not assignable
                        // to parameter of type 'string | undefined'.
              </code></pre>
          </div>
        </section>

        <section>
          <h2>Eigene Typen</h2>
          <p>
            Mit <code>interface</code> und <code>type</code>können eigene Typen (Objekt-Strukturen)
            definiert werden:
          </p>

          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
  // Komplexer Typ
  interface Person {
    name: string; // Pflicht
    livesIn?: string; // Optional
  }

  // Alternativ (interface und type fast synonym)
  type Person = { name: string; livesIn?: string; }

  const susi: Person = { // OK
    name: 'Klaus',
    livesIn: 'Hamburg'
  };
  const klaus: Person = { // OK (livesIn ist optional)
    name: 'Klaus'
  }

  const helmut: Person = {} // Error: Property 'name' is missing

  const lukas: Person = {
    name: 'Lukas',
    profession: 'Lokführer'
  } // Error: 'profession' does not exist in type 'Person'.
                 </code></pre>
        </section>

        <section>
          <h2>Eigene Typen II</h2>
          <p>Eigene Objekt-Typen können sowohl "Attribute" als auch Funktionen enthalten:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
            // Komplexer Typ
            type Person {
              name: string; // Pflicht
              greet(greeting: string): string;
            }

            const p:Person = {
              name: "Klaus",
              greet(greeting: string) {
                return `${greeting}, ${this.name}`
              }
            }
            p.greet("Hello"); // OK
            p.greet(123); // ERR: Argument of type '123' is not
                          // assignable to parameter of type 'string'.

            const wrong:Person = {
              name: "Susi", // OK
              greet(greeting: number) { return "hello" }
                // ERR: Type '(greeting: number) => string' is not assignable to
                //      type '(greeting: string) => string'.
                //      Types of parameters 'greeting' and 'greeting' are incompatible.
                //      Type 'string' is not assignable to type 'number'.
            }
                           </code></pre>
        </section>
        <section>
          <h2>Union Types</h2>
          <p>Variablen, Parameter etc. können mehr als einen Typ annehmen:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

function printNameOrTitle(obj: Person | Movie) {

  console.log(obj.title); // ERR: Property 'title' does not
                          // exist on type 'Person | Movie'

  if ("title" in obj) { // Abfrage ist ein "Type Guard"
    // obj ist Movie hier, title ist definiert
    console.log(obj.title);
  } else {
    // obj ist Person hier: name ist definiert
    console.log(obj.name);
  }
}

printNameOrTitle({name: "Klaus"}); //OK
printNameOrTitle({title: "Pulp Fiction"}); //OK
printNameOrTitle({label: "Save"}); // ERR

          </code></pre>
        </section>
        <section>
          <h2>Type Guards</h2>
          <p>Durch einen Type Guard können Typen "eingeengt" werden</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion true zurueckgibt, nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie ist
function isMovie(candidate: any): candidate is Movie {
  return ("title" in candidate);
}

function printNameOrTitle(obj: Person | Movie) {
  if (isMovie(obj)) {
    // movie
  }
}

          </code></pre>
        </section>
        <section>
          <h2>Type Assertions</h2>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion zurueckkehrt (kein Error geworfen wird) nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie  ist
function assertIsMovie(candidate: any): asserts candidate is  Movie {
  if ("title" in candidate) {
    return;
  }
  throw new Error("Candidate is not a movie!")
}

function printTitle(hopefullyAMovie: any) {
  assertPersonIsMovie(hopefullyAMovie)
  // hopefullyAMovie ist jetzt Movie
  hopefullyAMovie.title; // OK
}

          </code></pre>
        </section>
        <section>
          <h2>String Literal Types</h2>
          <p>Beispiel: String Aufzählungstyp</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Beispiel:
type View = "POST_LIST" | "POST_EDITOR";

const s:View = "POST_LIST"; // OK
const t:View = "POST_LISTE" // FEHLER

function setView(v: VIEW) {
    if (v === "POST_LIST") { ... } // ok
    if (v === "POST_LISTE") { ... } // error: immer false
}

setView("POST_LIST"); //OK
setView("POST_LISTE"); // ERROR
          </code></pre>
        </section>

        <section>
          <h3>Typ-sicherheit in useState</h3>
          <ul>
            <li>Der Typ von useState wird grundsätzlich von TypeScript automatisch abgeleitet</li>
            <li>
              <pre><code class="line-numbers typescript" data-leftpad>
function PostEdior() {
  const [title, setTitle] = React.useState("");

  // greeting is string, because initial value is a string
  setGreeting("huhu"); // OK
  setGreeting(666); // ERROR (wrong Type)
  setGreeting(null); // ERROR (wrong Type)
  console.log(title.toUpperCase()); // OK
}
            </code></pre>
            </li>
            <li>Du kannst alternativ den Typen auch explizit setzen</li>
            <li>Das ist in einigen Fällen sogar erforderlich:</li>
            <li>
              <ul>
                <li>Wenn du mehr als einen Typen angeben willst, z.B. null oder string</li>
                <li>
                  Wenn du eine Liste oder ein Objekt im Zustand hast, dessen Typ TypeScript nicht
                  ermitteln kann
                </li>
              </ul>
            </li>
            <li>
              <pre><code class="line-numbers typescript" data-leftpad>

function App() {
  const [error, setError] = React.useState&lt;null|string>(null);

  const [greetings, setGreetings] = React.useState&lt;string[]>([]);

  const [address, setAddress] = React.useState&lt;Address|undefined>();

  // ...
}
                            </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>Übung: Hello, TypeScript!</h2>
          <h3>
            <em>Mach dich mit den Grundzügen der Sprache TypeScript vertraut</em>
          </h3>

          <ol class="x-list">
            <li>Diese Übung machen wir im TypeScript Playground!</li>
            <li>
              Öffne dazu den TypeScript Playground im Browser: https://www.typescriptlang.org/play/
            </li>
            <li>
              Kopiere den Inhalt der Datei <code>material/ts-intro/uebung.ts</code> in den
              Playground-Editor
            </li>
            <li>Darin enthalten sind zahlreiche Compile-Fehler 😱</li>
            <li>
              Bitte ergänze die fehlenden Typ-Angaben, Hinweise und Todos findest du in der Datei
            </li>
            <li>Mögliche Lösung: <code>material/ts-intro/uebung_loesung.ts</code></li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="t4" -->
# Teil 4
## Komponenten-Hierarchien
* Themen:
  * [Properties von Komponenten](#/t4-properties)
  * [Kommunikation und Datenfluss](#/t4-komponenten-datenfluss)
  * [Listen mit JSX](#/t4-listen-mit-jsx)

  </textarea
          >
        </section>

        <!-- - - - - - - - - - - - - - - - PROPS HIER ERST - - - - - - - - - - - - - - -  -->
        <section id="t4-properties">
          <h3>React: Properties</h3>
          <p>Live: Die TagChooser-Komponente einbinden</p>
          <ul>
            <li>
              Mit <b>Properties</b> können einer Komponente von <b>außen</b> Werte und Eigenschaften
              übergeben werden

              <pre><code class="javascript"  >
function PostEditor() {
    // type, onChange und value sind Properties!

    return (
      &lt;input type="text" onChange={() => setTitle("...")} value={title}&lt;/h1>
    );
  }
}
            </code></pre>
            </li>
            <li><b>Properties</b> können innerhalb der Komponente nicht verändert werden</li>
            <li>
              Zum Vergleich: <b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der
              Komponente (die verändert werden kann)
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties ("Props") einer Komponente</h3>
          <ul>
            <li>Komponenten können beliebig eigene Properties definieren</li>
            <li>
              Bei der Angabe der Properties bei der Verwendung einer Komponente werden die
              Properties wie von HTML gewohnt in der Notiation
              <code>name=value</code> hingeschrieben
            </li>
            <li>
              <pre><code class="javascript"  >
&lt;TagChooser title="Select tags for your post" availableTags={["JS", "Web Development" ]} />
               </code></pre>
            </li>
            <li>
              ...alle angegebenen Properties werden von React "gesammelt" und in
              <b>einem Objekt</b> an die Komponente übergeben
            </li>
            <li>Das Objekt ist immer das <b>erste Funktionsargument</b> einer Komponente</li>
            <li>
              <pre><code class="javascript"  >
function TagChooser(props) {
    // props:
    //  {
    //     title: "Select tags for your post",
    //     availableTags: ["JS", "Web Development" ]
    // }

    return ...;
}
              </code></pre>
            </li>
            <li>
              <pre><code class="javascript"  >
// Mit Destructuring
function PostEditor( {title, availableTags} ) {

    return ...;
}
                                </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Properties mit TypeScript
<!-- .slide: class="left" -->
- Der erste Parameter einer Komponente ist immer ein `object`
- Mit TypeScript kannst du beschreiben, welche Properties deine Komponente darin erwartet und von welchem Typ die sind
  - Daran ist aus TypeScript-Sicht nichts React-spezifisch
- Dazu musst du mit `type` (oder `interface`) das `props`-Objekt beschreiben
- Wie du den Typen nennst, spielt keine Rolle.
  - In der Regel ist die Konvention entweder nur `Props` oder `KomponentenNameProps`
  * ```typescript
    type TagChooserProps = {
      // optionales Property:
      title?: string;

      // Liste mit Strings:
      availableTags: string[]

      // Auch (Callback-)Funktionen sind erlaubt:
      onTagSelected(tag: string): void
    }
    ```

* In der Funktionssignatur eurer Komponente gebt ihr den Typen dann an:
  * ```typescript
    export default function TagChooser(props: TagChooserProps) { /* ... */ }
    ```
  * ```typescript
    // Mit Destructuring:
    export default function TagChooser({title, availableTags}: TagChooserProps) { /* ... */ }
    ```

          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Properties: Default-Werte</h3>

          <p>
            Mit dem Object Destructuring-Operator können <b>Default-Werte</b> angegeben werden, für
            Eigenschaften, die aus einem Objekt gelesen werden, aber dort nicht angegeben (bzw.
            undefined) sind:
          </p>
          <p>
            Für den Aufrufer sind die Properties dann optional, innerhalb der Komponente weiß
            TypeScript aber, dass ein Wert vorhanden ist (und kennt auch dessen Typ)
          </p>

          <pre><code class="javascript">
function TagChooser({title = "Select Tag", availableTags}: TagChooserProps) {
  // 'title' ist hier in jedem Fall vom Typ 'string', auch wenn
  //  das vom Aufrufer nicht gesetzt wird

  // ...
}
          </code></pre>
          <pre><code class="javascript">
// title in der Komponente ist "Select Tag"
&lt;TagChooser availableTags={["JS", "React"]} />
          </code></pre>
        </section>

        <!--        <section>-->
        <!--          <h3>Virtual DOM</h3>-->
        <!--          <p>Beispiel: <code>react-intro/steps/2b-rendering</code></p>-->
        <!--        </section>-->

        <section data-markdown>
          <textarea data-template>
<!-- .slide: class="left" -->
<!-- .slide: id="t4-listen-mit-jsx" -->
### Listen in React

* JSX hat keine eigene Syntax zum Erzeugen von Listen-Darstellungen (im Gegensatz zu anderen Template-Sprachen, z.B. `ng:for` in Angular)
* Stattdessen verwendet man das normale [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) um Listen mit "Daten" auf Listen mit "UI" abzubilden
* ```typescript
  // Beispiel: eine Liste mit Tags
  const availableTags = [ "JavaScript", "React" ];
  ```
* ```typescript
  // Beispiel JavaScript: Mappen von Werten auf neue Werte
  const t = availableTags.map( t => t.toUpperCase());
    // t: [ "JAVASCRIPT", "REACT" ]
  ```
* Beim Erzeugen von Listen in React muss jedes Element ein [`key`-Property](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) bekommen, das innerhalb der Liste eindeutig sein muss

* ```typescript
  // Beispiel: In React zur Erzeugung von Listen:
  const list = availableTags.map(t => <li key={t}>Tag: {t}</li>
    // <li key="JavaScript">Tag: JavaScript</li>
    // <li key="React">Tag: React</li>
  ```
* ```typescript
  // Komplettes Beispiel:
  function TagChooser({availableTags}: TagChooserProps) {
    // ...
    return <ul>
      {availableTags.map(t => <li key={t}>Tag: {t}</li>}
    </ul>;
  }
  ```

* Doku: https://react.dev/learn/rendering-lists

  </textarea
          >
        </section>

        <section>
          <h2>Übung: Ein TagChooser</h2>
          <em>Schritt 1 für den TagChooser: Darstellung der "available" Tags</em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="xx-list">
            <li>In <code>TagChooser.tsx</code> gibt es bereits eine TagChooser-Komponente.</li>
            <li>Diese Komponente musst du um Properties erweitern</li>
            <li>Außerdem musst du darin die übergebenen (<code>availableTags</code>) anzeigen</li>
            <li>Du findest dazu Hinweise direkt in der Datei.</li>

            <li>Mögliche Lösung: <code>steps/05_props</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams 🙋‍♀️</li>
          </ol>
        </section>

        <section>
          <h3>Hintergrund: Virtual DOM</h3>
          <p>"Rendern" hat leider doppelte Bedeutung!</p>
          <img src="slides/images/vdom.png" style="height: 650px" />
        </section>

        <section>
          <h2>React Devtools</h2>
          <em>React Developer Tools für Chrome und Firefox</em>
          <p>Untersuchen der React Anwendung zur Laufzeit</p>
          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/"
                target="_blank"
                >Firefox</a
              >
            </li>
          </ul>

          <p><img src="slides/images/screenshot-react-dev-tools.png" /></p>
        </section>
        <!-- <section>
          <h3>Render Zyklus</h3>
          <img src="slides/images/render-cycle.png" height="550px" />
        </section> -->

        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="t4-komponenten-datenfluss" -->
## Datenfluss: Wie können Komponenten untereinander kommunizieren?
* 👉 `PostEditor` und `TagChooser`
          </textarea>
        </section>

        <!--        <section>-->
        <!--          <h3>Smart und Dumb-Komponenten #1</h3>-->

        <!--          <p>-->
        <!--            Zur Erinnerung: in React bauen wir Komponenten. Komponenten bestehen aus Logik, Zustand-->
        <!--            und UI (HTML-Elemente und Styling)-->
        <!--          </p>-->
        <!--          <p>-->
        <!--            Ein bekanntes Muster ist, die Komponenten in zwei Arten aufzuteilen:-->
        <!--            <b>Smart (oder Controller)</b>- und <b>Dumb oder (Presentation-)</b>-Komponenten-->
        <!--          </p>-->
        <!--          <p>Technisch sind die Komponenten identisch, also "normale" React-Komponenten</p>-->
        <!--          <p>Nur ihre <b>Aufgabe</b> ist anders definiert...</p>-->
        <!--        </section>-->

        <section>
          <h3>Datenfluss in React-Anwendungen</h3>
          <p>
            <em
              >In React erfolgt der Datenfluss zwischen Komponenten
              <b>immer von oben nach unten</b>:</em
            >
          </p>
          <ol>
            <li>
              Eine Parent-Komponente hat <b>Zustand (State)</b> und ggf. Logik, um mit dem Zustand
              zu arbeiten
            </li>
            <li>
              Die Parent-Komponente reicht Daten per Properties an ihre Kind-Komponenten weiter
              (z.B. Daten aus dem Zustand)
            </li>
            <li>
              Außerdem gibt die Parent-Komponente <b>Callback-Funktionen als Properties</b> an ihre
              Kind-Komponenten (als eine Art Event-Handler)
            </li>
            <li>
              Bei einem Ereignis (zum Beispiel neues Tag ausgewählt) ruft die Kind-Komponente die
              Callback-Funktion der Parent-Komponente auf
            </li>
            <li>
              In der Callback-Funktion findet dann die fachliche Verarbeitung des Events statt.
              Dabei kann die Parent-Komponente zum Beispiel ihren <b>State aktualisieren</b>
            </li>
            <li>
              Das Ändern des States triggert das <b>erneute Rendern der Komponenten-Hierarchie</b>,
              so dass sowohl Parent- als auch Kind-Komponente ihre Darstellung gemäß den
              aktualisierten Daten anzeigen können
            </li>
          </ol>
          <ul>
            <li>
              Dieses Verhalten haben wir bei der eingebauten <code>input</code>-Komponente bereits
              gesehen. (<code>value</code> und <code>onChange</code>-Property)
            </li>
            <li>
              👉 Durch das pauschale neurendern auch aller Kind-Komponenten kann es nicht zu
              <b>Inkonsistenzen</b> in der Darstellung durch "vergessenes" Rendern kommen.
            </li>
          </ul>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Kontrollierte" und "unkontrollierte" Komponenten
* Komponenten, die von einer anderen Komponente "kontrolliert" werden, werden **controlled components** in React genannt
* Diese Komponenten verlassen sich darauf, dass ihre Parent-Komponente den Zustand verwalten
* Beispiele für `controlled components`:
    * `input` (mit `onChange` und `value`): Oberkomponenten hält den Inhalt des Eingabefelds und steuert, wann bzw. wie dieser geändert werden soll.
    * `TagChooser` (mit `selectedTags` und `onSelectionChange`): PostEditor kontrolliert, welche Tags ausgewählt sind und was passieren soll, wenn sich die Auswahl ändert
    (PostEditor könnte sich zum Beispiel entschliessen, eine Auswahl zu ignorieren, oder unabhängig vom TagChooser die Tags zurückzusetzen)
* Beispiel für eine unkontrollierte Komponente:
    * `TagChooser` (in der bisherigen Form mit lokalem Zustand): Der PostEditor hat keinen Einfluss auf die Auswahl der Tags
    * `PostEditor`
  </textarea
          >
        </section>

        <section>
          <h3>Komponenten-Hierarchie mit Properties und Callback-Funktionen</h3>
          <img src="slides/images/posteditor-tagchooser-hierarchy.png" height="1000px" />
        </section>
        <section data-markdown="">
          <textarea data-template>
### Beispiel: PostEditor und TagChooser
* Der PostEditor enthält die Liste aller Tags, sowie die aktuell für den neuen Post ausgewählten Tags
* Der PostEditor gibt die ausgewählten Tags an die TagChooser-Komponenten
* Der PostEditor gibt außerdem eine Callback-Funktion an den TagChooser
* Der TagChooser ruft diese Callback-Funktion auf, sobald sich die Auswahl der Tags geändert hat
* ```typescript
  function PostEditor() {
    const [tags, setTags] = useState<string[]>([]);

    return <>
      { /* ... */ }
      <TagChooser selectedTags={tags} onSelectionChange={setTags} />
    </>
  }
  function TagChooser({selectedTags, onSelectionChange}) {
    // kein State mehr!

    const handleTagClick = () => {
      // wenn ein Tag angeklickt wird, neue Auswahl ermitteln
      // und damit die Oberkomponente informieren
      const newSelectedTags = ...;

      onSelectionChange(newSelectedTags);
    }

    return /* ... */;
  }

  ```
  </textarea
          >
        </section>

        <section>
          <h2>Übung: Mache den TagChooser zu einer "kontrollierten" Komponente</h2>
          <p>
            <em> Der PostEditor soll die Liste der ausgewählten Tags verwalten </em>
          </p>
          <ol class="xx-list">
            <li>
              In <code>react-intro/material/06_hierarchien</code> findest du eine
              <code>TagChooser.tsx</code>-Datei
            </li>
            <li>In dieser Datei findest du eine Beschreibung der erforderlichen Schritte</li>
            <li>
              Du kannst die Änderungen entweder an deinem eigenen TagChooser im Workspace
              vornehmen...
            </li>
            <li>
              ...oder du kopierst dir die <code>TagChooser.tsx</code>-Datei in einen Workspace als
              Ausgangsbasis
            </li>
            <li>Mögliche Lösung: <code>steps/06-hierarchien</code></li>
            <li>Wenn Du fertig bist, bitte in Teams "Hand heben" 🙋‍♀️</li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Lifting State up"
* Der Zustand ist an eine Komponente und deren Lebenszyklus gebunden
* Wenn eine Komponente von React aus dem DOM entfernt wird ("unmount"), geht auch deren Zustand verloren
* Wenn der PostEditor also entfernt wird gehen auch alle Eingaben und die ausgewählten Tags verloren
* Dazu ein Beispiel
* <!-- .element: class="demo" --> PostPreview in 07_exkurs_lifting_state_up
---
### "Lifting State up"
* Wenn ihr Zustand benötigt, der das Entfernen einer Komponente überlebt, müsst ihr den Zustand in der Komponente nach oben schieben
* Dasselbe gilt auch, wenn ihr Zustand habt, der von mehr als einer Komponente verwendet werden soll
  * Erinnerung: Kommunikation erfolgt immer von oben nach unten, nie auf gleicher Ebene
* Soweit nach oben, bis ihr zu einer Komponente kommt, die über den Komponenten steht, die den Zustand benötigen
* Dieses Pattern wird als ["Lifting State up"](https://react.dev/learn/sharing-state-between-components#lifting-state-up-by-example) bezeichnet
* Im `PostPreview`-Beispiel wird der Zustand aus dem `PostEditor` auch in `PostPreview` benötigt und wird dem entsprechend in
            `PostEditorPage` hochgeschoben
* <img src="slides/images/lifting-state-up.png" height="500px"/>

          </textarea>
        </section>
        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="#/t5-data-fetching" -->
# Teil 5
## Data Fetching
* *Lesen und Schreiben von Daten von einem Backend (REST/HTTP)*
---
## Data Fetching
* Themen
  * [Ausführen von HTTP Requests mit "ky"](#/ky)
  * [Hintergrund: Asynchroner Code mit JavaScript Promises](#/t-promises)
  * [TanStack Query](#/ts-query)
  * [Daten lesen mit useQuery](#/ts-use-query)
  * [Mutations](#/ts-query-mutations)
---
## Data Fetching
* <!-- .element: class="demo" --> Schritt-für-Schritt Demo:
  * `react-intro/steps/20_data_fetching`
  * `react-intro/steps/25_mutations`
          </textarea>
        </section>

        <!-- =================================================================================================== -->
        <!-- ==   Promises und Speichern                                                                                          == -->
        <!-- =================================================================================================== -->
        <section>
          <h2>Server-Zugriffe</h2>
          <ul class="x-list">
            <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
            <li>
              In der Regel braucht man zwei Dinge:
              <ol>
                <li>Eine (low-level) Bibliothek zum Ausführen der eigentlichen Requests</li>
                <li>
                  Eine (high-level) Bibliothek zum Arbeiten mit den Daten mit erweiterten Features
                  wie Caching und Fehlerbehandlung
                </li>
              </ol>
            </li>
            <li>
              Häufig in React verwendet: <b>fetch</b> API
              <ul>
                <li>Browser-API zum Ausführen von HTTP Requests</li>
                <li>
                  Dokumentation:
                  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"
                    >Fetch API (MDN)</a
                  >
                </li>
              </ul>
            </li>
            <li>
              Im Workshop verwenden wir <a href="https://github.com/sindresorhus/ky">ky</a>
              <ul>
                <li>Kleine Bibliothek, die auf fetch basiert</li>
                <li>
                  Abstraktion für typische Anwendungsfälle macht die Bedienung etwas einfacher
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Die ky Bibliothek
<!-- .slide: id="ky" -->
* Auf dem `ky`-Objekt sind Funktionen definiert, mit denen ihr Requests mit unterschiedlichen HTTP Methoden machen könnt (`get`, `post`, ...)
* Die Methoden haben jeweils zwei Parameter:
  1. Die Methoden erwarten die URL, die ihr aufrufen wollt
  2. (optional) Ein Objekt mit weiteren Einstellungen für einen Request, z.B. der Payload
* Die Funktionen liefern jeweils ein Promise mit einem `Response`-Objekt zurück
  * Dabei handelt es sich um eine Erweiterung des standardisierten [Response-Objektes des Browsers](https://developer.mozilla.org/en-US/docs/Web/API/Response).
  * In ky gibt es darauf noch Hilfsmethoden, die es vereinfachen mit dem Payload der Antwort zu arbeiten
* Als Typ-Argument kann jeweils der erwartete Rückgabe-Typ in TypeScript definiert werden
  * Achtung! Nur Build-Zeit-Prüfung, zur Laufzeit findet keine Prüfung statt, ob die Antwort vom Server dem angegebenen
    Typen entspricht.

* ```typescript
  // HTTP GET Request
  const blogPosts = await ky
          .get<BlogPost[]>(`http://localhost:7000/posts`)
          .json();
  // ...
  ```
* ```typescript
  // HTTP POST Request mit Objekt als Body
  const newBlogPost = await ky.post<BlogPost>("http://localhost:7000/posts", {
          json: { title, body, tags }
  // ...
  });
  ```
  </textarea
          >
        </section>

        <section data-state="exkurs" id="t-promises">
          <h3>Hintergrund: Promises in JavaScript</h3>

          <p class="fragment">
            Ein Promise liefert einen "Versprechen" auf einen Wert zurück, der evtl. erst in der
            Zukunft ermittelt werden kann
          </p>
          <p class="fragment">
            Damit können wir asynchrones Verhalten in JavaScript Applikation abbilden
          </p>
          <pre class="fragment"><code class="javascript" contenteditable>
// "getNameAsync" ist eine ausgedachte Funktion, 
// die ein Promise zurückliefert, 
// das "irgendwann" den String "Klaus" zurückgibt
const promise = getNameAsync();
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise.then(name => console.log(name));
// Ausgabe "irgendwann": "Klaus"
  </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>Promises</h3>
          <p>Promises können verkettet werden</p>
          <pre><code class="javascript" contenteditable>
// Annahme: 'getNameAsync' liefert "irgendwann" den String "Klaus" zurück
const promise = getNameAsync()

// Wird mit dem ersten Wert aufgerufen und gibt neuen Wert zurück
.then(name => getGreetingAsync(name)) 

// wird mit dem zweiten Wert (aus vorherigem then) aufgerufen
.then(greeting => console.log(greeting));

// Ausgabe "irgendwann": 
// "Hello, Klaus"

  </code></pre>
          <p class="fragment">
            Die <code>then</code>-Funktion gibt <b>immer</b> ein Promise zurück
          </p>
        </section>

        <section data-state="exkurs">
          <h3>Fehlerbehandlung</h3>
          <h4>Mit <code>catch()</code> kann man Fehler fangen und darauf reagieren</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
  const promise = getNameAsync()

    .then(name => { if (name === null) throw new Error("No name found") })

    .then(greeting => console.log(greeting));

    .catch(error => console.error(`Greeting failed: ${error}`))
  
    // Wenn 'getNameAsync' null zurückliefert ist die Ausgabe:
    //   Greeting failed: No name found
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section data-state="exkurs">
          <h3>Finally</h3>

          <p class="fragment">
            Eine <code>finally</code>-Callback-Funktion wird nach dem letzten <code>then</code> bzw.
            <code>catch</code>-Block ausgeführt.
          </p>

          <p class="fragment">
            Die finally-Funktion wird <b>immer</b> ausgeführt (unabhängig davon, ob vorher ein
            Fehler aufgetreten ist oder nicht
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              const promise = getNameAsync();

                .then(name => { if (name === null) throw new Error("No name found") })

                .then(greeting => console.log(greeting));

                .catch(error => console.error(`Greeting failed: ${error}`))

                .finally( () => console.log("Goodbye!") );
              
                // Output (error): Greeting failed: No name found
                // Output (log): Goodbye!
                </code></pre>
        </section>

        <section data-state="exkurs">
          <h2>async / await</h2>
          <p>"Wrapper" um Promises</p>
          <p>Erlaubt es, asynchronen Code "linear" hinzuschreiben</p>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>await</code> wartet bis ein Promise aufgelöst wird</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }
    
    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);
    
      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>async</code> machen eine Funktion zu einer "async function"</p>
          <p class="fragment">
            Eine <code>async</code> Funktion gibt &nbsp; <b>immer</b> ein Promise zurück
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }
  
  const greeting = greet('Klaus');
  
  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> Funktion als Fat Arrow Funktionen:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;                
    
  const greeting = greet('Klaus');
    
  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>async / await</h3>
          <p>
            Anstatt <code>then</code> oder <code>catch</code>-Ketten kannst Du einfach mehrere
            <code>await</code> Statements verwenden und try/catch für die Fehlerbehandlung:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};
  
  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
                      </code></pre>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Daten laden mit ky
* In einer ganz einfachen Variante können wir wie folgt Daten vom Backend in unsere Komponente laden:
* ```typescript
  export default function PostList() {
    const [posts, setPosts] = useState<BlogPost[]>([]);

    const handleLoadPosts = async () => {

      // Achtung! get() bzw. json() liefert Promise zurück!
      //   -> mit await warten!
      const receivedPosts = await ky.get<BlogPost[]>("http://localhost:7000/posts")
            .json();

      // geladene Posts in den State packen:
      setPosts(receivedPosts);
    }

    return <div>
      <button onClick={handleLoadPosts}>Load Posts</button>
      // ...Posts rendern...
      </div>
  }
  ```
* Hier fehlen aber wichtige Features:
  * Fehlerhandling
  * Verhindern doppelter Requests
  * Caching
  * Zugriff auf die Daten in weiteren Komponenten
* 👉 deswegen verwendet man fetch bzw. ky üblicherweise mit einer Data Fetching Bibliothek
---
<!-- .slide: id="ts-query" -->
## Data Fetching Bibliotheken
* Es gibt spezialisierte Bibliotheken für React, die typische Anwendungsfälle und Probleme beim Lesen von Daten adressieren
  * [TanStack Query](https://tanstack.com/query/latest): Prominenteste Bibliothek zum Laden/Speichern von Daten inklusive Cache-Funktion
  * [SWR](https://swr.vercel.app/)
  * [Redux Toolkit Query](https://redux-toolkit.js.org/rtk-query/overview): Arbeiten mit APIs in Redux-Anwendungen
  * [Apollo GraphQL Client](https://www.apollographql.com/docs/react/): Client für GraphQL APIs mit Cache und Statemanagement Möglichkeiten
* Diese Bibliotheken haben alle ähnliche Konzepte:
  * Hooks zum Laden/Speichern von Daten
  * globales Caching von Daten (auch zur Sicherstellung der konsistenten Darstellung)
    * Strategien zur Aktualisierung von Daten (auch automatisch im Hintergrund)
  * Unterstützung für das [Suspense-Feature von React](https://react.dev/reference/react/Suspense) (mit Ausnahme von RTK Query)

---
## TanStack Query
### Schritt-für-Schritt: Laden von Daten mit "TanStack Query"

* 👉 `PostListPage`

---
### Der QueryClient

* Zentrales Konfigurationsobject: `QueryClient`
* React-unabhängig
* Wird beim Starten der Anwendung initialisiert
* Oft reichen Default-Einstellung
* Es können aber z.B. globale Refetch-Policies eingestellt werden
* Das Objekt wird per QueryClientProvider in die Anwendung gereicht
* ```typescript
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false
      }
    }
  });

  root.render(
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  );
  ```
* In unserem Workspace wird der QueryClient in `create-query-client.ts` erzeugt

---
### Laden von Daten: useQuery
<!-- .slide: id="ts-use-query" -->
* [Queries](https://tanstack.com/query/latest/docs/react/guides/queries) werden mit dem `useQuery`-Hook ausgeführt
* [Der `useQuery`-Hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) erwartet ein Konfigurationsobjekt
  * `queryKey`: Array mit Query Keys (zur Interaktion mit dem Cache)
  * `queryFn`: Funktion zum Laden der Daten
  * Weitere Konfigurationen (optional)
* ```typescript
  import { useQuery } from "react-query";

  function BlogListPage() {

    const result = useQuery({
            queryKey: ['posts'],
            queryFn() { /* ... */ }
    );

    // ...
  }
  ```
---
### Query Function

* `useQuery` erwartet eine [Query-Function](https://tanstack.com/query/latest/docs/react/guides/query-functions), die den eigentlichen Request ausführt
* Diese Funktion müsst ihr selbst implementieren, z.B. mit ky oder fetch
* Die Funktion muss ein Promise mit den gelesenen Daten zurückliefern
* Wenn es einen Fehler gab, muss die Funktion einen Fehler werfen
  * Wenn ihr `ky` benutzt, passiert das automatisch bei allen HTTP Status Codes die nicht im 200er-Bereich liegen
  * Wenn ihr `fetch` benutzt, müsst ihr selber den Status Code überprüfen und ggf. einen Fehler werden
* Aus dem Rückgabe-Typ der Query-Funktion leitet `useQuery` den TypeScript-Typ für die gelesenen Daten ab.
* ```typescript
  import { useQuery } from "react-query";

  function BlogListPage() {

    const result = useQuery({
        queryKey: ['posts'],
        queryFn(): {
          return ky.get("http://...").json();
        }
    );

    // ...
  }
  ```

---

### Rückagebwert von `useQuery` (Query Ergebnis)

* `useQuery` liefert ein Objekt zurück, das u.a. folgende Informationen umfasst:
  * `isLoading`: Der Query lädt noch (und es sind keine Daten im Cache)
  * `isSuccess`: Daten sind geladen
  * `isError`: Es ist ein Fehler aufgetreten
  * `data` enthält die geladenen Daten (wenn `isSuccess` `true` ist)
  * `error`: Fehlerobjekt aus der Query-Funktion (wenn `isError` auf `true` gesetzt ist)
* Weitere [siehe Doku](https://tanstack.com/query/latest/docs/react/reference/useQuery)

---
### Query Keys

* [Query Keys](https://tanstack.com/query/latest/docs/react/guides/query-keys) werden verwendet, um das Ergebnis eines Queries identifizieren und cachen zu können
* Ein Query Key besteht aus einem Array von Werten
* Üblicherweise ist es ein Name (z.B. "posts") und dann ggf. weitere Parameter, zum Beispiel die Id eines Posts ("P1")
  oder die Sortierreihenfolge
  * Also alle Daten, die den Query exakt beschreiben
* ```typescript
  import { useQuery } from "react-query";

  function BlogPage({postId}) {

    // Für jeden Aufruf mit einer neuen postId
    //  wird das Ergebnis separat in den Cache gelegt
    const result = useQuery({
      queryKey: ['blogPost', postId],
      queryFn: () => ky.get(`http://localhost:7000/posts/${postId}`).json()
    });

    // ...
  }
  ```
* Wenn ein Query mit denselben Query Keys in mehr als einer Komponente ausgeführt wird...
  * ...stellt TanStack Query sicher, dass der Query nur einmal ausgeführt wird
  * ...wenn sich das Ergebnis ändert, werden alle Komponenten, die den Query verwenden, automatisch aus dem Cache aktualisiert
---
### TanStack Query: Mutations
<!-- .slide: id="ts-query-mutations" -->

* [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) werden verwendet, um Daten auf dem Server zu *verändern* (speichern, löschen)
* Üblicherweise werden dabei HTTP POST, PATCH, PUT oder DELETE Requests ausgeführt
* Der entsprechende Hook heißt [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
* Dessen API ist vergleichbar mit `useQuery`
* Auch der `useMutation`-Hook liefert Informationen über den Zustand der Mutation zurück
* ```typescript
  import { useMutation } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const mutation = useMutation({
      mutationFn() { ky.post("http://....", {json: { title, body } } ) },
      onSuccess() {
        // optional: wird aufgerufen, wenn die Mutation erfolgreich war
        // ...
      }
    });

    if (mutation.isSuccess) {
      return <h1>Blog Post saved!</h1>;
    }

    if (mutation.isError) {
      return <h1>Error: {mutation.error.toString()}</h1>;
    }

    // ...
  }
  ```
---
### TanStack Query: Mutations
* Im Gegensatz zu `useQuery` wird eine Mutation aber nicht automatisch ausgeführt, sondern wird explizit gestartet
* Dazu liefert `useMutation` die Funktion `mutate` zurück
* Übergeben wird der Funktion die zu schreibenden Daten
* ```typescript
  function PostEditor() {
    const [title, setTitle]  = useState("");

    const mutation = useMutation(/* ... */ );

    function saveBlogPost(newPost: NewBlogPost) {
      mutation.mutate();
    }

    // ...
  }
  ```
---
### Parameter für die Mutations
* Es gibt Szenarien, in denen benötigt eine Mutation Daten, die erst bei der Ausführung von `mutate()` feststehen
  * Informationen, die beim Aufruf von `useMutation()` noch nicht vorliegen
* Dazu kann der `mutate`-Funktion genau **ein** Parameter übergeben werden
* Wie dieser aussieht bestimmt ihr in der Definition der Mutation selbst
* Dieser Parameter entspricht nämlich dem ersten Parameter der `mutationFn`:
  * ```typescript
    const addPostMutation = useMutation({
      mutationFn(newBlogPost: NewBlogPost) { /* ... */ }
    })
    ```
* Wenn ihr mehr als einen "logischen" Parameter benötigt, müsst ihr ein Objekt verwenden:
* ```typescript
  type AddCommentParam = { postId: string, comment: string };

  const addCommentMutation = useMutation({
    mutationFn(param: AddCommentParam) {
      const url = `/api/posts/${postId}/comments;
      return ky.post(url, { json: { comment: param.comment } });
    }
  });
  ```

---
### Arbeiten mit dem Ergebnis

* Wenn eine Mutation ausgeführt wurde, bekommt ihr `data` bzw. `error` zurück
* Damit könnt ihr - wie bei `useQuery` - nach der Ausführung einer Mutation die UI aktualisieren, um zum Beispiel Fehlermeldungen anzuzeigen
* ```typescript
  function PostEditor() {
    const savePostMutation = useMutation(/*...*/);

    return <form>
      { /* ... */}

      {saveMutation.isError && <p>Fehler beim Speichern des Posts: {String(saveMutation.error)}</p>}
      {saveMutation.isSuccess && <p>Der Blogpost wurde erfolgreich gespeichert!</p>}
    </form>
  }
  ```
---
### Aktionen nach einer Mutation ausführen
* Um direkt nach Beendingung einer Mutation weitere Aktionen auszuführen, gibt es zwei Wege:
  1.  [`mutateAsync`](https://tanstack.com/query/latest/docs/framework/react/guides/mutations#promises) statt `mutate` zum Ausführen der Mutation nutzewn
  2.  `on`-Callback-Funktionen verwenden
* Mit `mutateAsync` könnt ihr _in einer Komponente_ auf das Ergebnis der Mutation warten. Das ist sinnvoll, wenn man Komponenten-spezfische Aktionen ausführen möchte.
  * `mutateAsync` liefert ein Promise mit den Daten der Mutation zurück.
  * Schlägt die Mutation fehl, wird das Promise verworfen (rejected)
* Beispiel:
* ```typescript
  function PostEditor() {
    const navigate = useNavigate(); // vom React Router

    const savePostMutation = useMutation({ /* ... */ });

    async function savePost(newPost: NewPost) {
      const result = await savePostMutation.mutate(newPost);
      // result ist hier das Ergebnis der (erfolgreichen) Mutation

      navigate("/"); // nach erfolgreicher Mutation zurück auf die Landingpage
    }

    // ...

  }
  ```
---
### Manuelles Aktualisieren von Queries

* Queries können per API manuell erneut ausgeführt werden
* Das kann zum Beispiel nach einer Mutation sinnvoll sein, um die geänderten/gespeicherten Daten im Cache zu aktualisieren
* Dazu wird die Funktion [`invalidateQueries`](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientinvalidatequeries) vom `QueryClient` verwendet
* Übergeben werden die Query Keys, deren Queries erneut ausgeführt werden sollen
* ```typescript
  import { useMutation, useQueryClient } from "react-query";

  function PostEditorPage() {
    const queryClient = useQueryClient();
    const mutation = useMutation({
      mutationFn() { /* ... */ },
      onSuccess() {
        // PostListPage-Query erneut ausführen, wenn Mutation erfolgreich war
        queryClient.invalidateQueries(['posts']);
      }
    });

    // ...
  }
  ```

---
### Zurücksetzen einer Mutation

* Wenn eine Mutation ausgeführt wurde, ist `status`, `data`, `error` usw. gesetzt
* Mit `reset` kann man diese Informationen zurücksetzen
* Das kann zum Beispiel nach einem Fehler sinnvoll sein, um die Fehlermeldung wieder verschwinden zu lassen
  * Zum Beispiel nach einer Benutzer-Interaktion
* Dann ist die Mutation "wie neu"
* ```typescript
  function PostEditor() {
    const addPostMutation = useMutation(/* ... */);

    return <form>
      { /* ... */ }

      <input onChange={e => {
        addPostMutaton.reset();
        // ...
      }} />

      { /* ... */ }
    </form>
  }
  ```
---
### Übung: TanStack Query
- Implementiere das Laden der Blog Posts sowie das Speichern eines neuen Blog Posts
- Vorbereitung:
  - Bitte zuerst das "Backend starten
  - Dazu im Verzeichnis `backend` ausführen: `npm install` und  `npm start`
  - Der "Blog-Server" läuft dann unter http://localhost:3000
- Damit die Anwendung einfach bleibt, zeigen wir die Blog-Liste und den PostEditor gemeinsam auf einer Seite an
- Das **Lesen der Blog-Posts** musst du in der Komponenten `PostListPage` implementieren
  - dort findest du weitere Hinweise
  - mögliche Lösung: `steps/20_data_fetching`
- Zum **Speichern des neuen Blog-Posts** musst du die Komponente `PostEditor` erweitern
  - im Verzeichnis `material/25_mutions` findest du eine `PostEditor`-Komponente mit weiteren Informationen dazu
  - du kannst die Anpassungen in deinem eigenen PostEditorm machen oder du kopierst `PostEditor.tsx` in deinen Workspace
  - mögliche Lösung: `steps/25_mutation`
---
<!-- .slide: id="t6-routing" -->
# Teil 6
## Clientseitiges Routing
---
## Clientseitiges Routing

* Themen:
  * URLs auf Komponenten abbilden
  * (Interne) Links, die die Anwendung neu rendern, ohne zum Server zu gehen

---

## Der React Router

* React bringt (im Gegensatz zu Angular) keinen Router mit
* In der Regel wird der **React Router** verwendet
* Homepage: [https://reactrouter.com/](https://reactrouter.com/)
* Aktuelle Version v6
* Alternative (aber noch ganz neues Projekt): [TanStack Router](https://tanstack.com/router/latest/docs/framework/react/overview)
  - Überragender TypeScript Support
  - Sehr komfortables Arbeiten mit Search Params
  - Code Generator und File-basierte Routen
---

### Der React Router
* <!-- .element: class="demo" --> Schritt-für-Schritt Demo
  * `createBrowserRouter`
  * Routen für PostListPage und PostEditorPage
  * Layout-Komponente

---
### React Router: Beispiel für Konfiguration

```tsx
const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    children: [
      {
        index: true,
        element: <PostListPage />
      },
      {
        path: "/editor",
        element: <PostEditorPage />
      },

      { path: "*", element: <NotFoundPage /> }
    ]
  }
]);

export default function App() {
  return <RouterProvider router={router} />;
}
```

---

### Der BrowserRouter

* Es gibt mehrere Implementierungen des Routers, der Stadard ist der `BrowserRouter`
* Beim navigieren wird dabei der Pfad im Browser verändert (analog zum normalen Browser-Verhalten bei serverseitigen Anwendungen)
* 👉 Demo im Browser, Netzwerkverkehr untersuchen
* Wenn ihr den Router in Produktion verwendet, müsst ihr euren Webserver so konfigurieren, dass bei allen angefragten Routen
            jeweils die `index.html`-Datei ausgeliefert wird

---

### Konfiguration der Routen: Welche Komponente soll für welche Route angezeigt werden?

* Mit dem `Route`-Objekt wird die Konfiguration beschrieben, welche Pfade es in Eurer Anwendung gibt, und welche Komponenten jeweils gerendert werden sollen.
* Es gibt zwei Notationen, eine Objekt- und eine Komponenten-Form
  * Beide sind identisch
  * Wenn ihr die Komponenten-Form verwendet, müsst ihr die Komponenten an die Funktion `createRoutesFromElements` übergeben
---
### Routen als Objekt

```typescript
  const routerConfig = createBrowserRouter([
    {
      path: "/",
      element: <RootLayout />,
      children: [
        {
          index: true,
          element: <PostListPage />
        },

        {
          path: "post/:postId",
          element: <PostPage />
        },
      ]
    }
  ]);
```
---
### Routen als Komponenten

```typescript
  const routerConfig = createBrowserRouter(
    createRoutesFromElements(
      &lt;Route path="/" element={&lt;RootLayout />}>

        &lt;Route index element={&lt;BlogListPage /> } />

        &lt;Route path="post/:postId" element={&lt;PostPage />}>

      &lt;/Route>
    )
  );
```

---
### Outlet

* Eine Komponente für eine Route kann die Komponenten für die Unter-Routen einbinden
* Auf diese Weise kann eine Oberkomponente zum Beispiel ein gemeinsames Layout implementieren
* Die Oberkomponente muss dann jeweils die Unterkomponenten rendern
  * Das funktioniert mit der [`<Outlet />`](https://reactrouter.com/en/main/components/outlet)-Komponente
  * ```javascript
    function App() {
      return &lt;div className="App">
        &lt;h1>Blog App</h1>
        &lt;Outlet />
      &lt;/div>
  }
```

---

### Index Routes

* Bei verschachtelten Routen muss für die Ober-Route eine Index Route gerendert werden
* Beispiel:
* ```typescript
  export const router = createBrowserRouter([
    {
      path: "/",
      element: <Layout />,
      children: [
        { path: "/editor",  element: <PostEditor /> }
      ]
    }
  ]);
  ```
* Hier wird `Blog` als `Outlet` in `App` für `/blog` gesetzt. Aber kein Outlet für `/`
* Dazu muss eine Index-Route definiert werden. Die wird unterhalb der Ober-Route eingesetzt und
  wird dann gerendert, wenn genau der Pfad der Ober-Route aufgerufen wird
* Statt `path` wird darin einfach `index` angegeben:
* ```typescript
  export const router = createBrowserRouter([
    {
      path: "/",
      element: <Layout />,
      children: [
        // "Index-Route" für /:
        { element: <PostListPage />, index: true },
        { path: "/editor",  element: <PostEditor /> }
      ]
    }
  ]);
  ```

---

### Fallback Route

* Mit `path="*"` kann eine Fallback-Route angegeben werden, die aktiv ist, wenn keine andere Route passt
* Beispiel:
* ```javascript
    &lt;Route path="/" element={&lt;App />}>
      &lt;Route path="blog" element={&lt;Blog />} />

      &lt;Route path="*" element={&lt;NotFound />} /> &lt;!-- Für alle Route, außer / und /blog -->
    &lt;/Route>
  ```

---

### Links

* Links müssen mit der [`Link`](https://reactrouter.com/docs/en/v6/components/link)-Komponente gerendert werden
* ```javascript
  function PostTeaser({post}) {
    return &lt;div>
      &lt;h1>{post.title}&lt;/h1>
      &lt;Link to={`/post/${post.id}`}>Read more&lt;/Link>
    &lt;/div>
  }
```
* Die `Link`-Komponente rendert ein `a`-Element, verhindert aber, dass der Browser Serveraufrufe durchführt,
  wenn darauf geklickt wird
* Das gilt nur für interne Links, externe Links wie gewohnt mit HTML `a`-Element
* Alternative: [`NavLink`](https://reactrouter.com/docs/en/v6/components/nav-link) weiß, ob der `to`-Pfad
  der gerade aktiven Route entspricht und kann sich dann anders darstellen ("Aktiver Link", "Aktiver Tab", ...)
  * ```javascript
    function NavBar() {
      return &lt;div>
        &lt;NavLink to={`/home}`} className={active => active ? "Tab--active":"Tab--default" }>Home&lt;/Link>
        &lt;NavLink to={`/about}`} className={active => active ? "Tab--active":"Tab--default" }>About&lt;/Link>
        &lt;NavLink to={`/profile}`} className={active => active ? "Tab--active":"Tab--default" }>Profile&lt;/Link>
      &lt;/div>
    }
```
* Mit `className` und `style` können Callback-Funktionen übergeben werden, die das konkrete Styling/CSS Klasse je nach Zustand
  (active bzw not-active) zurückliefern.

---

### Navigation per API

* Die [`Navigate`](https://reactrouter.com/docs/en/v6/components/navigate)-Komponente kann gerendert werden,
  wenn eine Komponente beim Rendern einen Redirect machen möhcte
* ```javascript
  function BlogPost() {
    const result = useQuery({ /* ... */ });

    if (result.isError) {
      return &lt;Navigate to="/error" />
    }

    return &lt;BlogPost post={post} />
  }
  ```
* Mit [`useNavigate`](https://reactrouter.com/en/6.16.0/hooks/use-navigate) kann auch per API, z.B. in einem Event Handler, ein Redirect gemacht werden:
* ```javascript
  function LogoutButton() {
    const useNaviate = useNavigate();

    function handleClick() {
      navigate("/");
    }

    return &lt;button onClick={handleClick}>Logout&lt;/button>
  }
  ```

---
### Übung: Router

* **Stelle die Anwendung auf den React Router um**
* Die beiden bekannten Seiten (Post Liste und Post Editor) sollen jeweils eine Route werden
* Außerdem soll es ein globales "Layout" geben, das den Anwendungstitel sowie zwei Links anzeigt
* Schreibe dafür die Router-Definition in `create-router.tsx`. Dort findest du auch weitere Informationen
* Eine mögliche Lösung findest Du in `30_router`



</textarea
          >
        </section>

        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="seiteneffekte" -->
# Seiteneffekte

  </textarea
          >
        </section>

        <section>
          <h3>Seiteneffekte</h3>
          <ul>
            <li>
              Als <b>Side effect</b> bzw. <b>Seiteneffekt</b> (könnte im deutschen auch mit
              "Nebenwirkung" übersetzt werden) wird in React Code bezeichnet, der Dinge außerhalb
              der umschließenden Komponenten-Funktion verändert.
            </li>
            <li>
              Beispiele sind: Manipulation des nativen DOM (z.B. Fenster-Titel setzen), einen Timer
              starten oder einen Server-Aufruf durchführen
            </li>
            <li>Seiteneffekte sind in der <b>Renderphase</b> einer Komponente verboten! 🚨</li>
          </ul>
        </section>

        <section>
          <h3>useEffekt-Hook</h3>
          <p>
            <em
              >Mit useEffekt kann eine Funktion registriert werden, die nach dem Rendern der
              Komponente ausgeführt wird</em
            >
          </p>
          <p>
            Diese <b>Effekt-Callback</b>-Funktion wird beim <em>commit</em> der Komponente
            ausgeführt
          </p>

          <div>
            <pre><code class="javascript"  >
            function App(props) {
              React.useEffect(
                () => console.log("I will run on EACH commit")
              );
            }
          </code></pre>
          </div>
          <div>
            2. Parameter (leeres Array) gibt an, dass die Funktion nur einmal ausgeführt werden soll
            <pre><code class="javascript"  >
              function App(props) {
                React.useEffect(
                  () => console.log("I will run only on 1st commit"),
                  []
                );
              }
            </code></pre>
          </div>
        </section>

        <section>
          <h3>useEffect Hook</h3>

          <p>Zwei Parameter:</p>
          <ol>
            <li>
              Callback-Funktion, die aufgerufen wenn entsprechendes Ereignis eintritt (z.B.
              initiales Rendern abgeschlossen)
            </li>
            <li>
              Ein Array mit Abhängigkeiten:
              <ul>
                <li>
                  Wenn kein Array angegeben wird, wird der Effekt nach jedem Rendern ausgeführt
                  (achtung! Endlosschleife möglich)
                </li>
                <li>
                  Wenn ein leeres Array angegeben wird, wird der Effekt nur nach dem 1. Rendern
                  ausgeführt
                </li>
                <li>
                  Wenn Werte angegeben werden, wird der Effekt ausgeführt, wenn sich mind 1 Wert
                  verändert hat
                </li>
                <li>
                  <b>Wichtig!</b> <em>Alle</em> Werte im Dependency-Array angeben, die darin
                  verwendet werden (Werte aus Props, State, ...)
                </li>
              </ul>
            </li>
          </ol>
        </section>
        <section data-markdown>
          <textarea data-template>
### useEffect Hook: Clean-up Funktion

* Um auf das Entfernen der Komponente aus dem DOM zu reagieren (z.B Resourcen
freigeben), kann die Callback-Funktion als Rückgabe eine "Clean-Up"-Funktion zurückliefern:
  * ```javascript
    function HelloEffect() {
      React.useEffect(
        () => {
          console.log("Ich bin gemounted worden");
          return () => console.log("Ich bin entfernt worden")
        },
        [])
      );
    }
  ```
* Die Clean-Up-Funktion wird immer ausgeführt, wenn die Komponente aus dem DOM entfernt wird
              und bevor der Effekt erneut ausgeführt wird.
* Mit der Clean-up-Funktion kann also immer die letzte Ausführung des Effekt-Callbacks "aufgeräumt" werden
  * ```javascript
    function PostEditor() {
      const [title, setTitle] = useState("");

      React.useEffect(
        () => {
          let currentTitle = title;
          console.log("Title: ", currentTitle);
          return () => console.log("Title war beim Commit:", currentTitle)
        },
        [ title ])
      );
    }
    ```

</textarea
          >
        </section>

        <section>
          <h3>Beispiel: Aktualisieren des Browsertitels</h3>

          <div>
            <p>Der eingegebene Post-Titel soll auch in der Titelzeile des Browsers erscheinen.</p>
            <pre><code class="javascript"  >
                function PostEditor() {
                  const [title, setTitle] = React.useState("");
                  const [body, setBody] = React.useState("");

                  React.useEffect(() => {
                    // Aktuellen Titel merken
                    const currentTitle = window.document.title;
                    window.document.title = `New Post ${title}`;

                    // Nach dem Unmount bzw. erneuten Ausführung des Effekts
                    // Titel wieder auf ursprünglichen Wert zurücksetzen
                    return () => window.document.title = currentTitle;


                  }, [title]);

                  return <div>...</div>

                }

                </code></pre>
          </div>
        </section>

        <section data-markdown="">
          <textarea data-template>
---
<!-- .slide: id="t-zod" -->
# Validieren von Daten
## ...am Beispiel von zod

---
### Validieren von Daten
* <!-- .element: class="demo" --> Außerhalb des Projektes, in einer TypeScript-Datei:
* <!-- .element: class="demo" --> json()-Ergebnis von ky ist 'unknown' in TypeScript
* <!-- .element: class="demo" --> Noch schlimmer wäre any
* <!-- .element: class="demo" --> zod
---
### Validieren von Daten
<!-- .slide: class="left" -->
- Das Ergebnis von `json()` in der `ky` API ist ein Promise von `unknown`.
- Ohne explizite Typangabe schlägt der Compiler fehl 😢:
* ```typescript
  async function queryFn() {
    const data = await ky
      .get(`http://localhost:7000/posts`)
      .json();

    data.map({ /* ... */}); // ERROR: TS18046: data is of type 'unknown'
  }
  ```
* Mit expliziter Typ-Angabe gibt es keinen Compile-Fehler:
* ```typescript
  async function queryFn() {
    const data = await ky
      .get<IBlogPost[]>(`http://localhost:7000/posts`)
      .json();

    data.map({ /* ... */}); // data ist jetzt BlogPost[]  😊
  }
  ```
* Damit führen wir eine Art "Type Cast" durch
  * ...aber: stimmt das auch zur Laufzeit? 🤔
  * ...welche Probleme kann es geben? 🤔
* Die Typ-Prüfung findet nur zur Build-Zeit statt!
---
### Typecast vs. Validierung
<!-- .slide: class="left" -->
- Mit einem Typecast sagen wir TypeScript welchen Typ eine Variablen haben soll
* Das kann richtig oder falsch sein:
* ```typescript
  const s:string = "Hallo";
  let y:any = s;
  let x:number = y as number; 🙀
  ```
- Entspricht ungefähr in Java:
* ```java
  String s = "Hallo";
  Object y = s;
  Integer x = (Integer) y;
  ```
- In unserem Beispiel sind wir uns ja sicher, dass `data` eine Liste von `BlogPost`-Objekten ist.
- Deswegen können wir uns auf den Type Cast verlassen.
* Oder? 🤔
---
### Validierung
<!-- .slide: class="left" -->
* Die Daten, die von einem Server (oder auch aus Benutzereingaben) kommen, können von TypeScript nicht überprüft werden
* TypeScript ist zu Laufzeit "weg"
* Wenn der Server also Daten schickt die - entgegen unserer Erwartung - nicht zu dem passen, was wir als TypeScript-Typ definiert haben, merken wir das nicht
  * (abgesehen davon, dass die Anwendung irgendwann in Fehler läuft)
* Besser wäre bei solchen Daten eine echte Laufzeit-Validierung
* Dabei werden die gelesen Daten nach dem Empfang überprüft:
* ```typescript
  async function queryFn(): Promise<BlogPost[]> {
    const data = await ky.get<BlogPost[]>("...").json();
    if (!Array.isArray(data)) {
      // Fehler, Antwort muss eine Liste sein
    }

    data.forEach(p => {
      if (!"title" in p) { throw new Error("Kein title"); }
      if (!"body" in p) { throw new Error("Kein body"); }
      // ... weitere Prüfungen ...
    });

    // ok: data hier ziemlich sicher BlogPost-Liste
    return data;
  }
  ```
* Ist das schön?
---
### Probleme mit manueller Validierung

* Validierung kann viel Code in Anspruch nehmen
* Außerdem redundant:
  * wir müssen den Code zur Validierung schreiben (Laufzeit)
  * wir müssten den TypeScript-Code schreiben (Buildzeit)
---
### Validierungsbibliothek: zod
<!-- .slide: class="left" -->
- Mit [zod](https://zod.dev) gibt es eine Validierungsbibliothek, die beides verbindet
- Mit (JavaScript)-Code, der auch zur Laufzeit ausgeführt wird, wird ein **Schema** beschrieben
- Dieses Schema kann zur Laufzeit verwendet werden, um ein beliebiges Objekt zu validieren
- Außerdem kann aus dem Schema ein TypeScript-Type für die Build-Zeit abgeleitet werden
* ```typescript
  import { z } from "zod";

  const UserSchema = z.object({
    // String:
    username: z.string(),

    // String mit Format:
    email: z.email(),

    // Optionaler String (kann null oder undefined sein):
    nickname: z.string().nullish(),

    // Zahl:
    age: z.number(),

    // Liste von Strings:
    roles: z.string().array();
  });
  ```
---
### Validierungsbibliothek: zod
<!-- .slide: class="left" -->
* Die definierten Schema lassen sich kombinieren:
* ```typescript
  // "Primitiver" Wert mit definiertem Format
  const Password = z.string()
            .min(10)
            .regex(/^(?=.*[a-zA-Z])(?=.*\d).+$/);

  const UserSchema = z.object({
    // ...
    password: Password
  });

  // Liste mit definiertem Inhalt (UserSchema)
  const GetUserApiResponse = UserSchema.array();

  ```
* ```typescript
  // Erweiterung des UserSchema:
  const EditorSchema = UserSchema.extend({
    mainTopic: z.string()
  });
  ```
* ```typescript
  // Verwenden von Schemas
  const Article = z.object({
    // writtenBy muss EditorSchema entsprechen (weder null noch undefined)
    writtenBy: EditorSchema,

    // reviewedBy darf Editor oder null sein (nicht undefined)
    reviewedBy: EditorSchema.nullable(),

    // Optionale Liste von Usern (darf undefined, aber nicht null sein)
    commentedBy: UserSchema.array().optional()
  })
  ```
---
### Zod
* Mit dem `z`-Objekt lassen sich Typen (einfache und komplexe) beschreiben
* Objekte werden mit [`z.object`](https://zod.dev/?id=objects) beschrieben
* Dabei kann man nicht nur Typen angeben ([`string`, `number`](https://zod.dev/?id=primitives), `email`, ....) sondern auch Wertebeschränkungen
  * [Mindestlänge, Maximallänge](https://zod.dev/?id=minmaxlength), erlaubte Zeichen etc.
* Mit der [`parse`-Methode](https://zod.dev/?id=parse) am `Schema`-Objekt kann dann ein beliebiges Objekt validiert werden.
* Wenn das Objekt nicht dem Schema entspricht, wird ein Fehler geworfen
* Wenn alles in Ordnung ist, kommt das validierte Objekt zurück
* ```typescript
  const potentialUser = await loadUser("U1");

  const user = UserSchema.parse(potentialUser);
  ```
* Dadurch ist auch TypeScript der Typ bekannt!
* ```typescript
  type User = { username: string; email: string; nickname?: string | null };
  const user: User = UserSchema.parse(potentialUser);
                     // ^--- ok

  ```
---
### Zod: Ableiten des TypeScript-Typen
* Den TypeScript-Typen müssen wir gar nicht selber schreiben, dass kann zod für uns machen:
* ```typescript
  export const UserSchema = z.object({ /* ... */ });

  export type User = z.infer<typeof UserSchema>;
  ```
* 👉 Damit sind wir sicher, dass unser TypeScript-Type und die Validierungsregeln übereinstimmen
  * Wir vermeiden Redundanzen
  * Wir haben Sicherheit zur Build- und zur Laufzeit
---
### Übung: zod

* In `types.ts` ist der `BlogPost`-Typ als TypeScript-Typ definiert
* Schreibe zwei zod-Typen:
  1. als "Ersatz" für den `BlogPost`-Typen. Dieser soll genau dem bisherigen `BlogPost`-Typen entsprechen
  2. einen Typen für die Antwort vom Server, also eine Liste von `BlogPost`-Objekten
* Verwende den zod-Typen in der Anwendung um die gelesenen Daten zu validieren.
* Mehr Hinweise findest du direkt in `types.ts`
* Mögliche Lösung: `60_zod`


  </textarea
          >
        </section>

        <section>
          <h2>Geschafft! 😊</h2>
          <h3>Vielen Dank für Eure Teilnahme!</h3>
          <h3>Viel Spaß und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, könnt ihr mich erreichen:</p>
          <p><a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p><a href="https://www.linkedin.com/in/nils-hartmann-2a5738252/">LinkedIn</a></p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>

        <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
        <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
        <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
        <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
        <script src="slides/revealjs/config.js"></script>
      </div>
    </div>
  </body>
</html>
