<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React Einf√ºhrung</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2024-09-16-react-einstieg</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg"
                  >https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p style="margin-top: 2rem">
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>
          <p></p>
          <p style="margin-top: 5rem">Java | JavaScript, TypeScript | React | GraphQL</p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>
        <!-- ============================================================================= -->

        <section>
          <h2>Agenda</h2>
          <h3>React</h3>
          <ul style="font-size: 85%">
            <li>
              <a href="#/t1">Teil I: React Einf√ºhrung</a>
            </li>
            <li>
              <a href="#/t2">Teil II: React-Komponenten (Details)</a>
            </li>
            <li>
              <a href="#/t3">Teil III: React-Komponenten: Hierarchien und Anwendungen</a>
            </li>
            <li style="margin-top: 20px">
              <a href="#/t-server">Teil IV: Seiteneffekte und Server-Zugriffe</a>
            </li>

            <li style="margin-top: 20px">
              <a href="#/t-typescript">Teil V: React mit TypeScript</a>
            </li>

            <li>
              <h4>Aus- und √úberblick (bei Interesse und Zeit)</h4>

              <ul>
                <li>
                  <a href="#/t-router">Client-seitiges Routing</a>
                </li>

                <li>
                  <a href="#/t-test">Testen</a>
                </li>
                <li style="margin-top: 20px">
                  <a href="#/t-state">Globales Zustandsmanagement mit Redux Toolkit</a>
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section id="t1">
          <h1>Teil 1</h1>
          <h2>React</h2>
        </section>

        <section>
          <h3>Beispiel-Anwendung</h3>
          <a target="_blank" href="http://localhost:3000">
            <img src="slides/images/blog-example.png" style="height: 850px" />
          </a>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Dokumentation</h3>

          <ul class="xx-list">
            <li>
              Dokumentation
              <a href="https://react.dev/">https://react.dev/</a>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### React im Umbruch?

* Bislang wurden und werden mit React Single-Page-Anwendungen (SPA) gebaut
* Mit Single-Page-Anwendungen l√§uft der Anwendungscode ausschlie√ülich im Browser
  * Man kann die Anwendung im (JavaScript-)Server vorrendern lassen (SSR)
* Seit M√§rz 2023 empfiehlt das React-Team ein "Fullstack Framework" wie Next.js zu verwenden
* Im Gegensatz zur "klassischen" Single-Page-Anwendung wird dabei ein Teil der Anwendung auf 
  einem (JavaScript-) Server ausgef√ºhrt
* Man kann aber weiterhin mit React SPAs bauen
* In dieser Schulung besch√§ftigen wir uns auch nur mit den SPAs
* Alles was wir sehen, w√§re auch Grundlage f√ºr Fullstack-Anwendungen 
  * Falls ihr also sp√§ter "Fullstack"-Anwendungen mit React bauen wollt, habt
  ihr auch daf√ºr schon die Grundlagen gelernt
  * Fullstack-Anwendungen bauen auf dem auf, was wir in uns in dieser Schulung ansehen
          </textarea>
        </section>

        <section>
          <h2>Unsere erste React-Komponente</h2>

          <ul>
            <li>
              <em>Sehen wir uns die wichtigsten Konzepte einer React-Komponente im Code an</em>
            </li>
            <li>Ihr k√∂nnt mir zugucken, √úbungen machen wir danach</li>
            <li>Schritt-f√ºr-Schritt (<code>react-intro/workspace</code>)</li>
          </ul>
        </section>

        <section id="interaktiv-hellomessage">
          <h3>Hello World React</h3>
          <code>PostEditor.js</code>
          <pre><code>
  import React from "react";
  
  export default function PostEditor() {
    const [title, setTitle] = React.useState("");
  
    return (
      &lt;div>
        &lt;label>
          Title
          &lt;input onChange={event => setTitle(event.target.value)} value={title} />
        &lt;/label>
      &lt;/div>
    );
  }
            </code></pre>
        </section>

        <section>
          <h3>Einbinden der Anwendung in die HTML-Seite</h3>
          <div>
            <p>
              <code>index.html</code>
            </p>
            <pre><code>
  &lt;html>
    &lt;-- ... -->
    &lt;body>
      <div id="root"></div>
    &lt;/body>
  &lt;/html>
  </code></pre>
          </div>
          <div>
            <p>
              <code>index.tsx</code>
            </p>
            <pre><code class="javascript">
  import React from 'react';

  import { createRoot } from 'react-dom/client';
  import PostEditor from './PostEditor';
  
  const root = createRoot(document.getElementById('root')!);
  root.render(&lt;PostEditor />);
  </code></pre>
            <p>Im Workspace ist die Root-Komponente die <code>App</code>-Komponente</p>
          </div>
        </section>

        <section>
          <h3>Der Trainingsworkspace</h3>
          <ul class="x-list">
            <li style="margin-bottom: 40px">
              <code>2024-09-16-react-einstieg.html</code>: Die Slides
            </li>
            <li style="margin-bottom: 40px">
              Der Code ist im <code><b>react-intro</b></code> Verzeichnis
            </li>

            <li style="margin-bottom: 40px">
              <code>react-intro/<b>workspace</b></code
              >: Verzeichnis f√ºr Eure √úbungen <br />üëâ&nbsp;<b>Empfehlung</b>: nur diesen Ordner in
              IDE/Editor √∂ffnen
            </li>
            <li>
              <code>react-intro/<b>steps</b></code
              >: Fertiger Source-Code nach jeder √úbung
            </li>
          </ul>
        </section>
        <section>
          <h2>√úbung #1: Hello-World</h2>
          <h3>
            <em>Mit Tools, Workspace und React vertraut machen</em>
          </h3>
        </section>
        <section>
          <h3>Schritt #1: Tool Chain starten</h3>
          <p>Gemeinsam, Schritt-f√ºr-Schritt:</p>
          <ol class="x-list" style="font-size: 85%">
            <li>Verzeichnis <code>react-intro/workspace</code> im Editor √∂ffnen</li>

            <li>
              <code>cd react-intro/workspace</code>
            </li>
            <li>
              <code>npm install</code>
            </li>
            <li>
              <code>npm run dev</code>
            </li>

            <li>
              Der Browser sollte automatisch
              <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>
              √∂ffnen
            </li>

            <li>Wenn Du "Hello, World" im Browser siehst, ist alles gut!</li>
            <li>Dann bitte in Teams "Hand heben" üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <p>
            <em
              >Ein kleiner Schritt f√ºr die PostEditor-Komponente, ein gro√üer Schritt f√ºr dich auf
              deinem Weg, React zu lernen!</em
            >
          </p>
          <ul>
            <li>Ersetze den "statischen" Code in <code>PostEditor.tsx</code></li>
            <li>Die Komponente soll <b>PostEditor</b> hei√üen</li>
            <li>
              Sie sollte einen Zustand/State (<code>title</code>) und ein Eingabefeld daf√ºr haben
            </li>
            <li>
              Als Hilfe kannst Du den Code aus den
              <a href="#interaktiv-hellomessage">vorherigen Slides</a> ansehen.
            </li>
            <li>
              Eine m√∂gliche L√∂sung findest Du auch in
              <code>react-intro/steps/02_hello_world_editor</code>
            </li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
## Ein React Projekt beginnen

* Wenn ihr Single-Page-Anwendungen mit React bauen wollt, habt ihr zwei M√∂glichkeiten, euer Projekt aufzusetzen:
  * [Vite](https://vitejs.dev/) mit dem `react-ts` Template
  * [Create React App (CRA)](https://create-react-app.dev/). 
    * Das war lange das Standard-Tool zum Aufsetzen von React-Projekten, wird aber kaum noch weiterentwickelt
    * Wenn ihr bestehende React-Projekte seht, ist die Wahrscheinlichkeit aber hoch, dass das CRA aufgesetzt wurde
  * üëâ vite ist das Mittel der Wahl und wird auch hier im Workspace verwendet
  </textarea
          >
        </section>

        <section id="t2">
          <h1>Teil II</h1>
          <h2>React Komponenten</h2>
        </section>

        <section>
          <h3>React: JSX</h3>
          <ul>
            <li style="font-size: 80%">
              Wird wie HTML hingeschrieben, inkl Attribute:
              <pre><code class="xml"  >
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Achtung! <code>class</code>-Attribut hei√üt <code>className</code>:
              <pre><code class="xml"  >
&lt;h1 className="title">...&lt;/h1>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Attribute, die keine Strings sind, m√ºssen in {} eingeschlossen werden:
              <pre><code class="xml"  >
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              CSS-Eigenschaften werden als Objekt √ºbergeben in Camel-Case-Notation:
              <pre><code class="xml"  >
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>React: JSX #2</h3>
          <ul>
            <li style="font-size: 80%">
              Fragmente (rendern selber kein Element in den DOM, nur ihre Kind-Elemente):
              <pre><code class="xml"  >
function Choice() { 
  return &lt;&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt;/>              
}  
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              null oder boolean (false oder true), um nichts zu rendern:
              <pre><code class="xml"  >
function ErrorMessage() {
  const hasError = someCondition(); // returns true or false

  return <div>
    {hasError && "Error!"}
    {hasError || "Everything fine"}
  </div>
}              
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              Kommentare
              <pre><code class="xml"  >
  function MyComponent() {
    return <div>
      { /* hier ist javascript, deswegen block-kommentare erlaubt */ }
    </div>;
  }              
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Zustand einer Komponente und der useState-Hook (Zusammenfassung)</h3>
          <ul class="fragement">
            <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server, Menu offen oder zu</li>
            <li><b>Werte</b> √ºblicherweise immutable</li>
            <li>Arbeiten mit Zustand √ºber <b>useState</b>-Hook</li>
            <li>
              useState liefert Array mit zwei Werten zur√ºck: aktuellen Zustand, und setter-Funktion
              um Zustand zu ver√§ndern
            </li>
            <li>
              <pre><code class="javascript"  >
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  return &lt;input onChange={e => setTitle(e.target.value) value={title} />;
}
                  </code></pre>
            </li>

            <li>
              Aufruf des Setters <b>l√∂st erneutes rendern der <i>gesamten</i> Komponente aus</b>
            </li>
            <li>
              Es k√∂nnen mehrere States erzeugt werden, durch Verwendung mehrerer useState-Aufrufe
            </li>
            <li><b>Zustand</b> ist eines der <b>zentralen</b> Konzepte von React</li>
          </ul>
        </section>

        <!-- <section>
          <h2>√úbung 1b: Styling f√ºr den Post-Editor</h2>
          <em><b>F√ºge dem Post-Editor etwas CSS hinzu</b></em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li>
              Das Root-Element deines Formulars soll die CSS Klasse <code>Container</code> bekommen.
              Dadurch sollte sich ihr Aussehen (leicht) ver√§ndern
            </li>
            <li>
              Wenn <b>kein Text</b> im Eingabe-Feld steht, soll eine Fehlermeldung ausgegeben werden
              ("Please fill in the title" o.√§.)
              <br />
              Der Fehlertext sollte in fettem Rot ausgegeben werden (CSS-Eigenschaften:
              <code>color: red</code> und <code>font-weight: bold</code>)
            </li>
            <li>
              Wenn <b>mindestens ein Zeichen</b> im Eingabe-Feld steht, soll eine "positive" Message
              erscheinen ("You have filled the title correctly").
              <br />
              Diese positive Nachricht sollte in gr√ºn erscheinen (CSS-Eigenschaft:
              <code>color: green</code>)
            </li>
            <li>M√∂gliche L√∂sung in <code>steps/1b-editor-css</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section> -->

        <section>
          <h3>React Hooks API</h3>
          <em
            >Mit der React Hooks API kann sich eine Komponente in Zustand und Lebenszyklus
            "einhaken"</em
          >
          <ul>
            <li>
              Hooks sind "normale" Funktionen, m√ºssen aber mit <code>use</code> beginnen (useState,
              useEffect, ...)
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks API</h3>
          <em>Es gibt einige Regeln zu beachten, bei der Verwendung von Hooks üëÜ</em>
          <p style="font-size: 75%; margin-top: 0">
            <a href="https://reactjs.org/docs/hooks-rules.html"
              >(https://reactjs.org/docs/hooks-rules.html)</a
            >
          </p>
          <div>
            <p>Einschr√§nkungen:</p>
            <ul>
              <li>
                Hooks k√∂nnen nur in Funktionskomponenten (und anderen Hooks) aufgerufen werden
              </li>
              <li>
                Hooks m√ºssen immer in derselben Reihenfolge und auf Top-Level-Ebene verwendet werden
                <ul>
                  <li>Verboten z.B. in Schleifen, if-Abfragen oder in anderen Funktionen</li>
                </ul>
              </li>
              <li>
                Es gibt ein
                <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint Plug-in</a>
                zur korrekten Verwendung der Hooks
              </li>
              <li>
                <em
                  >Der Hooks-Mechanismus basiert intern darauf, dass React sich die Reihenfolge der
                  <code>useXyz</code>-Aufrufe merkt!</em
                >
              </li>
            </ul>
          </div>
        </section>
        <section>
          <h3>React Hooks</h3>

          <em>Beispiele f√ºr korrekte und unerlaubte Verwendung</em>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const [name, setName] = React.useState("");
  // ...
}
                                </code></pre>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const uppercaseGreeting = greeting.toUpperCase(); 
  const [name, setName] = React.useState("");
  // ...
}
                                                      </code></pre>

          <pre><code class="javascript"  >
// VERBOTEN:
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  function onSaveClick() {
    const [loading, setIsLoading] = React.useState(true);
    // ...
  }

  // ...
}
                                                      </code></pre>
        </section>

        <section>
          <h2>√úbung: Post-Editor f√ºr unsere Anwendung</h2>
          <em><b>Erweitere deine Komponente um neue Features</b></em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li>
              Zus√§tzlich zum "title", sollte es einen weiteren Zustand und eine Textarea geben:
              <code>body</code>. Ein <code>textarea</code>-Element hat dieselbe API wie ein
              <code>input</code>-Feld, du kannst also auch hier mit <code>onChange</code> und
              <code>value</code> arbeiten.
            </li>

            <li>
              F√ºge einen "Clear"-Button hinzu, der beide Eingabefeld leert. Das Property auf dem
              Button ist <code>onClick</code>.
            </li>
            <li>
              Der "Clear"-Button soll <b>disabled</b> sein, wenn beide Eingabefelder leer sind
            </li>
            <li>
              Optional: f√ºge unter beiden Feldern eine Fehler-Meldung hinzu, wenn das jeweilige Feld
              leer ist (z.B. "Please fill in Xyz")
            </li>
            <li>M√∂gliche L√∂sung: <code>steps/03_post_editor</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <section id="t3">
          <h1>Teil III</h1>
          <h2>React: Hierarchien und Anwendungen</h2>
        </section>

        <!-- - - - - - - - - - - - - - - - PROPS HIER ERST - - - - - - - - - - - - - - -  -->
        <section>
          <h3>React: Properties</h3>
          <p>Live: Die TagChooser-Komponente einbinden</p>
          <ul>
            <li>
              Mit <b>Properties</b> k√∂nnen einer Komponente von <b>au√üen</b> Werte und Eigenschaften
              √ºbergeben werden

              <pre><code class="javascript"  >
function PostEditor() {
    // type, onChange und value sind Properties!

    return (
      &lt;input type="text" onChange={() => setTitle("...")} value={title}&lt;/h1>
    );
  }
}
            </code></pre>
            </li>
            <li><b>Properties</b> k√∂nnen innerhalb der Komponente nicht ver√§ndert werden</li>
            <li>
              Zum Vergleich: <b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der
              Komponente (die ver√§ndert werden kann)
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties ("Props") einer Komponente</h3>
          <ul>
            <li>Komponenten k√∂nnen beliebig eigene Properties definieren</li>
            <li>
              Bei der Angabe der Properties bei der Verwendung einer Komponente werden die
              Properties wie von HTML gewohnt in der Notiation
              <code>name=value</code> hingeschrieben
            </li>
            <li>
              <pre><code class="javascript"  >
&lt;TagChooser title="Select tags for your post" availableTags={["JS", "Web Development" ]} />
               </code></pre>
            </li>
            <li>
              ...alle angegebenen Properties werden "gesammelt" und in <b>einem</b> Objekt im 1.
              Methoden-Parameter an Komponente √ºbergeben
            </li>
            <li>
              <pre><code class="javascript"  >
function TagChooser(props) {
    // props: { title: "Select tags for your post", availableTags: ["JS", "Web Development" ] }

    return ...;
  }
}
              </code></pre>
            </li>
            <li>
              <pre><code class="javascript"  >
// Mit Destructuring
function PostEditor({title, availableTags}) {

    return ...;
  }
}
                                </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Properties mit TypeScript
<!-- .slide: class="left" -->
- Der erste Parameter einer Komponente ist immer ein `object`
- Mit TypeScript kannst du beschreiben, welche Properties deine Komponente darin erwartet und von welchem Typ die sind
  - Daran ist aus TypeScript-Sicht nichts React-spezifisch
- Dazu musst du mit `type` (oder `interface`) das `props`-Objekt beschreiben
- Wie du den Typen nennst, spielt keine Rolle.
  - In der Regel ist die Konvention entweder nur `Props` oder `KomponentenNameProps`
  * ```typescript
    type TagChooserProps = {
      // optionales Property:
      title?: string;

      // Liste mit Strings:
      availableTags: string[]

      // Auch (Callback-)Funktionen sind erlaubt:
      onTagSelected(tag: string): void
    }
    ```

* In der Funktionssignatur eurer Komponente gebt ihr denn Typen dann an:
  * ```typescript
    export default function TagChooser(props: TagChooserProps) { /* ... */ }
    ```
  * ```typescript
    // Mit Destructuring:
    export default function TagChooser({title, availableTags}: TagChooserProps) { /* ... */ }
    ```

          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Properties: Default-Werte</h3>

          <p>
            Mit dem Object Destructuring-Operator k√∂nnen <b>Default-Werte</b> angegeben werden, f√ºr
            Eigenschaften, die aus einem Objekt gelesen werden, aber dort nicht angegeben (bzw.
            undefined) sind:
          </p>
          <p>
            F√ºr den Aufrufer sind die Properties dann optional, innerhalb der Komponente wei√ü
            TypeScript aber, dass ein Wert vorhanden ist (und kennt auch dessen Typ)
          </p>

          <pre><code class="javascript">
function TagChooser({title = "Select Tag", availableTags}: TagChooserProps) {
  // 'title' ist hier in jedem Fall vom Typ 'string', auch wenn
  //  das vom Aufrufer nicht gesetzt wird

  // ...
}
          </code></pre>
          <pre><code class="javascript">
// title in der Komponente ist "Select Tag"
&lt;TagChooser availableTags={["JS", "React"]} />
          </code></pre>
        </section>

        <section>
          <h3>Virtual DOM</h3>
          <p>"Rendern" hat leider doppelte Bedeutung!</p>
          <img src="slides/images/vdom.png" style="height: 650px" />
        </section>
        <!--        <section>-->
        <!--          <h3>Virtual DOM</h3>-->
        <!--          <p>Beispiel: <code>react-intro/steps/2b-rendering</code></p>-->
        <!--        </section>-->

        <section data-markdown>
          <textarea data-template>
<!-- .slide: class="left" -->

### Listen in React

* JSX hat keine eigene Syntax zum Erzeugen von Listen-Darstellungen (im Gegensatz zu anderen Template-Sprachen, z.B. `ng:for` in Angular)
* Stattdessen verwendet man das normale [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) um Listen mit "Daten" auf Listen mit "UI" abzubilden
* ```typescript
  // Beispiel: eine Liste mit Tags
  const availableTags = [ "JavaScript", "React" ];
  ```
* ```typescript
  // Beispiel JavaScript: Mappen von Werten auf neue Werte
  const t = availableTags.map( t => t.toUpperCase());
    // t: [ "JAVASCRIPT", "REACT" ]
  ```
* Beim Erzeugen von Listen in React muss jedes Element ein [`key`-Property](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) bekommen, das innerhalb der Liste eindeutig sein muss

* ```typescript
  // Beispiel: In React zur Erzeugung von Listen:
  const list = availableTags.map(t => <li key={t}>Tag: {t}</li>
    // <li key="JavaScript">Tag: JavaScript</li>
    // <li key="React">Tag: React</li>
  ```
* ```typescript
  // Komplettes Beispiel:
  function TagChooser({availableTags}: TagChooserProps) {
    // ...
    return <ul>
      {availableTags.map(t => <li key={t}>Tag: {t}</li>}
    </ul>;
  }
  ```

* Doku: https://react.dev/learn/rendering-lists

  </textarea
          >
        </section>

        <section>
          <h2>√úbung: Ein TagChooser</h2>
          <em>Schritt 1 f√ºr den TagChooser: Darstellung der "available" Tags</em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="xx-list">
            <li>In <code>TagChooser.tsx</code> gibt es bereits eine TagChooser-Komponente.</li>
            <li>Diese Komponente musst du um Properties erweitern</li>
            <li>Au√üerdem musst du darin die √ºbergebenen (<code>availableTags</code>) anzeigen</li>
            <li>Du findest dazu Hinweise direkt in der Datei.</li>

            <li>M√∂gliche L√∂sung: <code>steps/05_props</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <section data-state="js-exkurs">
          <h2>React Devtools</h2>
          <em>React Developer Tools f√ºr Chrome und Firefox</em>
          <p>Untersuchen der React Anwendung zur Laufzeit</p>
          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/"
                target="_blank"
                >Firefox</a
              >
            </li>
          </ul>

          <p><img src="slides/images/screenshot-react-dev-tools.png" /></p>
        </section>
        <!-- <section>
          <h3>Render Zyklus</h3>
          <img src="slides/images/render-cycle.png" height="550px" />
        </section> -->

        <section>
          <h2>Komponenten-Hierarchien</h2>
        </section>

        <section data-markdown="">
          <textarea data-template>
## Komponenten-Hierarchien
* Wie k√∂nnen Komponenten untereinander kommunizieren?
* üëâ `PostEditor` und `TagChooser`
          </textarea>
        </section>

        <!--        <section>-->
        <!--          <h3>Smart und Dumb-Komponenten #1</h3>-->

        <!--          <p>-->
        <!--            Zur Erinnerung: in React bauen wir Komponenten. Komponenten bestehen aus Logik, Zustand-->
        <!--            und UI (HTML-Elemente und Styling)-->
        <!--          </p>-->
        <!--          <p>-->
        <!--            Ein bekanntes Muster ist, die Komponenten in zwei Arten aufzuteilen:-->
        <!--            <b>Smart (oder Controller)</b>- und <b>Dumb oder (Presentation-)</b>-Komponenten-->
        <!--          </p>-->
        <!--          <p>Technisch sind die Komponenten identisch, also "normale" React-Komponenten</p>-->
        <!--          <p>Nur ihre <b>Aufgabe</b> ist anders definiert...</p>-->
        <!--        </section>-->

        <section>
          <h3>Datenfluss in React-Anwendungen</h3>
          <p>
            <em
              >In React erfolgt der Datenfluss zwischen Komponenten
              <b>immer von oben nach unten</b>:</em
            >
          </p>
          <ol>
            <li>
              Eine Parent-Komponente hat <b>Zustand (State)</b> und ggf. Logik, um mit dem Zustand
              zu arbeiten
            </li>
            <li>
              Die Parent-Komponente reicht Daten per Properties an ihre Kind-Komponenten weiter
              (z.B. Daten aus dem Zustand)
            </li>
            <li>
              Au√üerdem gibt die Parent-Komponente <b>Callback-Funktionen als Properties</b> an ihre
              Kind-Komponenten (als eine Art Event-Handler)
            </li>
            <li>
              Bei einem Ereignis (zum Beispiel neues Tag ausgew√§hlt) ruft die Kind-Komponente die
              Callback-Funktion der Parent-Komponente auf
            </li>
            <li>
              In der Callback-Funktion findet dann die fachliche Verarbeitung des Events statt.
              Dabei kann die Parent-Komponente zum Beispiel ihren <b>State aktualisieren</b>
            </li>
            <li>
              Das √Ñndern des States triggert das <b>erneute Rendern der Komponenten-Hierarchie</b>,
              so dass sowohl Parent- als auch Kind-Komponente ihre Darstellung gem√§√ü den
              aktualisierten Daten anzeigen k√∂nnen
            </li>
          </ol>
          <ul>
            <li>
              Dieses Verhalten haben wir bei der eingebauten <code>input</code>-Komponente bereits
              gesehen. (<code>value</code> und <code>onChange</code>-Property)
            </li>
            <li>
              üëâ Durch das pauschale neurendern auch aller Kind-Komponenten kann es nicht zu
              <b>Inkonsistenzen</b> in der Darstellung durch "vergessenes" Rendern kommen.
            </li>
          </ul>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Kontrollierte" und "unkontrollierte" Komponenten
* Komponenten, die von einer anderen Komponente "kontrolliert" werden, werden **controlled components** in React genannt
* Diese Komponenten verlassen sich darauf, dass ihre Parent-Komponente den Zustand verwalten
* Beispiele f√ºr `controlled components`:
    * `input` (mit `onChange` und `value`): Oberkomponenten h√§lt den Inhalt des Eingabefelds und steuert, wann bzw. wie dieser ge√§ndert werden soll.
    * `TagChooser` (mit `selectedTags` und `onSelectionChange`): PostEditor kontrolliert, welche Tags ausgew√§hlt sind und was passieren soll, wenn sich die Auswahl √§ndert
    (PostEditor k√∂nnte sich zum Beispiel entschliessen, eine Auswahl zu ignorieren, oder unabh√§ngig vom TagChooser die Tags zur√ºckzusetzen)
* Beispiel f√ºr eine unkontrollierte Komponente:
    * `TagChooser` (in der bisherigen Form mit lokalem Zustand): Der PostEditor hat keinen Einfluss auf die Auswahl der Tags
    * `PostEditor`
  </textarea
          >
        </section>

        <section>
          <h3>Komponenten-Hierarchie mit Properties und Callback-Funktionen</h3>
          <img src="slides/images/posteditor-tagchooser-hierarchy.png" height="1000px" />
        </section>
        <section data-markdown="">
          <textarea data-template>
### Beispiel: PostEditor und TagChooser
* Der PostEditor enth√§lt die Liste aller Tags, sowie die aktuell f√ºr den neuen Post ausgew√§hlten Tags
* Der PostEditor gibt die ausgew√§hlten Tags an die TagChooser-Komponenten
* Der PostEditor gibt au√üerdem eine Callback-Funktion an den TagChooser
* Der TagChooser ruft diese Callback-Funktion auf, sobald sich die Auswahl der Tags ge√§ndert hat
* ```typescript
  function PostEditor() {
    const [tags, setTags] = useState<string[]>([]);

    return <>
      { /* ... */ }
      <TagChooser selectedTags={tags} onSelectionChange={setTags} />
    </>
  }
  function TagChooser({selectedTags, onSelectionChange}) {
    // kein State mehr!

    const handleTagClick = () => {
      // wenn ein Tag angeklickt wird, neue Auswahl ermitteln
      // und damit die Oberkomponente informieren
      const newSelectedTags = ...;

      onSelectionChange(newSelectedTags);
    }

    return /* ... */;
  }

  ```
  </textarea
          >
        </section>

        <section>
          <h2>√úbung: Mache den TagChooser zu einer "kontrollierten" Komponente</h2>
          <p>
            <em> Der PostEditor soll die Liste der ausgew√§hlten Tags verwalten </em>
          </p>
          <ol class="xx-list">
            <li>
              In <code>react-intro/material/6_hierarchien</code> findest du eine
              <code>TagChooser.tsx</code>-Datei
            </li>
            <li>In dieser Datei findest du eine Beschreibung der erforderlichen Schritte</li>
            <li>
              Du kannst die √Ñnderungen entweder an deinem eigenen TagChooser im Workspace
              vornehmen...
            </li>
            <li>
              ...oder du kopierst dir die <code>TagChooser.tsx</code>-Datei in einen Workspace als
              Ausgangsbasis
            </li>
            <li>M√∂gliche L√∂sung: <code>steps/6-hierarchien</code></li>
            <li>Wenn Du fertig bist, bitte in Teams "Hand heben" üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Lifting State up"
* Der Zustand ist an eine Komponente und deren Lebenszyklus gebunden
* Wenn eine Komponente von React aus dem DOM entfernt wird ("unmount"), geht auch deren Zustand verloren
* Wenn der PostEditor also entfernt wird gehen auch alle Eingaben und die ausgew√§hlten Tags verloren
* Dazu ein Beispiel
* <!-- .element: class="demo" --> PostPreview in 07_exkurs_lifting_state_up
---
### "Lifting State up"
* Wenn ihr Zustand ben√∂tigt, der das Entfernen einer Komponente √ºberlebt, m√ºsst ihr den Zustand in der Komponente nach oben schieben
* Dasselbe gilt auch, wenn ihr Zustand habt, der von mehr als einer Komponente verwendet werden soll
  * Erinnerung: Kommunikation erfolgt immer von oben nach unten, nie auf gleicher Ebene
* Soweit nach oben, bis ihr zu einer Komponente kommt, die √ºber den Komponenten steht, die den Zustand ben√∂tigen
* Dieses Pattern wird als ["Lifting State up"](https://react.dev/learn/sharing-state-between-components#lifting-state-up-by-example) bezeichnet
* Im `PostPreview`-Beispiel wird der Zustand aus dem `PostEditor` auch in `PostPreview` ben√∂tigt und wird dem entsprechend in
            `PostEditorPage` hochgeschoben
* <img src="slides/images/lifting-state-up.png" height="500px"/>

          </textarea>
        </section>
        <section data-markdown="">
          <textarea data-template>
    <!-- .element: class="todo" -->Objekt als State
    <!-- .element: class="todo" -->useReducer
  </textarea
          >
        </section>

        <section id="t-server">
          <h1>Teil IV</h1>
          <h2>Seiteneffekte und Server-Zugriffe</h2>
          <em>Lesen und Schreiben von Daten von einem Backend (REST/HTTP)</em>
          <p><code>react-intro/steps/4b-remote</code></p>
        </section>

        <!-- =================================================================================================== -->
        <!-- ==   Promises und Speichern                                                                                          == -->
        <!-- =================================================================================================== -->
        <section>
          <h2>Server-Zugriffe</h2>
          <ul class="x-list">
            <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
            <li>
              H√§ufig in React verwendet: <b>fetch</b> API
              <ul>
                <li>Browser-API zum Ausf√ºhren von HTTP Requests</li>
                <li>
                  Dokumentation:
                  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"
                    >Fetch API (MDN)</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section data-state="exkurs">
          <h3>Die fetch API</h3>
          <p>Lesen von Daten (mit HTTP GET)</p>
          <pre><code class="javascript"  >
// Beispiel mit JavaScript Promises:

fetch('http://localhost:7000/posts')

  .then(response => response.json())

  .then(posts => console.log("Posts read from API:", posts))

  .catch(ex => console.error('request failed', ex));
</code></pre>
        </section>

        <section data-state="exkurs" id="t-promises">
          <h3>Hintergrund: Promises in JavaScript</h3>

          <p class="fragment">
            Ein Promise liefert einen "Versprechen" auf einen Wert zur√ºck, der evtl. erst in der
            Zukunft ermittelt werden kann
          </p>
          <p class="fragment">
            Damit k√∂nnen wir asynchrones Verhalten in JavaScript Applikation abbilden
          </p>
          <pre class="fragment"><code class="javascript" contenteditable>
// "getNameAsync" ist eine ausgedachte Funktion, 
// die ein Promise zur√ºckliefert, 
// das "irgendwann" den String "Klaus" zur√ºckgibt
const promise = getNameAsync();
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise.then(name => console.log(name));
// Ausgabe "irgendwann": "Klaus"
  </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>Promises</h3>
          <p>Promises k√∂nnen verkettet werden</p>
          <pre><code class="javascript" contenteditable>
// Annahme: 'getNameAsync' liefert "irgendwann" den String "Klaus" zur√ºck
const promise = getNameAsync()

// Wird mit dem ersten Wert aufgerufen und gibt neuen Wert zur√ºck
.then(name => getGreetingAsync(name)) 

// wird mit dem zweiten Wert (aus vorherigem then) aufgerufen
.then(greeting => console.log(greeting));

// Ausgabe "irgendwann": 
// "Hello, Klaus"

  </code></pre>
          <p class="fragment">
            Die <code>then</code>-Funktion gibt <b>immer</b> ein Promise zur√ºck
          </p>
        </section>

        <section data-state="exkurs">
          <h3>Fehlerbehandlung</h3>
          <h4>Mit <code>catch()</code> kann man Fehler fangen und darauf reagieren</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
  const promise = getNameAsync()

    .then(name => { if (name === null) throw new Error("No name found") })

    .then(greeting => console.log(greeting));

    .catch(error => console.error(`Greeting failed: ${error}`))
  
    // Wenn 'getNameAsync' null zur√ºckliefert ist die Ausgabe:
    //   Greeting failed: No name found
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section data-state="exkurs">
          <h3>Finally</h3>

          <p class="fragment">
            Eine <code>finally</code>-Callback-Funktion wird nach dem letzten <code>then</code> bzw.
            <code>catch</code>-Block ausgef√ºhrt.
          </p>

          <p class="fragment">
            Die finally-Funktion wird <b>immer</b> ausgef√ºhrt (unabh√§ngig davon, ob vorher ein
            Fehler aufgetreten ist oder nicht
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              const promise = getNameAsync();

                .then(name => { if (name === null) throw new Error("No name found") })

                .then(greeting => console.log(greeting));

                .catch(error => console.error(`Greeting failed: ${error}`))

                .finally( () => console.log("Goodbye!") );
              
                // Output (error): Greeting failed: No name found
                // Output (log): Goodbye!
                </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>Promise.all</h3>

          <p class="fragment">
            Mit
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
              >Promise.all</a
            >
            kannst Du auf eine Liste von Promises warten
          </p>

          <p class="fragment">
            Die Funktion wird nur ausgef√ºhrt, wenn alle √ºbergebenen Promises aufgel√∂st werden
            konnten
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              const user = loadUserAsync(); // gibt Promise zur√ºck
              const newsFeed = loadNewsFeedAsync(); // gibt Promise zur√ºck

              Promise.all(user, newsFeed)
                .then(result => {
                  const loadedUser = result[0];
                  const newsFeed = result[1];

                  return { user: loadedUser, news: newsFeed };
                });
                </code></pre>

          <p class="fragment">
            Verwandt:
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
              >Promise.any</a
            >
            und
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
              >Promise.allSettled</a
            >
          </p>
        </section>

        <section data-state="exkurs">
          <h2>async / await</h2>
          <p>"Wrapper" um Promises</p>
          <p>Erlaubt es, asynchronen Code "linear" hinzuschreiben</p>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>await</code> wartet bis ein Promise aufgel√∂st wird</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }
    
    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);
    
      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>async</code> machen eine Funktion zu einer "async function"</p>
          <p class="fragment">
            Eine <code>async</code> Funktion gibt &nbsp; <b>immer</b> ein Promise zur√ºck
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }
  
  const greeting = greet('Klaus');
  
  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> Funktion als Fat Arrow Funktionen:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;                
    
  const greeting = greet('Klaus');
    
  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>async / await</h3>
          <p>
            Anstatt <code>then</code> oder <code>catch</code>-Ketten kannst Du einfach mehrere
            <code>await</code> Statements verwenden und try/catch f√ºr die Fehlerbehandlung:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};
  
  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
                      </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>Die fetch API</h3>
          <p>Schreiben von Daten mit HTTP POST</p>
          <p>
            <code>fetch</code> nimmt als 2. Parameter optional ein Konfigurationsobjekt entgegen:
          </p>
          <ul>
            <li>
              <code>method</code>: HTTP Methode (<code>PUT</code>, <code>POST</code>,
              <code>DELETE</code>, ...)
            </li>
            <li><code>headers</code>: HTTP Header f√ºr den Request (z.B. Authorization)</li>
            <li><code>body</code>: Der Payload (als String!)</li>
            <li>
              <p>Der Returnwert ist derselbe wie bei GET</p>
              <pre><code class="javascript"  >
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
  })
  // ... 
      </code></pre>
            </li>
          </ul>
        </section>

        <section data-state="exkurs">
          <h3>fetch: Zusammenfassung</h3>

          <pre><code class="javascript"  >
  try {
    // 1. fetch liefert ein Promise-Objekt zur√ºck, das zu einer "Response" aufgel√∂st wird
    //    Das Response-Objekt enth√§lt Metadaten √ºber das Ergebnis (z.B. http Status)
    const response = await fetch('http://localhost:7000/posts', { 
      method: "POST", // oder "GET", "PATCH", ...
      headers: { "content-type": "application/json" },
      body: JSON.stringify(newBlogPost)  
    });

    if (response.status === 200) {

      // 2. mit den Methoden 'json()' bzw. 'text()' kann der Payload der
      //    Antwort ausgelesen werden:
      const answer = await response.json();

      console.log("Answer from server", answer)
    } else {
      console.error("Received status code from server:", response.status);
    }
  } catch (err) {
    // 4. In case something goes wrong, log error
    console.error('request failed', err);
  }
  
  </code></pre>
          <p>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API Doku</a>
          </p>
        </section>
        <section>
          <h3>Speichern eines neuen Blog-Posts</h3>
          <p>üëâSchritt-f√ºr-Schritt</p>
          <p style="font-size: small"><code>Ausgang: steps/3-hierarchy</code></p>
        </section>

        <section>
          <h2>√úbung Fetch #1 (Speichern)</h2>
          <p>
            <em
              >Implementiere die n√§chste Version der <code>App</code>-Komponente, die in der Lage
              ist, einen neuen Blog Posts mit <code>fetch</code> zu speichern.</em
            >. In diesem Schritt kommen die angezeigten Posts immer noch aus den Mock-Daten aber wir
            k√∂nnen schon neue auf dem Server speichern.
          </p>
          <div>
            <p>Das backend ist bereits fertig. Ihr k√∂nnt es starten mit:</p>
            <pre><code>
                  cd react18-training/react-intro/backend-rest
                  npm start
                </code></pre>
            <p>Der Server l√§uft auf Port 7000</p>
            <p>
              Ihr k√∂nnt das Backend mit folgender URL testen (Browser, wget, curl, ...):
              <a href="http://localhost:7000/posts">http://localhost:7000/posts</a>
            </p>
          </div>
        </section>

        <section>
          <h2>√úbung Fetch POST</h2>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li>F√ºge in <code>App.js</code> den Code zum <b>Speichern</b> der Blog-Posts hinzu.</li>
            <li>
              Du kannst deine eigene <code>App.js</code>-Datei verwenden oder
              <code>material/4-remote/src/App.js</code>
            </li>
            <li>
              Das Speichern soll in der <code>savePost</code>-Funktion erfolgen

              <ul>
                <li>Du musst als HTTP Methode <code>POST</code> verwenden</li>
                <li>
                  Du musst als Header den <code>Content-Type</code> auf
                  <code>"application/json"</code> setzen
                </li>
                <li>Als <code>body</code> musst Du den neuen Blog-Post an den Server schicken</li>
                <li>
                  In der Antwort bekommst Du den gespeicherten Post vom Server zur√ºck. Diesen musst
                  Du in die Liste der bestehenden BlogPosts einf√ºgen
                </li>
              </ul>
            </li>

            <li>M√∂gliche L√∂sung in <code>steps/4a-remote</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <!-- =================================================================================================== -->
        <!-- ==   SEITENEFFEKTE                                                                               == -->
        <!-- =================================================================================================== -->
        <section data-markdown>
          <textarea data-template>
### Wann laden wir die initialen Daten f√ºr unsere Anwendung (Blog Posts)?

* Im vorherigen Schritt haben wir _nach einer Benutzerinteraktion_ bzw. _nach einem Event_ mit dem Server interagiert
* In diesem Schritt wollen wir Daten ohne vorheriges Event laden
* Dazu verwenden wir auch `fetch`, aber wir m√ºssen einige Besonderheiten von React bei der Arbeiten mit _Seiteneffekten_ beachten!
---

### Renderzyklus von React-Komponenten

1. Anwendung wird gestartet oder Zustand wird ge√§ndert: l√∂st rendern aus
2. In der _Render-Phase_ werden die Komponenten-Funktionen durchlaufen, die die neue UI zur√ºckliefern
3. In der anschlie√üenden _Commit-Phase_ aktualisiert React den DOM um die √Ñndern zu "aktivieren"
4. (Der Browser aktualisiert die Darstellung. Das findet au√üerhalb von React statt)

* Die Render-Phase muss _pure_ sein, das bedeutet eine Komponenten-Funktion muss bei gleichen Parametern (Props und State) **immer** dasselbe Ergebnis liefern. Sie muss Seiteneffekt-frei sein.
  * ```javascript
    // globale Variable
    let counter = 0;

    function DoNotDoThis() {

      // Ver√§ndert den globalen Z√§hler au√üerhalb der Komponente
      // => Seiteneffekt!
      return <h1>I have been rendered {counter++} times</h1>
    }
    ```
          </textarea>
        </section>
        <section>
          <h3>Seiteneffekte</h3>
          <ul>
            <li>
              Als <b>Side effect</b> bzw. <b>Seiteneffekt</b> (k√∂nnte im deutschen auch mit
              "Nebenwirkung" √ºbersetzt werden) wird in React Code bezeichnet, der Dinge au√üerhalb
              der umschlie√üenden Komponenten-Funktion ver√§ndert.
            </li>
            <li>
              Beispiele sind: Manipulation des nativen DOM (z.B. Fenster-Titel setzen), einen Timer
              starten oder einen Server-Aufruf durchf√ºhren
            </li>
            <li>Seiteneffekte sind in der <b>Renderphase</b> einer Komponente verboten! üö®</li>
          </ul>
        </section>

        <section>
          <h3>useEffekt-Hook</h3>
          <p>
            <em
              >Mit useEffekt kann eine Funktion registriert werden, die nach dem Rendern der
              Komponente ausgef√ºhrt wird</em
            >
          </p>
          <p>
            Diese <b>Effekt-Callback</b>-Funktion wird beim <em>commit</em> der Komponente
            ausgef√ºhrt
          </p>

          <div>
            <pre><code class="javascript"  >
            function App(props) {
              React.useEffect( 
                () => console.log("I will run on EACH commit")
              );
            }
          </code></pre>
          </div>
          <div>
            2. Parameter (leeres Array) gibt an, dass die Funktion nur einmal ausgef√ºhrt werden soll
            <pre><code class="javascript"  >
              function App(props) {
                React.useEffect( 
                  () => console.log("I will run only on 1st commit"),
                  []
                );
              }
            </code></pre>
          </div>
        </section>

        <section>
          <h3>useEffect Hook</h3>

          <p>Zwei Parameter:</p>
          <ol>
            <li>
              Callback-Funktion, die aufgerufen wenn entsprechendes Ereignis eintritt (z.B.
              initiales Rendern abgeschlossen)
            </li>
            <li>
              Ein Array mit Abh√§ngigkeiten:
              <ul>
                <li>
                  Wenn kein Array angegeben wird, wird der Effekt nach jedem Rendern ausgef√ºhrt
                  (achtung! Endlosschleife m√∂glich)
                </li>
                <li>
                  Wenn ein leeres Array angegeben wird, wird der Effekt nur nach dem 1. Rendern
                  ausgef√ºhrt
                </li>
                <li>
                  Wenn Werte angegeben werden, wird der Effekt ausgef√ºhrt, wenn sich mind 1 Wert
                  ver√§ndert hat
                </li>
                <li>
                  <b>Wichtig!</b> <em>Alle</em> Werte im Dependency-Array angeben, die darin
                  verwendet werden (Werte aus Props, State, ...)
                </li>
              </ul>
            </li>
          </ol>
        </section>
        <section data-markdown>
          <textarea data-template>
### useEffect Hook: Clean-up Funktion

* Um auf das Entfernen der Komponente aus dem DOM zu reagieren (z.B Resourcen
freigeben), kann die Callback-Funktion als R√ºckgabe eine "Clean-Up"-Funktion zur√ºckliefern:
  * ```javascript
    function HelloEffect() {
      React.useEffect(
        () => {
          console.log("Ich bin gemounted worden"); 
          return () => console.log("Ich bin entfernt worden") 
        },
        [])
      );
    }
  ```
* Die Clean-Up-Funktion wird immer ausgef√ºhrt, wenn die Komponente aus dem DOM entfernt wird
              und bevor der Effekt erneut ausgef√ºhrt wird. 
* Mit der Clean-up-Funktion kann also immer die letzte Ausf√ºhrung des Effekt-Callbacks "aufger√§umt" werden
  * ```javascript
    function PostEditor() {
      const [title, setTitle] = useState("");

      React.useEffect(
        () => {
          let currentTitle = title;
          console.log("Title: ", currentTitle); 
          return () => console.log("Title war beim Commit:", currentTitle) 
        },
        [ title ])
      );
    }
    ```

</textarea
          >
        </section>

        <section>
          <h3>Beispiel: Aktualisieren des Browsertitels</h3>

          <div>
            <p>Der eingegebene Post-Titel soll auch in der Titelzeile des Browsers erscheinen.</p>
            <pre><code class="javascript"  >
                function PostEditor() {
                  const [title, setTitle] = React.useState("");
                  const [body, setBody] = React.useState("");
                
                  React.useEffect(() => {
                    // Aktuellen Titel merken
                    const currentTitle = window.document.title;
                    window.document.title = `New Post ${title}`;

                    // Nach dem Unmount bzw. erneuten Ausf√ºhrung des Effekts
                    // Titel wieder auf urspr√ºnglichen Wert zur√ºcksetzen
                    return () => window.document.title = currentTitle;


                  }, [title]);

                  return <div>...</div>

                }
                
                </code></pre>
          </div>
        </section>

        <section>
          <h3>Beispiel #2: Laden von Daten ("fetch on render")</h3>

          <div>
            <p>
              <code>useEffect</code> und <code>useState</code> werden verwendet, um Daten nach dem
              initialen Rendern zu laden
            </p>
            <pre><code class="javascript"  >
                function App() {
                  const [posts, setPosts] = React.useState([]);
                
                  React.useEffect(() => {
                    fetch("http://localhost:7000/posts")
                      .then(response => response.json())
                      .then(json => setPosts(json))
                      .catch(err => console.error("Fehler beim Laden der Daten", err))
                  }, []);

                  return &lt;PostList posts={posts} />
                }
                
                </code></pre>
          </div>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Was ist das Problem mit diesem Code?</h3>

          <pre><code class="javascript">
    function BlogList() {
      const [posts, setPosts] = React.useState([]);
    
      React.useEffect(
        async () => {
          const response = await fetch("...");
          const loadedPosts = response.json();
          setPosts(loadedPosts);
        }, []
      );
    
      return ...;
    }
    </code></pre>
          <p>
            Die Callback-Funktion liefert ein Promise zur√ºck (wird zu "undefined" aufgel√∂st)! Das
            ist nicht erlaubt, da React eine Funktion erwartet (oder undefined).
          </p>
        </section>
        <section>
          <h3>Event-Handler</h3>
          <p>
            Zur Erinnerung: In einem Event-Handler m√ºssen Seiteneffekte
            <b>kein useEffect</b> implementiert werden!
          </p>
          <pre><code class="javascript"  >
function App(props) {
  // load, as seen
  React.useEffect( ... );

  function addPost(post) {
    fetch("http://localhost:7000/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(post)
    })
      .then(response => response.json())
      .then(newPost => setPosts([newPost, ...posts]));
  }


  return
    ...
      &lt;AddPost onAdd={newPost => addPost(newPost)} />
    ...
}
                </code></pre>
        </section>

        <!-- <section>
          <h2>√úbung Fetch #2: fetch mit useEffect</h2>
          <p>
            <em
              >Implementiere die n√§chste Version der <code>App</code>-Komponente, die in der Lage
              ist, die Blog Posts mit <code>fetch</code> zu laden.</em
            >
          </p>
          <div>
            <p>Das backend ist bereits fertig. Ihr k√∂nnt es starten mit:</p>
            <pre><code>
                  cd react18-training/react-intro/backend-rest
                  npm start
                </code></pre>
            <p>Der Server l√§uft auf Port 7000</p>
            <p>
              Ihr k√∂nnt das Backend mit folgender URL testen (Browser, wget, curl, ...):
              <a href="http://localhost:7000/posts">http://localhost:7000/posts</a>
            </p>
          </div>
        </section> -->

        <!-- ============================================================================= -->

        <section>
          <h2>√úbung Fetch #2: fetch mit useEffect</h2>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li>
              F√ºge in <code>App.js</code> den Code zum <b>Laden</b> der Blog-Posts mit
              <code>useEffect</code> hinzu.
            </li>

            <li>Die URL ist identisch mit dem POST-Request</li>
            <li>
              Du must als HTTP Methode "GET" verwenden, brauchst aber keinen Content-Type setzen und
              auch keinen Body schicken
            </li>
            <li>
              Du bekommst als Ergebnis vom Server eine Liste mit (Blog-Post-)Objekten, die schon der
              Struktur entsprechen, die wir im Client erwarten (Properties id, title, body). Du
              kannst die Liste nach dem Lesen also unver√§ndert in den Zustand setzen.
            </li>
            <li>Vorheriger fertiger Stand in <code>steps/4a-remote</code></li>
            <li>M√∂gliche L√∂sung in <code>steps/4b-remote-use_effect</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
            <li>
              <b>Optional, wenn noch Zeit ist</b>: F√ºge einen Loading Indicator hinzu
              <ul>
                <li>
                  Wenn Du <code>?slow</code> an die URLs im <code>fetch</code>-Aufruf h√§ngst, wird
                  der Server-Call k√ºnstlich verlangsamt:
                  <code>http://localhost:7000/posts?slow</code>
                </li>
                <li>
                  Gib w√§hrend des laufenden Server-Requests (Daten laden) eine Meldung aus ("Please
                  wait")
                </li>
                <li>M√∂gliche L√∂sung in <code>steps/4c-remote-with-loading</code></li>
                <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
              </ul>
            </li>
          </ol>
        </section>

        <!-- <section>
          <h3>√úbung: Speichern</h3>
          <ol class="x-list">
            <li>F√ºge in <code>App.js</code> den Code zum <b>Speichern</b> der Blog-Posts hinzu.</li>

            <li>
              Die URL ist identisch mit dem GET-Request, aber Du musst als HTTP Methode
              <code>POST</code> verwenden
            </li>
            <li>Du musst als Header den Content-Type <code>application/json</code> setzen</li>
            <li>Als <code>body</code> musst Du den neuen Blog-Post an den Server schicken</li>
            <li>
              In der Antwort bekommst Du den gespeicherten Post vom Server zur√ºck. Diesen musst Du
              in die Liste der BlogPosts einf√ºgen
            </li>
            <li>
              Erinnerung: Beim Speichern der Daten (in einem EventHandler) brauchst Du kein
              <code>useEffect</code> verwenden.
            </li>
            <li>M√∂gliche L√∂sung in <code>steps/4-remote</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section> -->

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Loading Indicator</h3>
          <p>Wie geben wir dem Benutzer Feedback, dass die Daten gerade geladen werden?</p>
        </section>

        <section>
          <h3>Komplexer Zustand</h3>
          <p>
            Wenn eine Komponente mehrere Zust√§nde h√§lt, die nicht unabh√§ngig sind, kannst Du auch
            ein Objekt als Zustand verwenden:
          </p>

          <pre><code class="javascript">
function App() {
  const [fetchState, setFetchState] = React.useState({
    loading: false,
    posts: []
  });

  ...;
}              
            </code></pre>
          <p>
            Wenn Du den Zustand √§nderst, musst Du ein <b>neues Objekt</b> erzeugen! Das bestehende
            Objekt darf nicht ver√§ndert werden
          </p>

          <pre><code class="javascript">
    function App() {
      const [fetchState, setFetchState] = React.useState( /* ... */ );

      // OK:
      setFetchState({
        loading: true
      })

      // FALSCH:
      fetchState.loading = true;
      setFetchState(fetchState)
    }              
        
  </code></pre>
        </section>

        <!-- <section>
          <h3>√úbung komplexer Zustand</h3>
          <ol class="x-list">
            <li>
              In deiner <code>App</code>-Komponente hast Du zwei Zust√§nde: <code>posts</code> und
              <code>loading</code>.
            </li>
            <li>
              F√ºge die beiden Zust√§nde zu <em>einem</em> "komplexen" Zustand zusammen. Verwende also
              ein Objekt im State.
            </li>
            <li>
              Achte darauf, dass der posts-Eintrag in dem Zustand niemals null oder undefined,
              sondern immer mindestens ein leeres Array ist. (Auch beim Initialisiern dran denken!)
            </li>
            <li>
              Bitte denk immer dran, dass Du das State-Objekt nicht ver√§ndern darfst, sondern es
              immer erneut erzeugen musst.
            </li>
            <li>M√∂gliche L√∂sung in <code>steps/4-remote-with-loading</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section> -->
        <section>
          <h3>Exkurs: Custom Hooks</h3>

          <em>Eigene Hooks k√∂nnen f√ºr wiederkehrende Aufgaben genutzt werden</em>

          <p>Beispiele: Laden von Daten, Arbeiten mit spezialisiertem State, ...</p>
        </section>

        <section>
          <h3>Exkurs: Custom Hooks</h3>

          <ul class="x-list">
            <li>
              ...m√ºssen mit <code>use</code> beginnen
              <ul>
                <li>(ansonsten kann der Linter nicht auf m√∂gliche Fehler pr√ºfen!)</li>
              </ul>
            </li>
            <li>...d√ºrfen nur aus anderen (Custom) Hooks und Komponenten aufgerufen werden</li>
            <li>
              ...erwarten "normale" Funktionsparameter (nicht zwingend ein Objekt wie bei
              Komponenten)
            </li>
            <li>...d√ºrfen andere (Custom) Hooks verwenden</li>
            <li>...beliebiger R√ºckgabewert m√∂glich (alle Typen erlaubt, auch JSX!)</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Ein Custom Hook zum Laden von Daten</h3>

          <pre><code class="javascript">
import React from "react";

export default function useApi(url, initialValue) {

  const [fetchState, setFetchState] = React.useState({data: initialValue});

  React.useEffect(
    () => {
      async function loadData() {
        try {

          setFetchState({loading: true, data: initialData})
          const response = await fetch(url);
          const json = await response.json();
          setFetchState({data: json})

        } catch (err) {
          console.error("LOADING DATA FAILED:", err);
          setFetchState({error: err.toString()})
        } 
      }
      loadData();
    },
    // Make sure, this Hook only runs (after initial) when URL changes
    [url]
  );

  return [fetchState.data, fetchState.isLoading];
}
</code></pre>
        </section>
        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-typescript" -->
# Teil V
## React Anwendungen mit TypeScript
* <!-- .element: class="demo" --> Beispiel: react-intro/steps/5-typescript
          </textarea>
        </section>

        <!-- ######################################################  -->
        <section>
          <h2>TypeScript</h2>
          <ol>
            <li><a href="#/t-typescript-grundlagen">Einf√ºhrung in TypeScript</a></li>
            <li><a href="#/t-typescript-react">React mit TypeScript</a></li>
          </ol>
        </section>

        <section id="t-typescript-grundlagen">
          <h2>Einf√ºhrung: Die Sprache TypeScript</h2>
          <p class="fragment">
            <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
            <a href="http://www.typescriptlang.org/" target="_blank"
              >http://www.typescriptlang.org/</a
            >)
          </p>
          <ul>
            <li class="fragment">Erweitert JavaScript um ein Typen System</li>
            <li class="fragment">
              Jeder g√ºltige JavaScript Code ist auch g√ºltiger TypeScript Code
            </li>
            <li class="fragment">
              Mittels des TypeScript Compilers wird aus TS Code JavaScript Code
            </li>
          </ul>
        </section>

        <section>
          <h3>TypeScript Grundlagen</h3>
          <p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Variablen k√∂nnen Typ-Informationen bekommen
  let foo: string;
  foo = 'yo';
  // Error: number: This type is incompatible with string
  foo = 10;
                 </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Funktionen
  function sayIt(what: string): string {
    return `Saying: ${what}`;
  }
  
  sayIt('Klaus'); // ok
  sayIt(10); // error
  </code></pre>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Arrow Funktionen
  const sayIt = (what: string): string => `Saying: ${what}`;
  
  sayIt('Moin');
  sayIt(123); // Error: Argument of type '123' is not assignable
              // to parameter of type 'string'.
  </code></pre>
        </section>

        <section>
          <h2>Eingebaute Typen</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // string
  let city: string = 'Hamburg';
  
  // boolean
  let isDone: boolean = false;
  
  // number
  let theAnswer: number = 42;
  
  // array (note the [])
  let cities: string[] = ['Hamburg', 'Barcelona'];
  // alternative:
  let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];
  
  // void
  function log(s: string): void { /* ... */ }
              </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // any: kann alle Typen aufnehmen, Typ-Pr√ºfung ist ausgeschaltet
  let theUnknown: any = 'Who cares';
  theUnknown = 666; // ok
  theUnknown = true; // ok
  let a: number = theUnknown; // ok
  function loadData(): any { return "" // ok }
  let b:number = loadData(); // ok
  
              </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // unknown: kann ebefalls alle Typen aufnehmen, erzwingt aber vor der Verwendung Typ-Pr√ºfung
  function loadData(): unknown { return "" // ok }
  let b = loadData(); 
  b.toUpperCase(); // ERROR
  if (typeof b === "string") {
    // b ist jetzt string (typeof ist Laufzeitpr√ºfung!)
    b.toUpperCase(); // OK
  }
              </code></pre>
        </section>
        <section>
          <h2>Typen k√∂nnen abgeleitet (inferred) werden</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  let city = 'Hamburg'; // city ist ein String
  
  city = 42;
  // Fehler: [ts] Type '42' is not assignable to type 'string'.
  </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Explizite Angabe eines Types (parameter)
  // und abgeleiteter Typ (Return Type der Funktion)
  
  function sayIt(what: string) {
    return `Saying: ${what}`;
  }
  
  const said: string = sayIt('Hello TypeScript'); // ok
  const saidItWrong: number = sayIt('Hello TypeScript'); // error!
  
  
  </code></pre>
        </section>

        <section>
          <h2>Type Check ausschalten</h2>
          <p>
            Mit <code>@ts-ignore</code> (als Kommentar) kann wird die √úberpr√ºfung der n√§chsten Zeile
            ausgeschaltet:
          </p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = "Hamburg";
  
  city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.
  
  // @ts-ignore
  city = 20259; // ok                
  </code></pre>
          <p class="fragment">
            N√ºtzlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei
            Migration
          </p>
        </section>
        <section>
          <h2>null und undefined</h2>
          <div class="fragment">
            <p><code>null</code> muss explizit zugelassen werden <em>(strictNullChecks</em>):</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = null; //Type 'null' is not assignable to type 'string'.
  
  let optionalCity:string|null = null; // OK
              </code></pre>
          </div>
          <div class="fragment">
            <p><code>undefined</code> muss ebenfalls explizit zugelassen werden:</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
    let city:string = undefined; //Type 'undefined' is not assignable to type 'string'.
    
    let optionalCity:string|undefined = undefined; // OK
    let optionalCity:string|undefined|null = null; // OK
                </code></pre>
          </div>
          <div class="fragment">
            <p>
              Optionale Parameter k√∂nnen mit ? gekennzeichnet werden (erlauben dann auch
              <code>undefined</code>)
            </p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  function greet(name: string, greeting?: string) {
    console.log(`${greeting || 'Hello'}, {name}`);
  }
  
  greet('Susi', 'Moin')// Moin, Susi
  
  // 2. Parameter ist optional:
  greet('Klaus'); // Hello, Klaus
  
  greet('Peter', null); // Argument of type 'null' is not assignable
                        // to parameter of type 'string | undefined'.
              </code></pre>
          </div>
        </section>

        <section>
          <h2>Eigene Typen</h2>
          <p>
            Mit <code>interface</code> und <code>type</code>k√∂nnen eigene Typen (Objekt-Strukturen)
            definiert werden:
          </p>

          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
  // Komplexer Typ
  interface Person {
    name: string; // Pflicht
    livesIn?: string; // Optional
  }

  // Alternativ (interface und type fast synonym)
  type Person = { name: string; livesIn?: string; }
  
  const susi: Person = { // OK
    name: 'Klaus',
    livesIn: 'Hamburg'
  };
  const klaus: Person = { // OK (livesIn ist optional)
    name: 'Klaus'
  }
  
  const helmut: Person = {} // Error: Property 'name' is missing
  
  const lukas: Person = {
    name: 'Lukas',
    profession: 'Lokf√ºhrer'
  } // Error: 'profession' does not exist in type 'Person'.
                 </code></pre>
        </section>

        <section>
          <h2>Eigene Typen II</h2>
          <p>Eigene Objekt-Typen k√∂nnen sowohl "Attribute" als auch Funktionen enthalten:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
            // Komplexer Typ
            type Person {
              name: string; // Pflicht
              greet(greeting: string): string;
            }

            const p:Person = {
              name: "Klaus",
              greet(greeting: string) { 
                return `${greeting}, ${this.name}`
              }
            }
            p.greet("Hello"); // OK
            p.greet(123); // ERR: Argument of type '123' is not 
                          // assignable to parameter of type 'string'.

            const wrong:Person = {
              name: "Susi", // OK
              greet(greeting: number) {¬†return "hello" } 
                // ERR: Type '(greeting: number) => string' is not assignable to 
                //      type '(greeting: string) => string'.
                //      Types of parameters 'greeting' and 'greeting' are incompatible.
                //      Type 'string' is not assignable to type 'number'.
            }
                           </code></pre>
        </section>
        <section>
          <h2>Union Types</h2>
          <p>Variablen, Parameter etc. k√∂nnen mehr als einen Typ annehmen:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

function printNameOrTitle(obj: Person | Movie) { 

  console.log(obj.title); // ERR: Property 'title' does not 
                          // exist on type 'Person | Movie'
 
  if ("title" in obj) { // Abfrage ist ein "Type Guard"
    // obj ist Movie hier, title ist definiert
    console.log(obj.title);
  } else {
    // obj ist Person hier: name ist definiert
    console.log(obj.name);
  }
}

printNameOrTitle({name: "Klaus"}); //OK
printNameOrTitle({title: "Pulp Fiction"}); //OK
printNameOrTitle({label: "Save"}); // ERR
    
          </code></pre>
        </section>
        <section>
          <h2>Type Guards</h2>
          <p>Durch einen Type Guard k√∂nnen Typen "eingeengt" werden</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion true zurueckgibt, nimmt Typescript an,
// dass das √ºbergebene Argument vom Typ Movie ist
function isMovie(candidate: any): candidate is Movie {
  return ("title" in candidate);
}

function printNameOrTitle(obj: Person | Movie) { 
  if (isMovie(obj)) {
    // movie
  }
}
    
          </code></pre>
        </section>
        <section>
          <h2>Type Assertions</h2>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion zurueckkehrt (kein Error geworfen wird) nimmt Typescript an,
// dass das √ºbergebene Argument vom Typ Movie  ist
function assertIsMovie(candidate: any): asserts candidate is  Movie {
  if ("title" in candidate) {
    return;
  }
  throw new Error("Candidate is not a movie!")
}

function printTitle(hopefullyAMovie: any) { 
  assertPersonIsMovie(hopefullyAMovie)
  // hopefullyAMovie ist jetzt Movie
  hopefullyAMovie.title; // OK
}
    
          </code></pre>
        </section>
        <section>
          <h2>String Literal Types</h2>
          <p>Beispiel: String Aufz√§hlungstyp</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Beispiel:             
type View = "POST_LIST" | "POST_EDITOR";

const s:View = "POST_LIST"; // OK
const t:View = "POST_LISTE" // FEHLER

function setView(v: VIEW) {
    if (v === "POST_LIST") { ... } // ok
    if (v === "POST_LISTE") { ... } // error: immer false
}

setView("POST_LIST"); //OK
setView("POST_LISTE"); // ERROR
          </code></pre>
        </section>

        <section>
          <h2>√úbung: Hello, TypeScript!</h2>
          <h3>
            <em>Mach dich mit den Grundz√ºgen der Sprache TypeScript vertraut</em>
          </h3>

          <ol class="x-list">
            <li>√ñffne den TypeScript Playground im Browser (den Link gibts per Chat)</li>
            <li>Link zu den Slides als Referenz gibt's ebenfalls im Chat</li>
            <li>
              Bearbeite die Datei, so dass keine Compile-Fehler mehr vorhanden sind, TODOs siehe
              dort
            </li>
            <li>Link zur L√∂sung gibt's ebenfalls im Chat</li>
          </ol>
        </section>
        <!-- ########################################################### -->

        <section id="t-typescript-react">
          <h2>React Anwendungen mit TypeScript</h2>
          <em
            >State und Properties einer Komponente k√∂nnen mit TypeScript Typen beschrieben weden</em
          >
          <p>
            Achtung! TypeScript-Dateien, die JSX-Code enthalten, <b>m√ºssen</b> mit
            <code>.tsx</code> enden!
          </p>

          <p>
            üëâ Lasst uns ausprobieren, wie das funktioniert! (<code>workspace-typescript</code>)
          </p>
        </section>
        <section>
          <h2>Typsicherheit in Funktionskomponenten</h2>
          <pre><code class="line-numbers typescript" data-leftpad>
type PostListProps = {
  posts: BlogPost[];
  onAddPost(): void;
};
            </code></pre>
          <pre><code class="line-numbers typescript">
function BlogList(props: PostListProps) {
  props.posts.length // OK
  
  props.post // compile ERROR: Property 'post' does not exist on type 'PostListProps'.
  props.onAddPost("huhu"); // compile ERROR: Expected 0 arguments, but got 1.
}
    
            </code></pre>
          <pre><code class="line-numbers typescript" data-leftpad>
// Mit Destructuring
function BlogList({posts, onAddPost}: GreetingMasterProps) => {
  // ...
}
            </code></pre>
        </section>

        <section>
          <h3>Typ-sichere Verwendung von Komponenten</h3>

          <div>
            <p>Code Completion</p>
            <img style="height: 200px" src="slides/images/screenshot-ts-code_completion.png" />
          </div>

          <div>
            <p>Unbekanntes Property</p>
            <img style="height: 200px" src="slides/images/screenshot-ts-error-01.png" />
          </div>

          <div>
            <p>Fehlerhafte Verwendung eines Properties</p>
            <img style="height: 200px" src="slides/images/screenshot-ts-error-02.png" />
          </div>
        </section>

        <section>
          <h3>Typ-sicherheit in useState</h3>
          <p>Der Typ von useState kann grunds√§tzlich von TypeScript hergeleitet werden</p>
          <pre><code class="line-numbers typescript" data-leftpad>
type PostEditorProps = {  onSavePost(post: NewBlogPost): void; };
function PostEdior(props: PostEditorProps) {
  const [title, setTitle] = React.useState("");

  // greeting is string, because initial value is a string
  setGreeting("huhu"); // OK
  setGreeting(666); // ERROR (wrong Type)
  setGreeting(null); // ERROR (wrong Type)
}
            </code></pre>
          <div>
            <p>Du kannst alternativ den Typen auch explizit setzen</p>
            <p>Zum Beispiel notwendig, wenn der State mehr als einen Typen aufnehmen kann</p>
            <pre><code class="line-numbers typescript" data-leftpad>
type VIEW = "LIST" | "ADD";

function App() {
  const [view, setView] = React.useState&lt;VIEW>("LIST");

  // Mode ist either string "MODE_MASTER" or "MODE_DETAIL"
  // setMode only accepts the string "MODE_MASTER" and "MODE_DETAIL" 

  setMode("NOT_FOUND"); // compile error
  setMode(null); // compile error
}
                            </code></pre>
          </div>
        </section>

        <section>
          <h2>√úbung: Typ-sichere React Komponenten</h2>
          <h3>
            <em>F√ºge die fehlenden Typ-Informationen zu der App-Anwendung hinzu</em>
          </h3>
          <div style="font-size: 80%">
            <div>
              <p>
                <b>WORKSPACE:</b>
              </p>
              <p>
                Bitte benutze den Workspace <code><b>react-intro/workspace-typescript</b></code
                >. <br />Dieser enth√§lt die letzte Version unserer Anwendung, ist aber mit
                TypeScript konfiguriert.
              </p>
            </div>
            <div>
              <p>
                <b>VORBEREITUNG:</b>
              </p>
              <ol class="x-list">
                <li>Stop deinen laufenden "npm run"-Frontend-Prozess (ctrl+c)</li>
                <li>
                  F√ºhre <code><b>npm install</b></code> in
                  <code>react-intro/workspace-typescript</code> aus
                </li>
                <li>
                  F√ºhre <code><b>npm start</b></code> in
                  <code>react-intro/workspace-typescript</code> aus
                </li>
              </ol>
            </div>
          </div>
        </section>
        <section>
          <h3>√úbung: Typ Informationen hinzuf√ºgen</h3>
          <p>
            F√ºge die fehlenden Typ-Informationen in <code>PostList.js</code> und
            <code>PostEditor.js</code> hinzu
          </p>
          <p><b>Neuer Workspace</b>: <code>react-intro/workspace-typescript</code></p>
          <p></p>
          <ol style="font-size: 80%" class="x-list">
            <li>
              In <code>types.ts</code> findest Du fertige "fachliche" Typen f√ºr die Blog-Anwendung,
              die Du im folgenden verwenden kannst
            </li>
            <li>
              Benenne <code><b>PostList.js</b></code> in <code>PostList.tsx</code> um und starte
              <code>npm start</code> neu
            </li>
            <li>Stelle <code>PostList.tsx</code> auf TypeScript um</li>
            <li>
              Benenne <code><b>PostEditor.js</b></code> in <code>PostEditor.tsx</code> um und starte
              <code>npm start</code> neu
            </li>
            <li>Stelle <code>PostEditor.tsx</code> auf TypeScript um</li>
            <li>
              F√ºr Properties der <code>Message</code>-Komponente kannst Du als Typ einfach
              <code>any</code> verwenden.
            </li>

            <li>M√∂gliche L√∂sung in <code>steps/5-typescript</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <!-- ########################## TESTEN ######################################### -->
        <section id="t-test">
          <h2>Testen von React Anwendungen</h2>
        </section>

        <section data-transition="slide none">
          <h2>Was testen wir?</h2>
          <ul>
            <li><b>UI-unabh√§ngige Logik</b> (zum Beispiel Backend Calls, Berechnungen etc.)</li>
            <li>
              <b>Rendering</b> (Ist die Liste der Blog Posts korrekt? Sieht das Markup aus, wie wir
              uns das vorstellen?) und <b>Interaktionen</b> (funktionieren die Event Handler, die
              Callback-Funktionen, der Programmflu√ü etc.?)
            </li>
            <li>
              <b>Verhalten im Browser</b> (z.B. korrekte, pixelgenaue Darstellung,
              Browser-spezifisches JavaScript, Arbeiten mit Browser-Technologie wie Titelzeile,
              Session Storage, Scrollbars etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a>)</em
            >
          </p>
          <p>Vollst√§ndige Testl√∂sung f√ºr React (und andere):</p>
          <ul>
            <li>API vergleichbar mit <a href="https://jasmine.github.io/">Jasmine</a></li>
            <li>Test Runner</li>
            <li>Specs/Assertions, Mocks</li>
            <li>Code Coverage</li>
            <li>"Snapshot testing"</li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Beispiel: Ein einfacher Testfall</h3>
          <pre><code class="javascript"  >// sum.js (or sum.ts)
        export const sum = (a,b) => a+b;
                </code></pre>
          <pre><code class="javascript"  >// sum.test.js
        import {sum} from '../sum.js';
        
        test('sum of 2 and 2 is 4', () => {
          expect(sum(2, 2)).toBe(4);
        });
        
        test('sum of 2 and 2 is not 3', () => {
          expect(sum(2, 2)).not.toBe(3);
        });
                    </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code>test('it should work', () => {
          expect(...).toBe(...);
        });</code></pre>
          <pre><code>it('it should also work', () => {
          expect(...).toBe(...);
        });</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>"Expectations" und "Matchers"</h2>
          <div>
            <p>
              <code>expect()</code> liefert ein <em>Expectation</em> Objekt zur√ºck, das verschiede
              <em>Matcher</em> Funktionen bereitstellt:
            </p>
            <pre><code>expect(actual).toXyz(expected);
        // for example:
        expect("Hello Jest").toBe("Hello Jest"); // => ok
                </code></pre>
          </div>
          <div>
            <p>Beispiele f√ºr Matchers</p>

            <pre><code>// Compare identity
        expect(actual).toBe(expected);
        // Compare value:
        expect(actual).toEqual(expected);
        // true / false / null:
        expect(actual).toBeTruthy();
        expect(actual).toBeFalsy();
        expect(actual).toBeNull();
        // Length (Array oder String)
        expect(actual).toHaveLength(123);
                </code></pre>
          </div>
          <p>
            <a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a>
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Funktionen</h2>
          <ul>
            <li>
              <code>jest.fn()</code> erzeugt eine Mock-Funktion
              <pre><code>// Gibt undefined zur√ºck, wenn die Mock-Funktion ausgef√ºhrt wird
        const aMockFn = jest.fn();
        
        const x = aMockFn("huhu"); // => undefined
        expect(x).toBeUndefined();
        
        expect(aMockFn).toHaveBeenCalled());
        expect(aMockFn.toHaveBeenCalledWith("huhu"));
                              </code></pre>
            </li>

            <li>
              Implementierung der Mock-Funktion kann als Parameter √ºbergeben:
              <pre><code>
                const aMockFn = jest.fn( param => `Hello, ${param}` );
                
                console.log(aMockFn('World'));
                // => Hello, World
                          </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Testen von React Komponenten</h3>
          <h2>Nur rendern</h2>
        </section>

        <section>
          <h3>React Test Renderer</h3>
          <p>
            <a href="https://www.npmjs.com/package/react-test-renderer"
              >https://www.npmjs.com/package/react-test-renderer</a
            >
          </p>
          <p>Rendert React Komponenten in JSON Objekte (ohne DOM):</p>
          <pre><code class="javascript"  >import renderer from 'react-test-renderer';
        
        const component = renderer.create(
          &lt;PostList posts={somePosts} />
        );
        
        console.log(component.toJSON());
                    </code></pre>
          <pre><code class="javascript"  >
                { type: 'div',
                  props: {},
                  children:  [
                    { type: 'button', props: {}, children: [Object] },
                    { type: 'article', props: [Object], children: [Object] },
                    { type: 'article', props: [Object], children: [Object] }
                  ]
                }
                    </code></pre>
        </section>
        <section>
          <h3>"Snapshot Testing" mit Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> vergleicht ein erzeugtes JSON-Objekt mit
            einem gespeicherten JSON-Objekt aus einer Datei:
          </p>
          <ul>
            <li>
              Bei der <b>ersten</b> Ausf√ºhrung: Snapshot-Datei wird angelegt (
              <a href="slides/images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
              <ul>
                <li>Die Snapshot-Datei wird nun in Git eingecheckt</li>
              </ul>
            </li>
            <li>
              In den <b>folgenden</b> Test Ausf√ºhrungen: ein neuer Snapshot wird jeweils erzeugt und
              mit dem <b>gespeicherten</b> Snapshot verglichen
            </li>
            <li>
              Wenn die Snapshots nicht identisch sind:
              <ul>
                <li>
                  Fehler mit Unterschieden (<a
                    href="slides/images/jest-snapshot-diff.png"
                    target="_blank"
                    >Beispiel</a
                  >)
                </li>
                <li>
                  Im "watch mode" von Jest kann der Snapshot aktualisiert werden
                  <img src="slides/images/jest-snapshot-update.png" />
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Snapshot Tests mit Jest und React</h3>
          <pre><code class="javascript"  >import renderer from 'react-test-renderer';
                
        test('it should render correctly', () => {
        
          const somePosts = [ . . . ];
        
          const component = renderer.create(
            &lt;PostList posts={somePosts} />
          );
        
          expect(component.toJSON()).toMatchSnapshot();
        });
                    </code></pre>
        </section>

        <section>
          <h3>Testing React Components #2</h3>
          <h2>Interaktionen</h2>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage good testing
              practices."
            </em>
          </p>

          <p>
            <a href="https://github.com/testing-library/react-testing-library" target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophie: Tests werden aus User-Perspektive geschrieben. Das bedeutet, um die zu
            testenden Elemente zu finden, suchst Du nach Eigenschaften, nach denen auch ein User
            suchen w√ºrde (z.B. Labels, Placeholder etc.)
          </p>
          <p>üëâ <code>workspace-typescript</code></p>
        </section>
        <section>
          <h3>react-testing-library</h3>
          <p>Example</p>
          <pre><code class="javascript"  >
                    import { render, screen } from "@testing-library/react";
                    import userEvent from "@testing-library/user-event";
        
                    it("invokes callback on button click", () => {
                      const onAddPostFn = jest.fn();
                    
                      // Render
                      render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
                    
                      // search the button
                      const buttonElement = screen.getByRole("button", { name: "Add Post" });
        
                      // "click" the button
                      userEvent.click(buttonElement);
                    
                      // make sure it has been invoked
                      expect(onAddPostFn).toHaveBeenCalled();
                    });
        
        
                    </code></pre>
        </section>

        <section>
          <h3>Die render-Funktion</h3>
          <ul>
            <li>
              Die render-Function aus der react-testing-library wird im Test verwendet, um eine
              React Komponente (ohne Browser) zu rendern
            </li>
            <li>Genauso wie in der Anwendungen k√∂nnen Properties angegeben werden</li>
            <li>
              <pre><code class="javascript"  >
        import { render } from "@testing-library/react";
          
        // Render a single component
        render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
                    </code></pre>
            </li>
            <li>
              Dran denken, ggf. Contexte ebenfalls zu erzeugen, falls diese ben√∂tigt werden (React
              Router, Redux etc)!
            </li>
            <li>
              <pre><code class="javascript"  >
        
        // Render with surrounding Redux Provider (or Router, your own Context etc.)
        render(
          &lt;Provider>
            &lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />
          &lt;/Provider>
        );
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>query Funktionen</h3>
          <p>
            Um die gerenderten HTML-Elemente aus deiner Komponente zu √ºberpr√ºfen und mit ihnen zu
            interagieren, musst Du sie ersteinmal finden ü§ì
          </p>
          <p>
            Auf dem globalen <b>screen</b> Objekt der Testing-Lib sind verschiedene Funktionen
            definiert, mit denen Du nach Elementen suchen kannst
          </p>
          <p>
            Die query-Funktionen haben unterschiedliche <b>Suffixe</b>, die beschreiben,
            <b>nach welchem Kriterium</b> Du suchst (nach Label, nach aria-role, ...)
          </p>
          <p>
            Die Funktionen haben au√üerdem jeweils einen <b>Pr√§fix</b> (getBy, queryBy etc) der
            beschreibt, die Art des R√ºckgabewerts der jeweilgen Funktion (z.B. ob sie einen Error
            wirft oder null zur√ºckgibt, wenn das angefragte Element nicht gefunden wurde)
          </p>
          <p>
            Mehr zu den query-Funktionen:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre><code class="javascript">
          // BEISPIELE: 
        
          // suche nach einem Button (Annahme: es gibt GENAU EINEN, ansonsten schl√§gt der Test fehl)
          const buttonElement = screen.getByRole("button", { name: "Add Post" });
        
          // suche nach einem Button (gibt null oder EINEN Button, wirft ansonst einen Fehler)
          const buttonElement = screen.queryByRole("button", { name: "Add Post" });
        
          // suche nach einem Button (gibt alle gefunden zur√ºck oder ein leeres Array)  
          const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
        </code></pre>
        </section>

        <section>
          <h3>√úberpr√ºfen von Elementen</h3>
          <p>
            Wenn Du dein gesuchtes Elemente gefunden hast, kannst Du es √ºberpr√ºfen, ob es deinen
            Erwartungen entspricht (korrekte Attribute gesetzt etc.)
          </p>
          <p>
            Die Bibliothek
            <a href="https://github.com/testing-library/jest-dom" target="_blank">jest-dom</a> f√ºgt
            dazu DOM-spezifiche Matcher f√ºr Jest hinzu.
          </p>

          <pre><code class="javascript">
          import { screen } from "@testing-library/react";
        
          const buttonElement = screen.queryByRole("button", { name: "Add Post" });
        
          // stellt sicher, dass das Element im DOM vorhanden ist (getBy-Query w√ºrde hier vielleicht mehr Sinn machen)
          expect(buttonElement).toBeInTheDocument();
        
          // sicherstellen, dass ein Eingabefeld einen erwarteten Wert hat
          expect(titleInput).toHaveValue("Moin moin");
        
          // sicherstellen, dass ein Button disabled ist
          expect(okButton).toBeDisabled();
        </code></pre>
          <p>Alle Matcher sind auf der oben verlinkten GitHub Seite dokumentiert</p>
        </section>
        <section>
          <h3>Interaktionen</h3>
          <p>
            Du kannst mit den Elementen interagieren, in dem Du ihnen Events sendest, genau wie es
            ein Browser tun w√ºrde
          </p>
          <p>
            Es gibt eine weitere Bibliothek,
            <a href="https://github.com/testing-library/user-event" target="_blank"> user-event</a>,
            die dir dabei hilft, die Events zu erzeugen.
          </p>

          <pre><code class="javascript">
                    import userEvent from "@testing-library/user-event";
                    // Simuliert die Eingabe in ein Textfeld
                    userEvent.type(titleInput, "New Title");
        
                    // Simuliert den Klick auf einen Button
                    userEvent.click(clearButton);
                  </code></pre>
          <p>Alle Events sind auf der GitHub Seite beschrieben (Link oben)</p>

          <p>
            Vor dem Versenden eines Events musst Du <b>nicht</b> √ºberpr√ºfen, ob das Element, dem Du
            das Event senden willst, vorhanden ist. Die Bibliothek gibt eine sehr sprechende Fehler
            aus, wenn das Element nicht vorhanden ist
          </p>
        </section>
        <section>
          <h3>Testen von fetch-Aufrufen</h3>
          <p>Herausforderungen:</p>
          <ul>
            <li>Asynchroner Code (nicht beschr√§nkt auf fetch)</li>
            <li>Server Zugriffe/Server Mocks</li>
          </ul>
        </section>
        <section>
          <h3>Behandlung von asynchronem code</h3>
        </section>

        <section>
          <h3>Testen von asynchronem Code</h3>
          <p>
            Beispiel: Die <b>App</b> Komponente l√§dt Daten, <em>erst dann</em> stellt sie die
            PostList dar. Das Laden der Posts ist asynchron.
          </p>

          <pre><code class="javascript">
                    it("should render posts read from backend", () => {
                      render(&lt;App />);
                    
                      // Annahme: es gibt einen Artikel mit dem Title "Learning React"
                      const articleOne = screen.findByRole("heading", { name: "Learning React" });
        
                      expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
                    });
                  </code></pre>
          <p>
            Wir k√∂nnen einen Test als async-funktion schreiben und darin mit <b>await</b> auf ein
            Element warten
          </p>
          <pre><code class="javascript">
                    // Test-Funktion als async-Funktion (beachte 'async'):
                    it("should render posts read from backend", async () => {
                      render(&lt;App />);
                    
                      // Beachte await hier:
                      const articleOne = await screen.findByRole("heading", { name: "Learning React" });
        
                      expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
                    });
                  </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Testen von fetch</h3>
          <p>Wie gesehen, k√∂nnen wir asynchronen Code testen</p>
          <p>Wollen wir fetch-Aufrufe in unserem Code haben, den wir testen?</p>
          <p>
            M√∂glicherweise nicht, weil wir bei echten fetch-Aufrufen auch einen echten, laufenden
            und funktionierenden Server im Test br√§uchten
          </p>
          <p>Stattdessen wollen wir das "echte" fetch mocken</p>
        </section>

        <section>
          <h3>Fetch mocken, Ansatz #1</h3>
          <p>Wir k√∂nnen <b>komplette Module</b> in Jest mocken</p>
          <p>Wir k√∂nnten unseren fetch-Code in ein eigenes Modul schieben und das dann mocken</p>

          <pre><code class="javascript">
                    // api.ts (fetch vereinfacht!)
                    export function readPosts() {
                      return fetch("http://localhost:7000/posts").then(response => response.json());
                    }
                  </code></pre>

          <pre><code class="javascript">
                    // App.tsx:
        
                    import { readPosts } from "./api";
                    function App() {
                      // ...
                      React.useEffect(() => {
                        // Verwenden von readPosts hier:
                        readPosts()
                          .then(json => {
                            setLoading(false);
                            setPosts(json);
                          })
                          .catch(err => console.error("Loading data failed: " + err));
                      }, []);
                    }
                  </code></pre>
        </section>
        <section>
          <h3>Mocken von Modulen in Jest</h3>
          <p>Es gibt mehrere Varianten. Das hier die einfachste(?)</p>

          <pre><code class="javascript">
                    // App.test.tsx
        
                    const mockPosts = [
                      { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
                      { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
                    ];
        
                    jest.mock("../api", () => ({
                      readPosts: () => Promise.resolve(mockPosts)
                    }));
        
                    it("should render posts read from backend", async () => {
                      render(&lt;App />);
                    
                      // Hier immer noch asnychroner Code (deswegen await), aber:
                      // kein laufender Server mehr ben√∂tigt
                      const articleOne = await screen.findByRole("heading", { name: "One" });
                      expect(articleOne).toBeInTheDocument();
        
                      expect(screen.getByText("Second Post")).toBeInTheDocument();
                    });
                  </code></pre>
          <p>
            Beispiel:
            <code
              >react-intro/steps/6a-testing-with-api-module/src/__tests__/App_module_mock.test.tsx</code
            >
          </p>
        </section>
        <section>
          <h3>Ansatz #2: fetch API mocken</h3>
          <p>Es gibt mehrere Bibliothken mit fetch-Mocks</p>
          <p>
            F√ºr mich funktioniert
            <a href="https://www.npmjs.com/package/jest-fetch-mock" target="_blank"
              >jest-fetch-mock</a
            >
            am Besten
          </p>

          <pre><code class="javascript">
                    // App.test.tsx
                    it("should render posts read from backend", async () => {
                      // setzen des Ergebnisses, das der n√§chste fetch-Aufruf zur√ºckliefern soll
                      fetchMock.mockResponse(JSON.stringify(mockPosts));
        
                      render(&lt;App />);
                    
                      // Immer noch asynchroner Code, aber kein "echter" fetch-Aufruf mehr,
                      // zur√ºckgegeben wird das oben angegebene Ergebnis
                      const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });
        
                      expect(articleOne).toBeInTheDocument();
                    });
        
                  </code></pre>
          <p>
            Beispiel:
            <code
              >react-intro/steps/6a-testing-with-api-module/src/__tests__/App_jest_mock.test.tsx</code
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ansatz #3: Mock Service Worker (MSW)</h3>

          <p><a href="https://github.com/mswjs/msw" target="_blank">MSW</a></p>
          <p>
            MSW mockt echte Server-Aufrufe mit einem
            <a href="https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API"
              >Service Worker</a
            >
          </p>
          <p>
            fetch-Aufrufe werden "richtig" ausgef√ºhrt, aber beantwortet von dem Service Worker Mock
          </p>

          <pre><code class="javascript">
                    // PostList.test.js
                    import { rest } from 'msw'
                    import { setupServer } from 'msw/node'
                    
                    const server = setupServer(
                      rest.get('/posts', (req, res, ctx) => {
                        return res(ctx.json( mockPosts ))
                      }),
                    )
        
                    test("it should render blog list", async () => {
                      render(&lt;PostList />);
                      // ...
                    })
                  </code></pre>
        </section>

        <section>
          <h2>√úbung: Ein Test f√ºr den PostEditor</h2>
          <p>Schritte:</p>
          <ol>
            <li>Arbeite in <code>blog-example/workspace-typescript</code></li>
            <li>Starte in einem neuen Terminal <code>npm test</code> (der Prozess l√§uft "ewig")</li>
            <li>
              Es sollte einen fehlerhaften Test geben:
              <b><code>PostEditor.test.tsx</code></b
              >.
            </li>
            <li>Warum? Weil der noch leer ist üò¨!</li>
            <li>
              Implementiere den fehlenden Test. In der Datei<b><code>PostEditor.test.tsx</code></b>
              stehen TODOs daf√ºr
            </li>
            <li>
              Hinweis: wenn Du die Datei speicherst, werden die Tests automatisch neu ausgef√ºhrt
              (solange Du
              <code>npm test</code> noch laufen hast), ansonsten kannst Du "a" auf der Kommandozeile
              dr√ºcken, zum erneuten Ausf√ºhren der Tests.
            </li>
            <li>M√∂gliche L√∂sung in <code>steps/6-test</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <section>
          <h2>Browser Tests</h2>
          <p>H√§ufig eingesetzt:</p>
          <ul>
            <li>
              <a href="https://www.selenium.dev/">Selenium - The "classic"</a>
            </li>
            <li><a href="https://www.cypress.io/" target="_blank">Cypress</a></li>
            <li>
              <a href="https://devexpress.github.io/testcafe/" target="_blank">TestCafe</a> (mit
              Support f√ºr sehr viele Browser, u.a. auch den Cloud-Service
              <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>)
            </li>
            <li>
              <a href="https://playwright.dev/">Playwright</a> von Microsoft. Noch relativ neu,
              Hype-Kurve zeigt gerade steil nach oben.
            </li>

            <li>
              In TestCafe und Cypress werden die Tests in JavaScript/TypeScript geschrieben,
              Selenium und Playwright gibt's f√ºr mehrere Sprachen
            </li>
          </ul>
        </section>
        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-router" -->            
## Routing in React

* Anforderungen:
  * URLs auf Komponenten abbilden
  * (Interne) Links, die die Anwendung neu rendern, ohne zum Server zu gehen
* React bringt keinen Router mit
* In der Regel wird der **React Router** verwendet

---

## Der React Router

* Homepage: [https://reactrouter.com/](https://reactrouter.com/)
* Aktuelle Version v6
* Achtung: Verhalten und API haben sich in Version 4, 5 und 6 ge√§ndert.
  * Bei Beispielen/Dokumentation/Tutorial etc. die Version beachten!

---

## Der React Router

### Beispiel

```jsx
const routerConfig = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    children: [
      {
        index: true,
        element: <PostListPage />
      },

      {
        path: "post/:postId",
        element: <PostPage />
      },
      {
        path: "add",
        element: <PostEditorPage />
      },

      { path: "*", element: <NotFoundPage /> }
    ]
  }
]);

export default function App() {
  return <RouterProvider router={routerConfig} />;
} 
```

---

### Die Router-Komponente

* Als oberste Komponente muss die `RouterProvider`-Komponente gerendert werden
* Dieser wird die Router-Konfiguration √ºbergeben
* Es gibt verschiedene Router-Typen, die sich unter anderem darin unterscheiden, wie mit den URLs umgegangen wird:
* Router fest, welche URLs generiert werden soll:
* [Hash Router](https://reactrouter.com/en/main/routers/create-hash-router): Die Route wird durch Hash-Zeichen (`#`) getrennt hinter die URL geschrieben (Beispiel: `http://loalhost:8080#/post/1`)
  * √Ñnderungen in der URL hinter dem Hash-Zeichen f√ºhren im Browser nicht zum Neuladen der Seite vom Server!
  * Der Server wird also beim Seitenwechsel nie kontaktiert
* [Browser Router](https://reactrouter.com/en/main/routers/create-browser-router): Die Route wird direkt hinter die URL geschrieben. Sieht dann aus wie eine "normale" Route vom Server (Beispiel: `http://localhost:8080/post/1`)  
  * Empfohlene Implementierung
  * Bei der Navigation durch die Anwendung unterbindet der Router Server-Requests
  * Aber beim initalen Laden muss der Server sicherstellen, dass die URL gefunden wird
    * Dazu muss der Webserver entsprechend konfiguriert werden ("/..." -> index.html)
* [Memory Router](https://reactrouter.com/en/main/routers/create-memory-router): Zum Testen au√üerhalb eines Browsers, simuliert das Browser Verhalten    
* üëâ Demo im Browser, Netzwerkverkehr untersuchen

---

### Konfiguration der Routen: Welche Komponente soll f√ºr welche Route angezeigt werden?

* Mit dem `Route`-Objekt wird die Konfiguration beschrieben, welche Pfade es in Eurer Anwendung gibt, und welche Komponenten jeweils gerendert werden sollen.
* Es gibt zwei Notationen, eine Objekt- und eine Komponenten-Form
  * Beide sind identisch
  * Wenn ihr die Komponenten-Form verwendet, m√ºsst ihr die Komponenten an die Funktion `createRoutesFromElements` √ºbergeben
---
### Routen als Objekt

```typescript
  const routerConfig = createBrowserRouter([
    {
      path: "/",
      element: <RootLayout />,
      children: [
        {
          index: true,
          element: <PostListPage />
        },

        {
          path: "post/:postId",
          element: <PostPage />
        },
      ]
    }
  ]);
```
---
### Routen als Komponenten

```typescript
  const routerConfig = createBrowserRouter(
    createRoutesFromElements(
      &lt;Route path="/" element={&lt;RootLayout />}> 

        &lt;Route index element={&lt;BlogListPage /> } />

        &lt;Route path="post/:postId" element={&lt;PostPage />}> 

      &lt;/Route>
    )
  );
```

---
### Verschachtelte Routen

* `Route`-Komponenten k√∂nnen geschachtelt werden, um Hierchien abzubilden
* In den Child-Komponenten werden dann relative Pfade angegeben
* ```javascript
    &lt;Route path="/" element={&lt;App />}> &lt;!-- Rendert "/" -->
      &lt;Route path="blog" element={...}> &lt;!-- Rendert "/blog" -->

        &lt;Route path="new" element={...}/> &lt;!-- Rendert "/blog/new" -->

        &lt;Route path="post/:id" element={...}/> &lt;!-- Rendert "/blog/post/1" -->

      &lt;/Route>
    &lt;/Route>    
  ```
---
### Outlet

* Eine Komponente f√ºr eine Route kann die Komponenten f√ºr die Unter-Routen einbinden
* Auf diese Weise kann eine Oberkomponente zum Beispiel ein gemeinsames Layout implementieren
* Die Oberkomponente muss dann jeweils die Unterkomponenten rendern
  * Das funktioniert mit der [`<Outlet />`](https://reactrouter.com/en/main/components/outlet)-Komponente
  * ```javascript
    function App() {
      return &lt;div className="App">
        &lt;h1>Blog App</h1>
        &lt;Outlet />
      &lt;/div>
  }
```    

---

### Index Routes

* Bei verschachtelten Routen muss f√ºr die Ober-Route eine Index Route gerendert werden
* Beispiel:
* ```javascript
    &lt;Route path="/" element={&lt;App />}> 
      &lt;Route path="blog" element={&lt;Blog />} />
    &lt;/Route>    
  ```
* Hier wird `Blog` als `Outlet` in `App` f√ºr `/blog` gesetzt. Aber kein Outlet f√ºr `/`
* Dazu muss eine Index-Route definiert werden. Die wird unterhalb der Ober-Route eingesetzt und
  wird dann gerendert, wenn genau der Pfad der Ober-Route aufgerufen wird
* Statt `path` wird darin einfach `index` angegeben:  
  * ```javascript
    &lt;Route path="/" element={&lt;App />}> 
      &lt;Route index element={&lt;Home /> } /> &lt;!-- Rendert "App" mit Outlet "Home" f√ºr "/" -->
      &lt;Route path="blog" element={&lt;Blog />} /> &lt;!-- Rendert "App" mit Outlet "Blog" f√ºr "/blog" -->
    &lt;/Route>    
  ```


---

### Fallback Route

* Mit `path="*"` kann eine Fallback-Route angegeben werden, die aktiv ist, wenn keine andere Route passt
* Beispiel:
* ```javascript
    &lt;Route path="/" element={&lt;App />}> 
      &lt;Route path="blog" element={&lt;Blog />} />

      &lt;Route path="*" element={&lt;NotFound />} /> &lt;!-- F√ºr alle Route, au√üer / und /blog -->
    &lt;/Route>    
  ```

---

### Dynamische Parameter

* In einer Route k√∂nnen Platzhalter ("Parameter") angegeben werden
* Auf die entsprechenden Werte kann in einer Komponente mit `useParams` zugegriffen werden
* ```javascript
  // Konfiguration:
  &lt;Route path="/" element={<Page />}>
    &lt;Route path="/post/:postId" element={<PostPage />} />
    // ...
  &lt;/Route>

  function PostPage() {
    const { postId } = useParams(); 
    //  /post/p1  postId: "p1"
    //  /post/1  postId: "1"
  }
  ```  

---

### Links

* Links m√ºssen mit der [`Link`](https://reactrouter.com/docs/en/v6/components/link)-Komponente gerendert werden
* ```javascript
  function PostTeaser({post}) {
    return &lt;div>
      &lt;h1>{post.title}&lt;/h1>
      &lt;Link to={`/post/${post.id}`}>Read more&lt;/Link>
    &lt;/div>  
  }
```
* Die `Link`-Komponente rendert ein `a`-Element, verhindert aber, dass der Browser Serveraufrufe durchf√ºhrt,
  wenn darauf geklickt wird
* Das gilt nur f√ºr interne Links, externe Links wie gewohnt mit HTML `a`-Element
* Alternative: [`NavLink`](https://reactrouter.com/docs/en/v6/components/nav-link) wei√ü, ob der `to`-Pfad
  der gerade aktiven Route entspricht und kann sich dann anders darstellen ("Aktiver Link", "Aktiver Tab", ...)
  * ```javascript
    function NavBar() {
      return &lt;div>
        &lt;NavLink to={`/home}`} className={active => active ? "Tab--active":"Tab--default" }>Home&lt;/Link>
        &lt;NavLink to={`/about}`} className={active => active ? "Tab--active":"Tab--default" }>About&lt;/Link>
        &lt;NavLink to={`/profile}`} className={active => active ? "Tab--active":"Tab--default" }>Profile&lt;/Link>
      &lt;/div>  
    }
```
* Mit `className` und `style` k√∂nnen Callback-Funktionen √ºbergeben werden, die das konkrete Styling/CSS Klasse je nach Zustand
  (active bzw not-active) zur√ºckliefern. 

---

### Navigation per API

* Die [`Navigate`](https://reactrouter.com/docs/en/v6/components/navigate)-Komponente kann gerendert werden,
  wenn eine Komponente beim Rendern einen Redirect machen m√∂hcte
* ```javascript
  function BlogPost() {
    const [error, setError] = useState(false);
    const [post, setPost] = useState(null);

    useEffect( () => fetch(...).catch(e => setError(true)), [] );

    if (error) {
      return &lt;Navigate to="/error" />
    }

    return &lt;BlogPost post={post} />
  }
  ```  
* Mit [`useNavigate`](https://reactrouter.com/en/6.16.0/hooks/use-navigate) kann auch per API, z.B. in einem Event Handler, ein Redirect gemacht werden:
* ```javascript
  function LogoutButton() {
    const useNaviate = useNavigate();

    function handleClick() {
      navigate("/");
    }

    return &lt;button onClick={handleClick}>Logout&lt;/button>
  }
  ```  

---
### √úbung: Router

* Stelle die Anwendung auf den React Router um
* **Vorbereitung**:
  * Wir arbeiten im `workspace-typescript`
  * üëâ Kopiere die Dateien aus `material/7-router` in dein `src`-Verzeichnis
  * Darin enthalten ist bereits jeweils eine `Page`-Komponente f√ºr jede Route
    * Diese Komponenten "wrappen" unsere bisherigen Komponenten (PostList, PostEditor)

---
### √úbung: Router

**Schritte**  
1. Baue die `App`-Komponente um. Diese soll jetzt nur noch einen `RouterProvider` rendern
2. Erzeuge die Router-Konfiguration daf√ºr:
    - `/` soll das `RootLayout` redern
      - Darin musst Du noch die `Outlet`-Komponente erg√§nzen
    - Die `index`-Komponente f√ºr `/` soll `PostListPage` sein
      - In deiner `PostList`-Komponente reicht es nun, wenn du statt `post.body` nur `post.title` anzeigst 
        - Es soll ja nur eine "Vorschau" auf den Blog-Post sein
      - Jeder der Titel soll ein Link auf die neue vollst√§ndige Darstellung enthalten (`/post/${post.id}`)
      - Au√üerdem musst Du den `onAdd` Handler entfernen und stattdessen einen `Link` auf die `add`-Route setzen
        (den Button durch Link ersetzen)
    - F√ºr `/post/:postId` soll die `PostPage` generdert werden
      - Darin musst Du den `postId`-Parameter aus der URL auslesen!
    - F√ºr `/add` soll die `PostEditorPage` gerendert wreden
3. L√∂sung findest Du in `steps/7-router-with-typescript`
4. Wenn Du fertig bist, bitte Hand heben ‚úã  

---
<!-- .slide: id="t-data-fetching-libs" -->

## Data Fetching: Alternativen
* Mit `useEffect` und `fetch` stehen dir "Low-Level-APIs" zur Verf√ºgung, um mit serverseitigen Daten zu arbeiten
* Diese APIs sind React (`useEffect`) bzw. Browser (`fetch`) Standard APIs
* Es gibt aber spezialisierte Bibliotheken, die das Arbeiten mit Daten erleichtern k√∂nnen.
  * [TanStack Query](https://tanstack.com/query/latest) / und [Vercel SWR](https://swr.vercel.app/): Zwei Bibliotheken zum Laden/Speichern von Daten inklusive Cache-Funktion
  * [Redux Toolkit Query](https://redux-toolkit.js.org/rtk-query/overview): Arbeiten mit APIs in Redux-Anwendungen
  * [Apollo GraphQL Client](https://www.apollographql.com/docs/react/): Client f√ºr GraphQL APIs mit Cache und Statemanagement M√∂glichkeiten
---
### Beispiel: TanStack Query            
---
### Schritt-f√ºr-Schritt: Laden und speichern von Daten mit "TanStack Query"

* üëâ `steps/3-hierarchy`

---
### Der QueryClient

* Zentrales Konfigurationsobject: `QueryClient`
* React-unabh√§ngig
* Wird beim Starten der Anwendung initialisiert
* Oft reichen Default-Einstellung
* Es k√∂nnen aber z.B. globale Refetch-Policies eingestellt werden
* Das Objekt wird per QueryClientProvider in die Anwendung gereicht
* ```typescript
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false
      }
    }
  });

  root.render(
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  );
  ```

---

### Laden von Daten: useQuery

* Queries werden mit dem [useQuery-Hook](https://tanstack.com/query/latest/docs/react/guides/queries) ausgef√ºhrt
* Der Hook erwartet ein Konfigurationsobjekt
  * `queryKey`: Array mit Query Keys (zur Interaktion mit dem Cache)
  * `queryFn`: Funktion zum Laden der Daten
  * Weitere Konfigurationen (optional)
* ```typescript
  import { useQuery } from "react-query";
  import { loadBlogPosts } from "./blog-api";
  function BlogListPage() {

    const result = useQuery({queryKey: ['posts'], queryFn: loadBlogPosts});

    // ...
  }
  ```

---

### Query Keys

* Mit den [Query Keys](https://tanstack.com/query/latest/docs/react/guides/query-keys) wird ein Ergebnis im Cache gespeichert
* Ein Query Key besteht aus einem Array von Werten
* √úblicherweise ist es ein Name (z.B. "posts") und dann ggf. weitere Parameter, zum Beispiel die Id eines Posts ("P1")
  oder die Sortierreihenfolge
  * Also alle Daten, die den Query exakt beschreiben
* ```typescript
  import { useQuery } from "react-query";
  import { loadBlogPosts } from "./blog-api";

  function BlogPage({blogPostId}) {

    // F√ºr jeden Aufruf mit einer neuen blogPostId
    //  wird das Ergebnis separat in den Cache gelegt
    const result = useQuery({
      queryKey: ['blogPost', blogPostId], 
      queryFn: () => loadPost(blogPostId)
    });

    // ...
  }
  ```
* Wenn ein Query mit denselben Query Keys in mehr als einer Komponente ausgef√ºhrt wird
* stellt TanStack Query sicher, dass der Query nur einmal ausgef√ºhrt wird
* wenn sich das Ergebnis √§ndert, werden alle Komponenten, die den Query verwenden,
automatisch aus dem Cache aktualisiert
---

### Query Function

* `useQuery` erwartet eine [Query-Function](https://tanstack.com/query/latest/docs/react/guides/query-functions), die den eigentlichen Request ausf√ºhrt
* Die Signatur ist fast beliebig, die Funktion muss aber ein Promise zur√ºckliefern:
* Wenn die Daten erfolgreich geladen wurden, muss das Promise mit den Daten "aufgel√∂st" werden
* Wenn es einen Fehler gab, muss die Funktion einen Fehler werfen
* ```typescript
  // async function gibt IMMER ein Promise zur√ºck
  export async function loadBlogPost(postId) {
    const response = await fetch("http://localhost:7000/posts" + postId);

    if (!response.ok) {
      throw new Error("Could not load blog post: " + response.status);
    }

    return response.json();
  }
  ```

---

### R√ºckagebwert von `useQuery` (Query Ergebnis)

* `useQuery` liefert ein Objekt zur√ºck:
* `isLoading`: Der Query l√§dt noch (und es sind keine Daten im Cache)
* `isSuccess`: Daten sind geladen
* `isError`: Es ist ein Fehler aufgetreten
* `data` enth√§lt die geladenen Daten
* `error`: Fehlerobjekt aus der Query-Funktion 
* Weitere [siehe Doku](https://tanstack.com/query/latest/docs/react/reference/useQuery)

---

### TanStack Query: Mutations

* Mutations werden verwendet, um Daten zu schreiben
* Mutations haben keinen Cache-Key und werden auch nicht automatisch ausgef√ºhrt
* Die Mutation-Funktion entspricht der Query-Function (nur dass sie Daten schreibt und nicht liest)
* Auch der `useMutation`-Hook liefert Informationen √ºber den Zustand der Mutation zur√ºck
* Au√üerdem wird eine Funktion (`mutate`) zur√ºckgeliefert, die die Mutation ausf√ºhrt
* √úbergeben wird der Funktion die zu schreibenden Daten
* ```typescript
  import { useMutation } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const mutation = useMutation({
      mutationFn: savePost,
      onSuccess() {
        // optional: wird aufgerufen, wenn die Mutation erfolgreich war
        // ...
      }
    });

    if (mutation.status === "error") {
      return <h1>Error!</h1>;
    }

    if (mutation.status === "loading") {
      return <h1>Saving, please wait!</h1>;
    }

    return <PostEditor onSavePost={mutation.mutate} />;
  }
  ```

---

### Aktualisieren von Daten

* Alle Query-Ergebnisse von `useQuery` werden automatisch gecached
* Alle Komponenten werden aktualisiert, wenn sich der Cache aktualisiert
* Alle Daten im Cache werden als "stale" (veraltet) angesehen
* [Per Default](https://tanstack.com/query/latest/docs/react/guides/important-defaults) werden Queries deswegen automatisch neu ausgef√ºhrt:
* Komponente wird (neu) gemounted
* Browser-Fenster bekommt den Focus
* Nachdem das Netzwerk offline war

---

### Manuelles Aktualisieren von Queries

* Queries k√∂nnen per API manuell erneut ausgef√ºhrt werden
* Das kann zum Beispiel nach einer Mutation sinnvoll sein, um die ge√§nderten/gespeicherten Daten 
im Cache zu aktualisieren
* Dazu wird die Funktion [`invalidateQueries`](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientinvalidatequeries) vom `QueryClient` verwendet
* √úbergeben werden die Query Keys, deren Queries erneut ausgef√ºhrt werden sollen
* ```typescript
  import { useMutation, useQueryClient } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const queryClient = useQueryClient();
    const mutation = useMutation({
      mutationFn: savePost, 
      onSuccess() {
        // PostPage-Query erneut ausf√ºhren, wenn Mutation erfolgreich war
        queryClient.invalidateQueries(['posts']);
      }
    });

    // ...
  }
  ```

---

### Beispiel: Blog-Post nicht neuladen

* Ein einzelnes BlogPost kann im Cache verbleiben, da es sich in unserer App nicht √§ndert/nicht √§ndern kann
* Mit den `refetch`-Funktionen kann die automatische Aktualisierung ausgeschaltet werden
* ```typescript
  function PostPage() {
    // ...
    const result = useQuery({queryKey: ["blogPost", postId], queryFn: () => loadBlogPost(postId!)}, {
      refetchOnMount: false,
      refetchOnWindowFocus: false
    });  

    // ...
  }
  ```

---

### Refetch

* Das von `useQuery` zur√ºckgeliefert Objekt enth√§lt auch eine `refetch`-Funktion um einen Query
manuell neu auszuf√ºhren
* ```typescript
  function PostListPage() {
    const result = useQuery({queryKey: ['posts'], queryFn: readPosts}, {
      // nicht automatisch aktualisieren
      refetchOnMount: false, refetchOnWindowFocus: false
    })

    // ... result.status === loading, status === error ... 

    return <div>
      <button onClick={refetch}>Reload Posts</button>
      <PostList posts={data} />
    </div>
  }
  ```


---
<!-- 

## √úbung: Die Blog-Anwendung mit TanStack Query

* _Vervollst√§ndige den Query zum Laden und Speichern mit TanStack Query_
* Backend starten
* Das Backend ist bereits fertig. Du kannst es starten mit:
* ```
cd blog-example/backend-rest
npm install (nur, falls noch nicht gemacht)
npm start
```
* Danach sollte unter [http://localhost:7000/posts](http://localhost:7000/posts) 
die Liste mit den (JSON-)Posts zur√ºckkommen
* Schritte:
* Kopiere `index.js` und `App.js` aus `material/4-remote-query` in dein `src`-Verzeichnis
* In `App.js` findest Du TODOs mit weiteren Hinweisen
* M√∂gliche L√∂sung findest Du in `steps/4-remote-query`
* Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è

--- -->

                  </textarea
          >
        </section>
        <!-- #################################### AUSBLICK  ########################################## -->

        <section data-markdown>
          <textarea data-template>
# Ausblick
          </textarea>
        </section>
        <!-- ##################################### REDUX ############################################## -->
        <section data-markdown>
          <textarea data-template>
    <!-- .slide: id="t-state" -->
    ## Globales Statemanagement mit Redux   
    
    * Themen
      * [Redux Grundlagen](#/t-redux)
      * [Redux Toolkit](#/t-rtk)
      * Asynchrone Actions mit [Redux Thunk](#/t-redux-thunk)
      * Data Fetching mit [Redux Toolkit Query](#/t-rtk-query)
      
  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Globaler Zustand</h3>
          <ul>
            <li>
              Man kann Zustand in <b>lokalen Zustand</b> und <b>globalen Zustand</b> einteilen
            </li>
            <li>
              <b>Lokaler Zustand</b> ist Zustand, der "mehr oder weniger" einer Komponente zur
              Verf√ºgung steht
            </li>
            <li>
              <b>Globaler Zustand</b> hingegen ist f√ºr die ganze Anwendung oder gro√üe Teile davon
              zust√§ndig
            </li>
            <li>Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition</li>
            <li>Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme</li>
          </ul>
        </section>

        <section id="t-redux">
          <h2>External Statemanagement mit Redux</h2>
          <h3>Demo: Redux & Redux Devtools</h3>
          <p>üëâ steps/15-exkurs-redux-toolkit</p>
        </section>

        <section data-markdown>
          <textarea data-template>



# Redux Plain mit Thunk Action Plain
  -> Editor
  -> PostList (keine Posts laden)
  
# Thunk Actions Plain
  -> Eine Thunk Action f√ºr PostList            


# Thunk Action mit createThunkAction
# Redux Toolkit Query            
          </textarea>
        </section>

        <section>
          <h3>Wiederholung</h3>
          <h2>Render Cycle in Pure React</h2>
          <img src="slides/images/redux-01-react-cycle-no-redux.png" style="height: 650px" />
        </section>

        <section>
          <h2>Redux extrahiert die Verantwortlichkeiten</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px" />
        </section>

        <section data-markdown>
          <textarea data-template>
## Redux im Code
* <!-- .element: class="demo" -->Schritt-f√ºr-Schritt: "Plain Redux" 
* <!-- .element: class="demo" -->Schritt-f√ºr-Schritt: "Redux Toolkit"
* <!-- .element: class="demo" --> (jeweils workspace-redux)
---
## Strukturierter √úberblick √ºber alle Redux Teile            
* Wir sehen uns zun√§chst die Grundlagen des "klassichen" Redux an
* Im Projekt setzt man aber Redux Toolkit ein. Das sehen wir uns danach an.
* Hier geht's jetzt erstmal "nur" darum, die Konzepte und Ideen von Redux zu verstehen.
---
### Redux: Konzepte

* **Store**: eine Art "Datenbank", die au√üerhalb der Komponentenhierachie liegt. Hier ist der globale Zustand untergebracht. Komponenten werden √ºber Ver√§nderungen informiert und k√∂nnen sich re-rendern
* **Actions**: Einfache JavaScript-Objekte, die beschreiben was in einer Anwendung passiert. Bestehen aus einem Type und einem fachlichen Payload.
* **Reducer**-Funktionen: Funktionen, in denen die Logik zur Verarbeitung des Zustands untergebracht ist. Sie erhalten eine Action und einen (alten) Zustand, verarbeiten die Action und liefern neuen Zustand zur√ºck.
* **Action Creator**: Factory-Funktionen, die Action Objekte erzeugen
  </textarea
          >
        </section>
        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
### Actions
* Pure JavaScript-Objekte, die eine Aktion in der Anwendung beschreiben
* Haben √ºblicherweise <b>type</b> und <b>payload</b>
* √úber das <b>type</b>-Property k√∂nnen sie identifiziert werden
* Der <b>Payload</b> enth√§lt Action-spezifische Daten
* Beispiel 1: Action-Objekt ohne Payload:
* ```typescript
  {
    type: "editor/clearDraft"; 
  }
  ```
* Beispiel 2: Action-Objekt mit Payload:
* ```typescript
  {
    type: "editor/setDraftTitle",
    newTitle: "..."  // Action-spezifischer Payload 
                     // (hier: der neue Blog-Titel)
  }
  ```
  

          </textarea>
        </section>
        <section>
          <h3>Reducer-Funktion #1</h3>
          <ul>
            <li>
              ...erh√§lt einen (vorherigen) Zustand und eine <em>Action</em> als Parameter √ºbergeben
            </li>
            <li>...verarbeitet die Action</li>
            <li>...liefert dann den neuen, aktualisierten Zustand zur√ºck</li>
            <li>...muss Seiteneffekt frei sein ("pure function")</li>
            <li>
              <pre><code class="javascript"  >
      reducer(old_state, action) => new_state
    </code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Die reducer-Funktion #2</h3>
          <ul>
            <li>
              Bekommt den vorherigen Zustand √ºbergeben und liefert neuen Zustand zur√ºck (oder den
              unver√§nderten alten)
            </li>
            <li>Der Zustand ist immutable, deswegen den bestehenden Zustand immer kopieren!</li>
            <li>
              <pre><code class="javascript">
      function editorReducer(state = initalDraftPost, action) {
        switch (action.type) {

          case "editor/clearDraft":
            return initalDraftPost;

          case "editor/setDraftBody":
            return { ...state, body: action.body };

          case "editor/setDraftTitle":
            return { ...state, title: action.title };
            
          default:
            return state;
        }
      }
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Redux: Store, Reducer und Actions</h3>
          <ul>
            <li>
              Der Store, d.h. der globale Zustand, wird ausschlie√ülich √ºber reducer-Funktionen
              verwaltet
            </li>
            <li>
              Jede reducer-Funktion verwaltet einen "Teil-Zustand" des globalen Zustandes. Die
              reducer k√∂nnen sich untereinander nicht sehen und nicht auf die anderen Teile des
              gloablen Zustands zugreifen. Ein Teil-Zustand wird auch als "Slice" bezeichnet (also
              ein Anwendungsteil)
            </li>
            <li>
              Wenn Du den Store mit einer Datenbank vergleichst, w√§re ein solcher Teilzustand so
              etwas wie eine Tabelle
            </li>
            <li>Die reducer werden beim Starten der Anwendung in Redux registriert</li>
            <li>
              Dadurch ist eine gute Entkopplung m√∂glich: ein Teil der Anwendung informiert √ºber eine
              Aktion ("User hat sich eingeloggt", "Theme wurde ver√§ndert") und alle interessierten
              Anwendungsteile k√∂nnen darauf reagieren
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux: Actions ausl√∂sen</h3>
          <ul>
            <li>Actions werden an <b>alle</b> Reducer-Funktionen verteilt</li>
            <li>
              Zum Ausl√∂sen einer Action gibt auch von Redux eine <code>dispatch</code>-Funktion, an
              die Du mit dem <code>useDispatch</code> Hook von Redux gelangst.
            </li>
            <li>
              <pre><code class="javascript">
      function PostEditor() {
        const dispatch = useDispatch();

        function handleTitleChange(newTitle) {
          dispatch({ type: "editor/setDraftTitle", title });
        }

        // ...

        &lt;input onChange={(e) => handleTitleChange(e.target.value) />
      }
    </code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Action Creator...</h3>
          <ul class="no-fragment">
            <li>...sind "Factory-Funktionen", die deine Action-Objekte erzeugen</li>
            <li>...sind optional, werden aber nahezu immer verwendet</li>
            <li>
              <pre><code class="javascript">
      function setDraftTitle(newTitle) {

        return { 
          type: "editor/setDraftTitle", 
          title: newTitle
        }

      }  
    </code></pre>
            </li>
            <li>Beim dispatchen wird dann der Action-Creator aufgerufen:</li>
            <li>
              <pre><code class="javascript">
      function PostEditor() {
        const dispatch = useDispatch();

        function handleTitleChange(newTitle) {
          dispatch(setDraftTitle(newTitle));
        }

        // ...
      }
    </code></pre>
            </li>
          </ul>

          <p>ü§î Wof√ºr k√∂nnten Action Creator sinnvoll sein?</p>
          <ul>
            <li>Stellen sicher, dass Objekte korrekt aussehen</li>
            <li>Verbergen interne Struktur der Actions vor der Anwendung</li>
            <li>K√∂nnen plausibilit√§tspr√ºfungen machen</li>
            <li>K√∂nnen Daten konvertieren, bevor sie in die Action √ºbernommen werden</li>
          </ul>
        </section>

        <section>
          <h3>Redux: Zugriff auf den globalen Zustand</h3>
          <ul>
            <li>
              Komponenten k√∂nnen aus dem globalen Zustand (Store) die Daten ausw√§hlen, die sie
              ben√∂tigen
            </li>
            <li>
              Die Hierarchie-Ebene spielt dabei keine Rolle, weil der Zustand au√üerhalb, "neben" den
              UI Komponenten liegt
            </li>
            <li>
              Nur wenn sich die ausgew√§hlten Daten in einer Kompoente √§ndern, wird die Komponente
              neu gerendert
            </li>
            <li>
              Der <code>useSelector</code> Hook von Redux erwartet eine Callback-Funktion, die
              aufgerufen wird, sobald sich <em>irgendetwas</em> im Store ver√§ndert hat
            </li>
            <li>Dieser Callback-Funktion wird der komplette Store √ºbergeben.</li>
            <li>
              Aus dem Store w√§hlt die Komponente die f√ºr sie relevanten Daten aus und liefert sie
              zur√ºck
            </li>
            <li>
              Nur wenn sich diese zur√ºckgelieferten Daten ver√§ndert haben, wird die Komponente neu
              gerendert
            </li>
            <li>
              <pre><code class="javascript">
      function PostEditor() {
        const draftTitle = useSelector(state => state.editor.draftTitle);

        //  ...
      }
    </code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useSelector - Details</h3>
          <ul>
            <li>
              Um festzustellen, ob sich die ausgew√§hlten Daten ver√§ndert haben, pr√ºft Redux auf
              <b>Identit√§t</b>!
            </li>
            <li>
              Es wird deshalb empfohlen, nur einzelne Werte (keine Objekte) aus dem Store
              auszuw√§hlen - stattdessen mehrere useSelector-Aufrufe machen. Bei Objekten musst Du
              eventuell die
              <a href="https://react-redux.js.org/api/hooks#equality-comparisons-and-updates"
                >shallowEqual-Funktion</a
              >
              √ºbergeben.
            </li>
            <li>
              Du kannst nat√ºrlich auch "abgeleitete" Daten zur√ºckliefern, Redux vergleicht nur den
              von dir zur√ºckgelieferten Wert, unabh√§ngig davon, ob er "direkt" aus dem Store kommt
              oder basierend auf dem Store "berechnet" wurde
            </li>
            <li>
              <pre><code class="javascript">
      function AppHeader() {
        // "abgeleiteter" Zustand
        const hasDraftPost = useSelector(
          state => state.editor.draftTitle !== "" || state.editor.draftBody !== ""
        );
      }

      // √ºbergebene Selector-Callback-Funktion 
      //    wird bei JEDER √Ñnderung des Stores ausgef√ºhrt
      // AppHeader wird nur neu gerendert, 
      //    wenn sich deren R√úCKGABEWERT √§ndert
    </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Der Store</h3>
          <p>Ein <em>einziger</em> Store h√§lt den <em>kompletten</em> Zustand</p>
          <p>
            Der Store wird allen Componenten √ºber die Wrapper-Komponente <em>Provider</em>
            zur Verf√ºgung gestellt
          </p>
          <pre><code class="javascript">
import { store } from "./store";
import { Provider } from "react-redux";

const root = createRoot(document.getElementById("root"));

root.render(
  &lt;Provider store={store}>
      &lt;App />
  &lt;/Provider>
);
            
</code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux Dev Tools</h3>

          <p>
            Mit den Redux Dev Tools kannst Du unter anderem im Browser den Store einsehen und die
            ausgel√∂sten Actions nachverfolgen
          </p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=de"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a href="https://addons.mozilla.org/de/firefox/addon/reduxdevtools/" target="_blank"
                >Firefox</a
              >
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-rtk" -->
### Redux Toolkit
* _"The official, opinionated, batteries-included toolset for efficient Redux
development"_
* Das ist mittlerweile das "offizielle" Redux
  * [https://redux-toolkit.js](https://redux-toolkit.js)
  * Mit vorkonfiguriertem Setup (inklusive
  [immer](https://github.com/immerjs/immer) f√ºr Reducer-Funktionen)
  * Vereinfacht erheblich das Arbeiten mit Reducer, generiert z.B. Action Creator zur
  Laufzeit
  * Vereinfacht typische Anwendungsf√§lle wie API Calls mit dem integrierten [RTK Query](https://redux-toolkit.js.org/rtk-query/overview)
  
---
### createSlice    
* Ein "Slice" repr√§sentiert einen fachnlichen "Schnitt" in Eurer Anwendung
* Ein Slice wird mit der Funktion <code>createSlice</code> erzeugt
* Diese Funktion erwartet ein Konfigurationsobjekt
  * legt den initialen Zustand fest
  * definiert die Reducer-Funktionen
    * F√ºr jede reducer-Funktion werden automatisch Action-Creator erzeugt
* ```typescript
  const editorSlice = createSlice({
    name: "editor",
    initalState: { title: "", body: "" },
    reducers: {
      updateTitle(state, action) {
        state.title = action.payload.newTitle
      }
    }
  })
  ```
* ```typescript
  const dispatch = useDispatch();

  dispatch(editorSlice.actions.updateTitle({
    newTitle: "Hello RTK"
  }))
  ```
---
### TypeScript-Typen #1

* Der Typ des States eines Slices wird automatisch vom RTK aus dem `initialState` abgeleitet
  * Nat√ºrlich k√∂nnt ihr daf√ºr auch explizit einen Typen definieren
  * ```typescript
    type EditorSliceState = { title: string, body: string }

    const editorSlice = createSlice({
      name: "editor",
      initalState: { title: "", body: "" } as EditorSliceState,
      // ...
    })
    ```
  * oder:
  * ```typescript
    type EditorSliceState = { title: string, body: string }

    const initialState: EditorSliceState = { title: "", body: "" };

    const editorSlice = createSlice({
      name: "editor",
      initalState,
      // ...
    })
    ```
  
---
### Reducer-Funktionen

* Das `reducers`-Objekt enth√§lt die Reducer-Funktionen f√ºr einen Slice
* Der Key bzw. der Funktionsname entspricht dem Reducer-Namen
* Die Funktion kann zwei Parameter bekommen:
  1. Den aktuellen State des Slices
    * **Achtung!**: Der State hier ist nur der State des jeweiligen Slices, nicht der Gesamt-State aller Slices!
    * Ein Slice arbeitet immer nur auf "seinem" State und hat auch keinen Zugriff auf State anderer Slices.
  2. Das Action-Objekt (optional. Wenn eine Action keinen Payload hat, k√∂nnt ihr den Parameter weglassen)
* Der √ºbergebene `state` ist ein [immer](https://immerjs.github.io/immer/) `Draft`-Objekt, das ihr direkt ver√§ndern d√ºrft:
  * ```typescript
    reducers: {
      addBlogPost(state, action) {
        state.posts.push({...}); // push ist erlaubt hier
        state.posts[0].title = action.payload.newTitle; // direkte Modifikation erlaubt
      }
    }
  ```
* Alternativ k√∂nnt ihr auch ein komplett neues Objekt zur√ºckgeben, dann wird der bestehende
  State durch das neue Objekt komplett ersetzt:
* ```typescript
  reducers: {
    clearEditor(state) {
      return { title: "", body: ""}; 
    }
  }
  ```

---
### Action Creator  
* F√ºr jede Reducer-Funktion generiert das RTK automatisch eine Action-Creator-Funktion
* Die generierte Action-Create-Funktion erzeugt den _Payload_, der Action, die an die `reducer`-Funktion
  als 2. Parameter √ºbergeben wird
* Die generierten Funktionen liegen im erzeugten Slice-Objekt unter `slice.actions`:
* ```typescript
  const editorSlice = createSlice({ reducers: { updateTitle(...) { ... } });

  const { updateTitle } = createSlice.actions;
  // updateTitle kann 'dispatched' werden
  ```
---
### Actions im RTK

* Eine Action in RTK ist immer ein Objekt im folgenden Format:
  * ```typescript
    type Action<P> = {
      type: string
      payload: P
    }
    ```
* Der `type` setzt sich aus dem `name` des Slices und dem Namen der Reducer-Funktion zusammen
  * `editor/updateTitle`
---
### Action Payload  
* Der **Payload** ergibt sich aus dem zweiten Parameter der Reducer-Funktion
* Damit der Typ korrekt bestimmt werden kann, m√ºsst ihr einen TypeScript-Typen f√ºr den **Payload** definieren.
  Diesen gebt ihr dann - "verpackt" im `PayloadAction`-Typen - f√ºr den Action-Parameter in Eurem Reducer an:
* ```typescript
  type UpdateTitle = { newTitle: string };
  ```
* ```typescript
  const editorSlice = createSlice({
    reducers: {
      updateTitle(state, action: PayloadAction<UpdateTitle>) {
        state.title = action.payload.newTitle
      }
    }
  })
  ```
* Auf diese Weise ist sowohl `action`-Parameter korrekt getypt als auch der Action-Creator:
* ```typescript
  // OK
  dispatch(editorSlice.actions.updateTitle({
    newTitle: "Hello" 
  }));

  // ERR newTitle darf nicht null sein
  dispatch(editorSlice.actions.updateTitle({
    newTitle: null 
  }));

  // ERR newTitel statt newTitel
  dispatch(editorSlice.actions.updateTitle({
    newTitel: "Moin"
  }));

  ```
---
### Extra Reducer

- Actions in Redux k√∂nnen prinzipiell von _allen_ Reducern verarbeitet werden
- Bislang haben wir nur gesehen, wie die Actions direkt von dem Reducer verarbeitet werden,
  der sie "definiert" (als 2. Parameter)
- F√ºr alle weiteren Actions k√∂nnen `extraReducers` an einem Slice definiert werden
- Ein "extra reducer" ist eine gew√∂hnliche Reducer-Funktion, d.h. sie bekommt den State des Slices und eine Action √ºbergeben
- Welche Action sie √ºbergeben bekommt, kann sie an Hand verschiedener Kriterien ausw√§hlen
- Das `extraReducers`-Feld an `createSlice` ist eine Funktion, die ein `builder`-Objekt √ºbergeben bekommt
- Mit diesem `builder`-Objekt kann sie ihre Reducer definieren
  * ```typescript
    const editorSlice = createSlice({
      // ...
      extraReducers: builder => {
        builder.addCase(logoutAction, (state, action) => {
          state.title = "";
          state.body = "";
        }
      }
    })
    ```
---
### Extra Reducer
- √úber das `builder`-Objekt k√∂nnen Reducer hinzugef√ºgt werden
- Dabei wird jeweils ausgew√§hlt f√ºr welche Action(s) ein Reducer aufgerufen werden soll
- Dazu gibt es zwei Methoden (`addCase` und `addMatcher`)
- Der erste Parameter w√§hlt aus, ob eine Action verarbeitet werden soll oder nicht
- Der zweite Parameter ist die reducer-Funktion (identisch mit den Reducern aus `reducers`)
---
### Extra Reducer: addCase
- Mit `addCase` kann eine Action aus einem anderen Slice angegeben werden. Wenn diese Action ausgel√∂st wird,
  wird die Reducer-Funktion aufgerufen:
  * ```typescript
    const userSlice = createSlice({ reducers: { logout(...) { ... }}});
    export const { logout } = userSlice.actions;

    const editorSlice = createSlice({
      // ...
      extraReducers: builder => {
        builder.addCase(logout, (state, action) => {
          // action ist 'Logout'-Action aus 'userSlice'
          state.title = "";
          state.body = "";
        }
      }
    })
    ```
---
### Extra Reducer: addMatcher
- Mit `addMatcher` wird eine CallbackFunktion angegeben
- Diese Funktion wird f√ºr jede Action aufgerufen und liefert `true` bzw. `false` zur√ºck, um zu entscheiden,
  ob die Reducer-Funktion aufgerufen werden soll
- Die Funktion ist au√üerdem eine TypeScript [Type Predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)-Funktion. Dadurch ist die Reducer-Funktion dann
  automatisch korrekt getypt.
  * ```typescript

    type SavePostAction = { type: "savePost", payload: { title: string, body: string } };

    function isSavePostAction(a: AnyAction): a is SavePostAction {
      return a.type === "savePost";
    }

    const editorSlice = createSlice({
      // ...
      extraReducers: builder => {
        builder.addMatcher(isSavePostAction, (state, action) => {
          // Action ist eine SavePostAction
          // ...
        }
      }
    })
    ```
  
---
### Verwenden des Slices

* Das erzeugte Slice-Objekt hat zwei Properties:
  * `reducer`: Dieses Objekt wird in der Store-Konfiguration angegeben
  * `actions`: enth√§lt die automatisch generierten Action-Creator-Funktionen
* Beide Teile k√∂nnt ihr exportieren, in der Regel wird `reducer` per `default` exportiert:
* ```typescript
  const editorSlice = createSlice({ ... });

  export default editorSlice.reducer;
  export const { updateTitle, updateBody } = editorSlice.actions;
  ```
---
### Konfiguration
* Der globale Store wird mit der `configureStore`-Funktion erzeugt
* Diesem √ºbergebt ihr alle `reducer`, die ihr mit `createSlice` (oder auf "klassichem" Weg) erzeugt habt:
* ```typescript
  import { configureStore } from "@reduxjs/toolkit";
  import editor from "./editor-slice";
  import posts from "./posts-slice";

  export const store = configureStore({
    reducer: {
      editor,
      posts
    }
  });
  ```
* **Achtung!** Der Name des Keys im `reducer`-Objekt bestimmt den "Pfad" im globalen State:
  * Im Beispiel oben besteht der globale State aus zwei Root-Pfaden (`editor` und `posts`)
  * Zugriff zum Beispiel: `useSelector( state => state.editor.title )`
* In folgenden Beispiel best√ºnde der State aus den Pfaden `editorSlice` und `posts`:
* ```typescript
export const store = configureStore({
  reducer: {
    editorSlice: editor,
    posts
  }
});
  ```
---
### Den Store bekannt machen

* Der Store ist ein Singleton, der beim Starten der Anwendung initial erzeugt wird
* Das erzeugte `store`-Objekt m√ºsst ihr √ºber die `Provider`-Komponente in Eure React-Anwendung bringen:
* ```typescript
  import React from "react";
  import { createRoot } from "react-dom/client";

  import { configureStore } from "@reduxjs/toolkit";
  import { Provider } from "react-redux";

  import App from "./App";

  const store = configureStore({ .... });

  createRoot(document.getElementById("root"))
    .render(
      <Provider store={store}>
          <App />
      </Provider>
  );
  ```
---
### TypeScript-Typen f√ºr Zugriff auf den Store

* Aus dem erzeugten Store k√∂nnt ihr einen TypeScript-Typen f√ºr den globalen State erzeugen:
* ```typescript
  export const store = configureStore({ ... });

  export type RootState = ReturnType<typeof store.getState>;
  ```
* Den `RootState` k√∂nnt ihr jetzt z.B. f√ºr typsicheren Zugriff auf den State in `useSelector` verwenden:
* ```typescript
  const title = useSelector<RootState>(state => state.editor.newTitle); // OK
  const title = useSelector<RootState>(state => state.editor.newTitel); // ERR
  ```
* In der Regel erzeugt man sich eine `useAppSelector`-Funktion, die direkt den `RootState` Eurer Anwendung kennt:
* ```typescript
  // redux-hooks.ts

  import { TypedUseSelectorHook, useSelector } from "react-redux";
  import { AppDispatch, RootState } from "./store";

  export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
  ```
* Typsichere Verwendung:
* ```typescript
  import {useAppSelector} from "../redux-hooks"

  function Editor() {
    const title = useAppSelector(state => state.editor.title); // Typsicher!

    // ...
  }
  ```

---
### useAppDispatch

* Auch f√ºr die `useDispatch`-Funktion k√∂nnt ihr Euch einen TS-Typen und einen Hook erzeugen
* Die getypte Variante kennt dann auch alle Action-Typen, die per installierter Middleware (z.B. Thunk) erlaubt sind
* ```typescript
  type AppDispatch = typeof store.dispatch;

  export const useAppDispatch: () => AppDispatch = useDispatch;
  ```
* Anstatt der `useDispatch`-Funktion verwendet ihr in Eurer Anwendung dann einfach `useAppDispatch`

---
### √úbung: Redux Toolkit

* _Verwende f√ºr die Inhalte der PostEditor-Komponente einen RTK Slice_
* Daf√ºr arbeiten wir im Workspace `blog-example/workspace-redux`. 
  * Bitte bestehenden `npm start`-Prozess beenden und in `workspace-redux` erneut ausf√ºhren
* Todos findest Du in der Datei `redux/editor-slice.ts`
* Der Store ist schon fertig konfiguriert, Du musst "nur" den Slice bauen und den `PostEditor` anpassen
* M√∂gliche L√∂sung: `steps/70-redux/72-rtk-create-slice`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã

---
<!-- .slide: id="t-redux-thunk" -->
### Redux
## Komplexe Actions

* Problem 1: **Asynchroner Code** (z.B. beim Laden von Daten), Arbeiten mit Promises
* Wo unterbringen?
  * **Reducer** m√ºssen Seiteneffekt-frei sein!
  * **Actions** sind reine JavaScript-Objekte ohne Methoden/Logik!
* Problem 2: Weiteres Problem: fachliche Abl√§ufe oft komplex(er) als nur eine Action.
  * Zum Beispiel Lifecycle eines Server-Requests: Typisch: Request Start, Request l√§uft, Request erfolgreich/Request fehlgeschlagen
* In solchen F√§llen werden √ºblicherweise [Thunk Actions](https://github.com/reduxjs/redux-thunk) verwendet
  * Alternativen: Redux Saga oder Redux Observable
---
### Thunk Actions 

* <!-- .element: class="demo" --> Laden der Posts mit normaler Thunk Action
* <!-- .element: class="demo" --> Laden der Posts mit createAsyncThunk
                        
          </textarea>
        </section>

        <section>
          <h3>Hintergrund: Redux Middleware</h3>
          <ul>
            <li>
              Eine Middleware-Funktion bekommt alle dispatchen Actions √ºbergeben, bevor sie in den
              Store gelangen
            </li>
            <li>
              Die Middleware kann die Action annehmen, ver√§ndern, ablehnen und/oder weiterleiten
            </li>
            <li>Typische Anwendungsf√§lle: Logging, asynchrone Verarbeitung</li>
            <li>Die Middleware-Funktionen werden bei der Konfiguration des Stores angegeben</li>
            <li>In der Regel schreibst Du keine Middlewares selbst, sondern verwendest fertige</li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Thunk Action

- Als `Thunk Action` wird eine Action bezeichnet, die selbst eine Funktion (!) ist
- Ein Action-Creator kann eine Thunk Action, also eine Funktion zur√ºckliefern.
- Diese Funktion wird von der Thunk Middleware aufgerufen
- Der Thunk-Funktion werden zwei Parameter √ºbergeben:
  - Die `dispatch`-Funktion. Damit kann sie beliebig viele Actions ausl√∂sen
  - Die `getState`-Funktion, mit der sie (lesenden) Zugriff auf den State hat
- Die Thunk-Funktion darf asynchron sein!  
          </textarea>
        </section>

        <section>
          <h3>Asynchrone Actions mit Thunk Middleware</h3>
          <p>
            Schritt 1: <b>Dispatchen von Actions</b>: Komponente bleibt unver√§ndert, dispatched
            weiterhin eine Action, die wie eine "normale" Redux Action aussieht
          </p>
          <div>
            <pre><code>
      import { loadPosts } from "./posts-slice";

      function App() {
        React.useEffect( 
          () => dispatch(loadPosts()),
          []
        );

        return ...;
    }
  </code></pre>
          </div>
        </section>

        <section>
          <h3>Asynchrone Actions mit Thunk Middleware</h3>
          <p>
            Schritt 2: <b>Action Creator</b>: Hier k√∂nnen jetzt weitere Actions, auch asynchron,
            dispatched werden
          </p>
          <pre><code>
            // 'loadPosts' ist ein Action-Creator, der eine Thunk-Action zur√ºckliefert!
            export function loadPostsWithCache() {
              //              v--- Thunk-Action!
              return (dispatch, getState) => {
                dispatch(loadPostRequestStarted()); 
                try {
                  posts = await loadPostsWithFetch();
                  dispatch(loadPostRequestFinished(posts));
                } catch (err) {
                  dispatch(loadPostRequestFailed(err));
                }
              }
            }  
    </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Asynchrone Actions

* In einer Thunk-Action k√∂nnt ihr auf den State _lesend_ zugreifen (`getState`-Parameter)
* Ihr k√∂nnt den State aber _nicht ver√§ndern_!
* In den Thunk-Actions k√∂nnt ihr beliebig viele weitere (Thunk-) Actions dispatchen
* Ihr k√∂nnt also z.B. "normale" Actions dispatchen, dei dann von "normalen" Reducern verarbeitet werden
  * Im gezeigten Beispiel sind dass die "Lifecycle-Actions" (`loadPostRequestStarted` etc.)
  </textarea
          >
        </section>

        <section>
          <h2>Redux Thunk</h2>
          <p>Thunk Actions k√∂nnen nicht nur f√ºr asynchone Anwendungsf√§lle verwendet werden</p>
          <ul>
            <li>
              F√ºr Anwendungsf√§lle in den allgemein mehr als eine Action dispatched werden soll
            </li>
            <li>
              Es ist darin erlaubt, beliebige Seiteneffkte auszuf√ºhren, z.B. eine uuid generieren
              oder auf die Uhrzeit zuzugreifen
            </li>
            <li>
              Im Gegensatz zum Reducer hat ein Action-Creator Zugriff auf den gesamten State und
              kann z.B. eine Cache-Funktionali√§t implementieren
            </li>
            <li>
              <pre><code class="typescript line-numbers"  >
      export function loadPostsWithCache() {

        return (dispatch, getState) => {

          if (getState().posts.posts) {
            // Posts sind schon geladen => nicht erneut laden
            return;
          }


          dispatch(postsLoading());

          // ...wie gesehen: Posts laden etc.
        };
      }    </code></pre>
            </li>
          </ul>
          <!-- <p>
        <strong
          >Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone
          Operationen ausf√ºhren d√ºrfen</strong
        >
      </p> -->
        </section>
        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
### Redux Thunk in Redux Toolkit
* Die Redux Thunk Middleware ist in Redux Toolkit integriert
* (Asynchrone) Thunk Action Creator k√∂nnen aber nicht im `reducers`-Objekt eines Slices definiert werden
* Ihr m√ºsst sie als "normale" Funktion au√üerhalb von <code>createSlice</code> hinschreiben (wie im Beispiel gesehen)
* Aber nat√ºrlich k√∂nnt ihr in dem Thunk Action Creator die Actions aus Euren Slices dispatchen:
* ```typescript
    type LoadPostRequestFinished = { loadedPosts: BlogPost[] };
    
    const postsSlice = createSlice({
      reducers: {
        loadPostRequestStarted(state) {
          state.loading = true;
        }
        loadPostRequestFinished(state, action: PayloadAction<LoadPostRequestFinished>) {
          state.loading = false;
          state.posts = action.payload.loadedPosts;
        }
      }
    });

    // Thunk Action Creator
    export function loadPosts() { 

      return async (dispatch, getState) => {
        dispatch(postsSlice.action.loadPostRequestStarted());
        const posts = ...;
        dispatch(postsSlice.action.loadPostRequestFinished({loadedPosts: posts }));
      }
    }
  ```
---
### createAsyncThunk: Automatische Lifecycle-Actions
* In der asynchronen Verarbeitung soll h√§ufig eine Art Lifecycle ausgedr√ºckt werden (z.B. "loading", "finished", "failed")
* Mit [createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk) kannst Du vereinfacht Thunk-Actions schreiben, die solche Actions
automatisch dispatchen
* Du musst dann nur noch die fachliche Logik implementieren (z.B. das Laden der Daten)
* Deine Thunk Action liefert ein Promise zur√ºck.
* Vom Zustand des Promises macht RTK dann abh√§ngig, welche Lifecycle-Action dispatched wird:
  * `pending` (Promise wird gerade verarbeitet, z.B.: Server-Call l√§uft)
  * `fulfilled` (Promise wurde erfolgreich aufgel√∂st/resolved, Daten sind geladen worden)
  * `rejected` (Beim Verarbeiten des Promises ist ein Fehler aufgetreten)
---
### createAsyncThunk: API

* Die `createAsyncThunk`-Funktion erwartet zwei Parameter:
  * Den Action `type` als String (z.B. `"posts/load"`)
  * Eine Callback-Funktion (`payloadCreator`), in der die Action-Logik (z.B. das Laden von Daten) implementiert ist
* ```typescript
  export const loadPosts = createAsyncThunk("posts/load", async () => {
    const response = await fetch("http://localhost:7000/posts?slow");
    const json = (await response.json()) as BlogPost[];
    return json;
  });
  ```
*  Diese `loadPosts`-Action kann wie gewohnt dispatched werden:
* ```typescript
  dispatch(loadPosts());
  ```
* Es werden dann drei Actions dispatched:
  * `posts/load/pending` und dann:
  * `posts/load/fulfilled` oder `posts/load/rejected`
* Die `posts/load/fulfilled`-Action enth√§lt au√üerdem den ermittelten Wert des Promises

---
### createAsyncThunk: Verarbeiten der Actions

* Der R√ºckgabe-Wert der Thunk-Action wird als `payload` an die `fulfilled`-Action geh√§ngt
* Wenn die Thunk-Action fehlschl√§gt, wird der Fehler der Payload als `error` √ºbergeben
* Die ausgel√∂sten "Lifecycle"-Actions kannst Du mit einem `extraReducer` am Slice verarbeiten
  * Damit kannst du zum Beispiel den aktuellen Lifecycle in den State h√§ngen
  * Oder die geladenen Daten bzw. den aufgetretenen Fehler
* Um die Actions auszuw√§hlen kannst du die `addCase`-Funktion von `extraReducers` verwenden
  * F√ºr die drei Lifecycle Status gibt es jeweils ein Attribute an der Action, das Du √ºbergeben kannst:
* ```typescript
  const loadPosts = createAsyncThunk(...);

  const postsSlice = createSlice({
    initialState: { loading: false, posts: [] },

    extraReducers: builder => {

      builder.addCase(loadPosts.pending, (state) => { 
        state.loading = true;
      })

      builder.addCase(loadPosts.fulfilled, (state, action) => { 
        state.loading = false;
        state.posts = action.payload;
      });

      builder.addCase(loadPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error;
      });
    }
  })
  ```
  

---
###  createAsyncThunk: API Details

* Die [`payloadCreator`-Callback-Funktion](https://redux-toolkit.js.org/api/createAsyncThunk#payloadcreator) von `createAsyncThunk` kann zwei Parameter annehmen:
  1. Parameter: Objekt, mit dem Du Argumente beim dispatchen √ºbergeben kannst (z.B. Id der zu lesenden Daten)
  2. `thunkAPI`-Objekt. Dieses Objekt enth√§lt unter anderem die `dispatch` und die `getState`-Funktion, um weitere Actions zu dispatchen oder auf den State lesend zuzugreifen. Mit `rejectWithValue` kann ein angepasster `error` zur√ºckgeliefert werden
* ```typescript
  export const loadPostById = createAsyncThunk("posts/loadById", async (postId: string, thunkApi) => {

    // Beispiel: Zugriff auf State
    const post = getState().posts.find(p => p.id === postId);
    if (post) {

      // Beispiel: Dispatch weiterer Actions
      thunkApi.dispatch(metricSlice.actions.cacheHit(postId));
      return post;
    }
    thunkApi.dispatch(metricSlice.actions.cacheMiss(postId));

    const response = await fetch(`http://localhost:7000/posts/${postId}`);

    if (response.status === 404) {

      // Beispiel: Eigenes Fehler-Objekt
      return thunkApi.rejectWithValue({errorMessage: "Blog Post not found"});
    }

    return response.json();
  });
  ```
* ```typescript
  dispatch(loadPostById(123))
  ```
  

---
### √úbung: Thunk Actions

* _Baue eine Thunk Action zum Laden der Post-Liste_

* Die Post-Liste wird in `PostListPage` mit `fetch` geladen. Das soll nun √ºber Redux passieren.
* Baue eine Thunk-Action in `redux/posts-slice-thunk.ts` zum Laden der Post
* Verwende die Action und den globalen State dann in `PostListPage` 
* TODOs siehe `posts-slice-thunk.ts`
* M√∂gliche L√∂sung: `steps/70-redux/74-rtk-thunk-actions`
  * Dateien: `posts-slice-thunk.ts` und  `PostListPage.tsx`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã


---
## Redux Toolkit Query
<!-- .slide: id="t-rtk-query" -->


---
### Redux Toolkit Query

* Die [RTK Query](https://redux-toolkit.js.org/rtk-query/overview) API ist der "offizielle" Weg des Redux Toolkits, um mit Daten vom Server zu arbeiten
  * Aus dem [Redux Styleguide](https://redux.js.org/style-guide/#use-rtk-query-for-data-fetching): _we recommend using RTK Query as the default approach for data fetching and caching in a Redux app. We recommend against writing data fetching logic by hand in almost all cases._
* RTK Query unterst√ºtzt Lesen und Schreiben von Daten (per HTTP), Caching und Lifecycle

---
### Redux Toolkit Query

* Mit `createApi` wird eine Art API-Slice definiert (√§hnlich wie `createSlice` aber f√ºr API-Endpunkte)
* Damit wird beschrieben, welche Endpunkte es gibt, und wie auf diese Zugegriffen werden soll
* Auch die Konfiguration des Caches erfolgt dar√ºber
* F√ºr alle konfigurierten Endpunkte werden React Hooks generiert, mit denen die Server-Requests ausgef√ºhrt werden k√∂nnen
* ```typescript
  import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

  export const postsApi = createApi({
    baseQuery: fetchBaseQuery({ baseUrl: "http://localhost:7000" }),

    endpoints: builder => ({
      loadPosts: builder.query<BlogPost[], void>({
        query: () => "/posts",
      }),

      getPost: builder.query<BlogPost, string>({
        query: postId => `/posts/${postId}`,
        }
      })
    })
  });

  export const { useLoadPostsQuery, useGetPostQuery } = postsApi;

  ```
---
### createApi

* An [createApi](https://redux-toolkit.js.org/rtk-query/api/createApi) wird eine Objekt mit der Konfiguration deiner Endpunkte √ºbergeben.
* Du musst darin zwei Dinge zwingend angeben:
  * Den `baseQuery`. Eine Funktion, die bestimmt, wie Server Requests technisch durchgef√ºhrt werden sollen. 
    * F√ºr viele F√§lle ist die [`fetchBaseQuery`](https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery)-Funktion aus dem RTK ausreichend. Dieser √ºbergibst Du eine `baseUrl` und die Requests werden dann mit der `fetch` API durchgef√ºhrt.
  * `endpoints` Eine Callback-Funktion, mit der Du deine Endpunkt-Konfiguration festlegen kannst.

---
### Endpunkte

* Die Endpunkte deiner API werden mit der `endpoints`-Callback-Funktion festgelegt.
* Diese Funktion erh√§lt ein `builder`-Objekt, mit Du mit der `query`- und `mutation`-Funktion Endpunkte definieren kannst
  * Die `query`-Endpunkte sind zum lesen von Daten
  * Die `mutation`-Endpunkte sind f√ºr alle Arten von ver√§ndernden Server-Zugriffen (z.B. HTTP POST oder HTTP PUT)
* Die `endpoints`-Funktion liefert ein Objekt zur√ºck, in dem die **Keys** (fachliche) Namen von Endpunkten sind. 
  * Die Namen bestimmen unter anderem die generierten Hook-Funktion zum Aufrufen der Endpunkte
* Der **Wert** ist jeweils ein konfigurierter Endpunkt, der mit dem `builder` erzeugt wurde. 
  * Das folgende Beispiel zeigt zwei Query-Endpunkte mit den Namen `loadPosts` bzw. `getPost`  
  * ```typescript
    export const postsApi = createApi({
      endpoints: builder => return {
        loadPosts: builder.query<BlogPost[], void>({
          query: () => "/posts"
        }),

        getPost: builder.query<BlogPost, string>({
          query: postId => `/posts/${postId}`
        })
      }
    });

    ```
---
### Queries an Endpunkten definieren
* Mit der `query`-Funktion kann ein Query-Endpunkt (in der Regel HTTP GET) definiert werden
* Die Funktion erwartet zwei _Typ-Argumente_ f√ºr TypeScript und einen _Parameter_:
  * Die _Typ-Argumente_ geben an:
    1. den R√ºckgabe-Typ der Daten, die √ºber den Endpunkt gelesen werden
    2. Ein Typ, der erforderliche Parameter f√ºr den Endpunkt beschreibt (oder `void` f√ºr keinen Parameter)
    * ```typescript
        // Liefert BlogPost[] zur√ºck, erwartet keine Parameter
        builder.query<BlogPost[], void>(...);

        // Lierfert BlogPost zur√ºck, erwartet einen Parameter vom Typ string
        builder.query<BlogPost, string>(...);
      ```
  * Mit dem _Parameter_ √ºbergibst du ein Objekt mit der eigentlichen Konfiguration f√ºr diesen Endpunkt
    * Du musst mindestens die `query`-Funktion angeben, die den Pfad/URL des Endpunktes zur√ºckliefert

---
### Endpunkt-Konfiguration

* Die `query`-Callback-Funktion nimmt einen Parameter entgegen
* Der Typ des Paramters wird `builder.query` √ºbergeben.
* Den Wert f√ºr diesen Parameter muss der Aufrufer beim Ausf√ºhren des Queries √ºbergeben
* _Ohne_ Parameter:
  * ```typescript
    builder.query<BlogPost[], void>({ query: () => `/api/posts ` });
    ```
* _Mit_ Parameter (Beispiel: Objekt mit `postId` und `commentId`):
  * ```typescript
    builder.query<Comment, {postId: string, commentId: string}>({
      query: ({postId, commentId}) => `/api/posts/${postId}/comments/${commentId`
    })
    ```
  * Bei diesem Endpunkt m√ºsste der Aufrufer ein Objekt mit `postId` und `commentId` √ºbergeben (dazu sp√§ter mehr)
* Es gibt noch eine ganze Reihe weiterer Konfigurationsm√∂glichkeiten f√ºr einen Endpunkt, siehe dazu die ausf√ºhrliche Dokumentation

---
### Ausf√ºhren von Queries

* F√ºr jeden Endpunkt werden [React Hooks](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#hooks-overview) generiert, die Du verwenden kannst, um den Endpunkt aufzurufen und die Daten abzufragen.
* Wir betrachten den [`useQuery`](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usequery) Hook
* Der Name ist `useEndpunktNameQuery` (also zum Beispiel `useGetPostQuery`)
* Die generierten Hooks stehen √ºber das API-Objekt (R√ºckgabe von `createApi`) zur Verf√ºgung:
* ```typescript
    export const postsApi = createApi({
      // ...
      endpoints: builder => ({

          loadPosts: builder.query<BlogPost[], void>({ ... })

          getPost: builder.query<BlogPost, string>({ ... })
        })
    });

    export const { useLoadPostsQuery, useGetPostQuery } = postsApi;
  ```
---
### Ausf√ºhren von Queries mit dem useQuery-Hook

* Den generierten Hook kannst Du in deiner Komponente verwenden
* Der Query wird unmittelbar beim Rendern der Komponente ausgef√ºhrt
* Sind die Daten f√ºr den Enpunkt (noch) im Cache vorhanden, werden die Daten stattdessen aus dem Cache zur√ºckgegeben
  * Auch wenn die geladenen Daten automatisch im "normalen" Redux Store abgelegt werden, greift man immer √ºber die Query-Hooks darauf zu
  (nie √ºber `useSelector`)
* Der Hook liefert ein `UseQueryResult`-Objekt zur√ºck, das Informationen √ºber den Query-Status und die Daten gibt.
* ```typescript
    function PostListPage() {
      const loadPostsQueryResult = useLoadPostsQuery();

      if (loadPostsQueryResult.isLoading) {
        return <LoadingIndicator>Server Request running. Please wait.</LoadingIndicator>;
      }

      if (loadPostsQueryResult.isError) {
        return <h1>Error while fetching data!</h1>;
      }

      return <PostList posts={loadPostsQueryResult.data} />;
    }
  ```

---
### Das Query-Ergebnis
* Der `useQuery`-Hook liefert unmittelbar ein Result-Objekt zur√ºck und f√ºhrt dann den Query aus
* √úber das Result-Objekt kannst Du Status des Requests und ggf. Daten bzw. Fehler abfragen
* Sobald sich der Status √§ndert (zum Beispiel Request ist zur√ºckgekehrt), wird die Komponente neu gerendert und der Hook gibt ein neues Result-Objekt zur√ºck
* Bestandteil des Result-Objektes:
  * `isUninitialized`: Request wurde noch nicht gestartet
  * `isLoading`: Request l√§uft gerade
  * `isError`: `true` wenn beim Lesen der Daten ein Fehler aufgetreten ist
  * `data`: Die geladenen Daten (nur wenn `isLoading` und `isError` `false` sind)
  * `error`: Beim Laden aufgetretener Fehler (nur wenn `isError` `true` ist)

---
### Parameter √ºbergeben
* Sofern Du in der Endpunkt-Konfiguration angegeben hast, dass der Endpunkt Parameter braucht, musst Du diese bei dem Hook angeben:
* Beispiel: ein Endpunkt mit zwei Parametern
  * ```typescript
    // 
    type GetCommentParams = { postId: string; commentId: string }

    export const postsApi = createApi({
      // ...
      endpoints: builder => ({

        getComment: builder.query<BlogPost, GetCommentParams>({
          query: params => `/posts/${params.postId}/comments/${params.commentId}`,
        })

      })
    });
    export const { useGetCommentQuery } = postsApi;
    ```
* Verwendung des Hooks:  
  * ```typescript
    function CommentPage() {
      const result = useGetCommentQuery({postId: "P1", commentId: "C1"});

      // result wie gesehen
    }  
    ```

---
### Ausf√ºhren des Queries unterbinden

* Der `useQuery` f√ºhrt den Query unmittelbar beim Rendern der Komponente aus
* Das will man aber nicht immer. 
* Um die Ausf√ºhrung zu unterbinden, kannst Du das `skipToken` oder die `skip`-Option verwenden. 
* Die `skip`-Option kann als zweiter Parameter √ºbergeben werden:
* ```typescript
  type PostPageProps = { postId: string, loadPost: boolean }

  function PostPage({ postId, loadPost }: PostPageProps) {

    const r = useGetPostQuery(postId, { skip: !loadPost });

  }
  ```
* Das `skipToken` ist ein Objekt, dass von RTK Query bereitsgestellt wird, und das (statt Query-Parameter) als erster Parameter √ºbergeben werden kann:
  * ```typescript
    import { skipToken } from '@reduxjs/toolkit/query/react'

    function PostListPage() {
      const r = useLoadPostsQuery(skipToken);
    }
    ```
---
### Das skipToken  
* Das `skipToken` musst Du verwenden, wenn dein Query _keine_ Parameter hat, _oder_ Du die erforderlichen Parameter nicht zur Verf√ºgung hast
* Beispiel: die folgende Komponente erwartet _optional_ eine postId als Property. F√ºr den Query ist die `postId` aber Pflicht.
* ```typescript
  type PostPageProps = { postId?: string | null}
      
  function PostPage({postId}: PostPageProps) {

    const r = useGetPostQuery(postId); // Compile-Error, weil postId undefined oder null sein kann

  }
  ```
* In diesem Fall kannst Du statt des Query-Parameters (`postId`) das `skipToken` √ºbergeben, wenn die `postId` nicht gesetzt ist:
* ```typescript
  import { skipToken } from '@reduxjs/toolkit/query/react'

  type PostPageProps = { postId?: string | null}
      
  function PostPage({postId}: PostPageProps) {

    const r = useGetPostQuery(postId ?? skipToken); // OK: Entwender postId oder - falls null - das skipToken

  }
  ```
---
### √úbung: Daten laden mit RTK Query

* _Verwende RTK Query um die Daten f√ºr die Post-Liste und die Einzeldarstellung zu laden_

* In der `PostListPage` und der `PostPage` werden die Posts vom Server geladen
* Baue in `redux/posts-slice-thunk.ts` zwei Endpunkte f√ºr `/posts` und `/posts/{postId}`
  * Dort findest Du weitere TODOs und Hinweise
  * Bitte nur √úbung 1 ("Queries") machen (_nicht_ die Mutation-√úbung)
* Ersetze in `PostListPage` und`PostPage` den Code dort durch die `useQuery`-Hooks der beiden Endpunkte
  * Wenn Du dann in der Anwendung navigierst, sollte ein BlogPost in der Einzeldarstellung nur _einmal_ geladen werden.
  * Rufst Du ihn nocheinmal auf (Home -> P1 -> Home -> P1), sollte er beim zweiten Mal aus dem Cache kommen.
* In dem Workspace sind f√ºr die Arbeit mit den Post-Daten zwei Slices konfiguriert (`post-slice-thunk` und `post-slice-api`)
  * Das ist hier nur zu Demo-Zwecken. In einer "richtigen" Anwendung w√ºrdest Du f√ºr _eine_ "Fachlichkeit" auch nur _einen_ Slice verwenden
* TODOs siehe `redux/posts-slice-api.ts`
* M√∂gliche L√∂sung: `steps/70-redux/76-rtk-query`
  * Dateien: `posts-slice-api.ts`, `PostListPage.tsx`, `PostPage.tsx`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã

---
### RTK Query: Mutations und Cache

---
### Mutations

* **Mutations** sind Operationen, die Daten auf dem Server _ver√§ndern_
  * Im Gegensatz dazu, sind Queries nur f√ºr _lesende_ Abfragen gedacht
* Mutations und Queries sind in RTK Query sehr √§hnlich, es gibt aber unterschiede:
  * Bei Mutations wird h√§ufig ein Request Payload √ºbergeben (bei Queries nicht m√∂glich)  
  * Es werden unterschiedliche HTTP Verben (POST/PUT/PATCH/DELETE) verwendet
  * Die Mutations werden nicht beim Rendern der Komponente ausgef√ºhrt, sondern z.B. nach einer Benutzerinteraktion
  * Da Mutations Daten ver√§ndern, kann es sein, dass danach Daten im lokalen Cache veraltet sind

---
### Defintion der Endpunkte
* Die Definition der Mutations erfolgt ebenfalls √ºber den `builder`, mit dem das `endpoint`-Objekt beschrieben wird.
* Die zugeh√∂rige Methode am `builder` hei√üt in diesem Fall `mutation` (nicht `query`)
* √úblicherweise ist das `query`-Objekt, das dem `builder` √ºbergeben wird, hier eine Funktion, die ein Objekt zur√ºckgibt
* Das Objekt beschreibt dann nicht nur den Pfad, sondern auch den Payload und HTTP Header.
* ```typescript
    export const postsApi = createApi({
      // ...
      endpoints: builder => ({

        // Query (GET)-Endpunkt:
        loadPosts: builder.query<BlogPost[], void>({
          query: () => "/posts?slow",
        }),

        // Mutation (POST)-Endpunkt:
        savePost: builder.mutation<BlogPost, NewBlogPost>({
          query: newPost => ({
            url: `posts`,
            method: "POST",
            body: newPost
          })
        })
      })
    });

    export const { useLoadPostsQuery, useSavePostMutation } = postsApi;
  
  ```
---
### Mutations ausf√ºhren

* Auch f√ºr jede Mutation wird ein React Hook generiert.
* Dieser [`useMutation`-Hook](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usemutation) hat das Namenspattern `useEndpunktNameMutation`
* Im Gegensatz zu `useQuery` wird die Mutation nicht beim Rendern ausgef√ºhrt.
* Stattdessen liefert der Hook nicht nur das Result-Objekt zur√ºck, sondern auch eine `trigger`-Funktion zum Ausf√ºhren der Mutation
* √Ñhnlich wie bei Reacts `useState` ist der R√ºckgabe-Typ ein Tuple mit der `trigger`-Funktion und dem Result-Objekt:
* ```typescript
  const [savePost, savePostResult] = useSavePostMutation();

  function onSavePostClick(newPost: NewBlogPost) {
    savePost(newPost);
  }

  if (savePost.isLoading) {
    return <div>Saving new post...</div>
  }

  if (savePost.isError) {
    return <div>Saving Post failed...</div>
  }

  if (savePost.isSuccess) {
    return <div>Saving Post succeeded!</div>
  }

  return ...;

  ```
---
### Der RTK Query Cache

* Alle gelesenen Daten werden im Store abgelegt und dort gechached
* Wie lange sie darin liegen, h√§ngt unter anderem davon ab, ob noch eine Komponente auf die Daten zugreift
  * Grunds√§tzlich ist das pro Endpunkt einstellbar
* In einer Mutation kannst Du auch explizit festlegen, welche Daten von dieser ge√§ndert werden
  * Die Daten werden im Cache dann als "veraltet" markiert und in jedem Fall beim n√§chsten Query neu gelesen
* Dazu kennt RTK Query das Konzept von **Tags**

---
### Tags

* Jeder Query-Endpunkt kann mit einem oder mehreren Tags assoziiert werden.
* √úber die Tags kann eine Mutation ausdr√ºcken, welche Daten von ihr ver√§ndert bzw. nach der Ausf√ºhrung nicht mehr g√ºltig sind.
* Angabe der Tags:
  * Mit `tagTypes` wird beim Erzeugen der API (`createApi`) angegeben, welche "Typen" von Tags es √ºberhaupt gibt, z.B. `Post` oder `User`
  * Angegeben werden die konkreten Tags dann mit der `provideTags`-Eigenschaft bei der Konfiguration des Endpunkts
* ```typescript
  export const postsApi = createApi({
    tagTypes: ["BlogPost"],

    endpoints: builder => ({
      loadPosts: builder.query<BlogPost[], void>({
        query: () => "/posts?slow",
        providesTags: ["BlogPost"]
      }),

      getPost: builder.query<BlogPost, string>({
        query: postId => `/posts/${postId}/?slow`,
        providesTags: (_result, _error, postId) => {
          return [{ type: "BlogPost", id: postId }, "BlogPost"];
        }
      })
    })
  });
  
  ```
<!-- .element: class="todo" -->ist das Beispiel richtig, oder muss getPost auch 'Post' haben?  
---
### Tags

* Ein Tag kann entweder nur ein String sein (`BlogPost`, `User`) oder ein Objekt, bestehend aus `type` und `id`
  * Mit der Id kann ein Tag genauer beschrieben werden:
    * _Ohne_ Id: dieser Endpunkt stellt allgemein "irgendwelche" Daten dieses Typs zur Verf√ºgung
    * _Mit_ Id: dieser Endpunkt stellt genau diese Daten ("Instanzen") zur Verf√ºgung
* `provideTags` kann entweder ein Array mit Tags sein oder ein Callback-Funktion
  * Die Callback-Funktion wird von RTK Query aufgerufen mit dem Query-Ergebnis (oder Fehler) und den √ºbergebenen Parametern
  * Auf dieser Basis kann die Funktion dann eine Liste von Tags f√ºr das konkrete Ergebnis zur√ºckliefern.
  * Im folgenden Beispiel ist die postId nicht vor der Ausf√ºhrung des Queries bekannt.
  * Der Cache Tag kann also erst auf Basis der geladenen Daten ermittelt werden:
  * ```typescript
      export const postsApi = createApi({
        tagTypes: ["BlogPost"],

        endpoints: builder => ({
          getNewestPost: builder.query<BlogPost, string>({
            query: postId => `/posts?orderBy=date&limit=1`,
            providesTags: (result) => {
              return result ? [{ type: "BlogPost", id: result.postId }] : [ "BlogPost" ]
            }
          })
        })
      });
    ```
---
### Tags invalidieren
* Eine Mutation kann angeben, welche Tags nach ihrer Ausf√ºhrung ung√ºltig sind
* Dazu wird die `invalidatesTags`-Eigenschaft bei der Defintion des Mutation-Endpunkts verwendet.
* Die Mutation kann ein einzelnes Tags oder eine Liste von Tags invalidieren
* Wie bei `provideTags` kann die `invalidatesTags`-Eigenschaft eine Liste oder eine Funktion zur√ºckliefern. 
  * Der Funktion werden dieselben Argumente √ºbergeben wie `provideTags`
* ```typescript
    export const postsApi = createApi({
      tagTypes: ["BlogPost"],

      
      endpoints: builder => ({
        savePost: builder.mutation<BlogPost, NewBlogPost>({
          query: newPost => ( ... ),
          invalidatesTags: ["BlogPost"]
        }),

        updatePost: builder.mutation<BlogPost, BlogPost>({
          query: post => ( ... ),
          invalidatesTags(result, error, param) { return [type: "BlogPost", id: param.id] }
        })
      })
    });
  ```
---
### Tags invalidieren
* In diesem Beispiel soll ein einzelner Blog Post aktualisiert werden:
* ```typescript
    export const postsApi = createApi({
      tagTypes: ["BlogPost"],

      loadPosts: builder.query<BlogPost[], void>({
        query: () => "/posts",
        providesTags: ["BlogPost"]
      }),
      
      endpoints: builder => ({
        updatePost: builder.mutation<BlogPost, BlogPost>({
          query: post => ( ... ),
          invalidatesTags(result, error, param) { return [type: "BlogPost", id: param.id] }
        })
      })
    });
  ```

* Die entsprechende Mutation markiert den Blog Post mit seinem Cache als veraltet
* Die Daten des `loadPosts` Endpunkts sind allerdings nur mit dem `BlogPost`-Tag assoziiert
* Das hei√üt die Daten, die `loadPosts` zur√ºckgeliefert hat, werden nicht als veraltet markiert. In dieser Liste k√∂nnte also der alte Blog Post weiterhin vorhanden sein.
---
### Tags invalidieren

* Um das Problem zu l√∂sen gibt es zwei M√∂glichkeiten
  1. `updatePost` liefert auch den Tag `BlogPost` zur√ºck. Damit w√ºrde die Liste ung√ºltig
  2. Die `loadPosts`-Daten werden auch mit einer `id` assoziiert
* In beiden F√§llen wird komplette Ergebnis von `loadPosts` als veraltet markiert und die erste Komponente, die `useLoadPostsQuery` verwendet, w√ºrde die Daten erneut laden.
* Beispiel: hier werden die Ids der Blog Posts, die `loadPosts` geladen hat, ebenfalls als Tag f√ºr `loadPosts` verwendet:
* ```typescript
    export const postsApi = createApi({
      tagTypes: ["BlogPost"],

      loadPosts: builder.query<BlogPost[], void>({
        query: () => "/posts",
        providesTags(result) { return result.map(p => ({type: "BlogPost", id: p.id})).concat("BlogPost") }
      }),
      
      endpoints: builder => ({
        updatePost: builder.mutation<BlogPost, BlogPost>({
          query: post => ( ... ),
          invalidatesTags(result, error, param) { return [type: "BlogPost", id: param.id] }
        })
      })
    });
  ```
---
### √úbung: Mutations mit RTK Query

* _Baue eine Mutation zum Speichern eines neuen BlogPosts_
* In der `PostEditorPage` wird `fetch` zum Speichern des Blog Posts verwendet. 
* Erweitere in `redux/posts-slice-api` die `postsApi` um eine Mutation zum Speichern des Posts
  * Weitere Informationen und Todos findest Du dort
* Ersetze den `fetch`-Code in `PostEditorPage` durch den `useSavePostMutation`-Hook
* Wenn das funktioniert, kannst Du noch _Cache Tags_ einf√ºhren, um den Cache nach dem Speichern eines Posts als "veraltet" zu markieren
* M√∂gliche L√∂sung: `steps/70-redux/78-rtk-query-mutation`
  * Dateien: `posts-slice-api.ts`, `PostEditorPage.tsx`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã


* Liste wird nicht aktualisiert üò¢
* TagTypes hinzuf√ºgen `BlogPost`



                        
          </textarea>
        </section>

        <!-- <section>
  <h2>√úbung: Redux Toolkit</h2>
  <p><em>Portiere den editor-slice auf Redux Toolkit (createSlice)</em></p>
  <p>Vorbereitung:</p>
  <ol>
    <li>
      Kopiere die Datei <code>store.js</code> aus
      <code>material/5-redux-toolkit/redux</code> in dein <code>src/redux</code>-Verzeichnis
      (bestehende Datei √ºberschreiben)
    </li>
    <li>
      Kopiere die Datei <code>editor-slice.js</code> aus
      <code>material/5-redux-toolkit/redux</code> in dein <code>src/redux</code>-Verzeichnis
      (deine Datei ggf. sichern)
    </li>
  </ol>
  <p>Schritte:</p>
  <ol>
    <li>In editor-slice.js stehen TODOs, du musst die reducer-Funktionen implementieren</li>
    <li>
      Der Rest der Anwendung sollte danach unver√§ndert laufen. Deswegen achte auf die
      korrekten Namen der reducer-Funktionen!
    </li>
  </ol>
  <p>M√∂gliche L√∂sung in <code>steps/5-redux-toolkit</code></p>
  <p>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</p>
</section> -->

        <!-- <section>
  <h2>√úbung: Der PostEditor mit Redux</h2>
  <p>Vorbereitung:</p>
  <ol>
    <li>Workspace <code>blog-example/workspace-redux</code></li>
    <li>Bitte <code>npm install</code> hier ausf√ºhren</li>
    <li>
      danach <code>npm start</code> ausf√ºhren (den laufenden Prozess bitte beenden)
    </li>
    <li>Den Workspace in der IDE/Editor √∂ffnen</li>
    <li>
      Wenn die Anwendung l√§uft, bitte "Hand heben" in Zoom, dann geht's weiter mit der
      eigentlichen √úbung üôã‚Äç‚ôÄÔ∏è
    </li>
  </ol>
</section> -->
        <!-- <section>
  <h2>√úbung: Der PostEditor mit Redux</h2>
  <p>
    Der Workspace enth√§lt zwei Verzeichnisse: <code>ui</code> f√ºr Komponenten und
    <code>redux</code> f√ºr Logik. Diese Aufteilung ist <em>nicht empfehlenswert</em> in
    "echten" Anwendungen (dort bitte nach Fachlichkeit aufteilen), macht uns hier aber das
    Leben einfacher.
  </p>

  <p>Schritte:</p>
  <ol>
    <li>
      Implementiere in <code>editor-slice.js</code> die Action Creator-Funktionen (siehe
      dort)
    </li>
    <li>Vervollst√§ndige die reducer-Funktion</li>
    <li>
      Migriere den (nicht funktionierenden) <code>PostEditor</code> so, dass der Draft Post
      aus dem Redux State gelesen und aktualisiert wird (<code>useSelector</code> und
      <code>useDispatch</code>)
    </li>
    <li>
      Vervollst√§ndige die <code>AppHeader</code>-Komponente, so dass diese den "Clear
      Draft"-Button anzeigen und ausl√∂sen kann
    </li>

    <li>
      In den drei Dateien sind todos eingetragen.
    </li>
    <li>M√∂gliche L√∂sung in <code>steps/5-redux</code></li>
    <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
  </ol>
</section> -->

        <!-- <section>
          <h2>Zusammenfassung Redux-Architektur</h2>
          <img
            src="slides/images/redux-03-resulting-redux-architecture.png"
            style="max-height: 650px"
          />
        </section>
        <section>
          <h3>Lokaler Zustand ist weiterhin erlaubt und erw√ºnscht!</h3>
          <p>Es gibt diverse Orte, wo Zustand vorkommt!</p>
          <ul>
            <li>Server und client</li>
            <li>Komponenten lokaler State</li>
            <li>Redux</li>
            <li>URL, Session or Local Storage</li>
          </ul>
          <p>Zustand immer so nah an dort halten, wo er gebraucht wird</p>
          <div>
            <img src="slides/images/three-kinds-of-state.png" style="max-height: 650px" />
          </div>
        </section> -->

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
