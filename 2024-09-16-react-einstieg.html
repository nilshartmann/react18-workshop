<!doctype html>
<!--suppress ALL -->
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div id="nils-clipboard">
      <svg
        width="100%"
        height="100%"
        viewBox="0 0 16 16"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M14.15 3.30005L11.525 0.700049C11.35 0.525049 11.1 0.425049 10.85 0.425049H6.30004C5.57504 0.425049 4.97504 1.02505 4.97504 1.75005V10.875C4.97504 11.6 5.57504 12.2 6.30004 12.2H13.1C13.825 12.2 14.425 11.6 14.425 10.875V3.97505C14.425 3.72505 14.325 3.47505 14.15 3.30005ZM11.575 2.35005L12.525 3.30005H11.575V2.35005ZM13.1 11.075H6.30004C6.20004 11.075 6.10004 10.975 6.10004 10.875V1.75005C6.10004 1.65005 6.20004 1.55005 6.30004 1.55005H10.45V3.85005C10.45 4.15005 10.7 4.42505 11.025 4.42505H13.3V10.9C13.3 11 13.2 11.075 13.1 11.075Z"
          fill="#d1d5db"
        />
        <path
          d="M11.025 5.62506H7.72502C7.42502 5.62506 7.15002 5.87506 7.15002 6.20006C7.15002 6.52506 7.40002 6.77506 7.72502 6.77506H11.025C11.325 6.77506 11.6 6.52506 11.6 6.20006C11.6 5.87506 11.325 5.62506 11.025 5.62506Z"
          fill="#d1d5db"
        />
        <path
          d="M11.025 7.72498H7.72502C7.42502 7.72498 7.15002 7.97498 7.15002 8.29998C7.15002 8.59998 7.40002 8.87498 7.72502 8.87498H11.025C11.325 8.87498 11.6 8.62498 11.6 8.29998C11.575 7.97498 11.325 7.72498 11.025 7.72498Z"
          fill="#d1d5db"
        />
        <path
          d="M10.45 13.0001C10.15 13.0001 9.87501 13.2501 9.87501 13.5751V14.2501C9.87501 14.3501 9.77501 14.4501 9.67501 14.4501H2.90001C2.80001 14.4501 2.70001 14.3501 2.70001 14.2501V5.10006C2.70001 5.00006 2.80001 4.90006 2.90001 4.90006H3.75001C4.05001 4.90006 4.32501 4.65006 4.32501 4.32506C4.32501 4.00006 4.07501 3.75006 3.75001 3.75006H2.90001C2.17501 3.75006 1.57501 4.35006 1.57501 5.07506V14.2501C1.57501 14.9751 2.17501 15.5751 2.90001 15.5751H9.70001C10.425 15.5751 11.025 14.9751 11.025 14.2501V13.5751C11.025 13.2501 10.775 13.0001 10.45 13.0001Z"
          fill="#d1d5db"
        />
      </svg>
    </div>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React Einf√ºhrung</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2024-09-16-react-einstieg</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg"
                  >https://nilshartmann.github.io/react18-workshop/2024-09-16-react-einstieg</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p style="margin-top: 2rem">
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>
          <p></p>
          <p style="margin-top: 5rem">Java | JavaScript, TypeScript | React | GraphQL</p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>
        <!-- ============================================================================= -->
        <section data-markdown="">
          <textarea data-template>
## Agenda

* [Teil 1: Hello World, React!](#/t1)
* [Teil 2: React-Komponenten und Hooks API](#/t2)
* [Teil 3: React-Komponenten mit TypeScript](#/t-3-typescript)
* [Teil 4: Komponenten-Hierarchien](#/t4)
* [Teil 5: Data Fetching](#/t5-data-fetching)
* [Teil 6: Clientseitiges Routing](#/t6-routing)
* Ausblick
  * [Seiteneffekte mit useEffect](#/seiteneffekte)
  * [Validieren von Daten mit zod](#/t-zod)
* Wenn ihr weitere Themen und W√ºnsche habt, jederzeit gerne. Einfach Bescheid sagen!


  </textarea
          >
        </section>

        <section id="t1">
          <h1>Teil 1</h1>
          <h2>React</h2>
        </section>

        <section>
          <h3>Beispiel-Anwendung</h3>
          <a target="_blank" href="http://localhost:3000">
            <img src="slides/images/blog-example.png" style="height: 850px" />
          </a>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Dokumentation</h3>

          <ul class="xx-list">
            <li>
              Dokumentation
              <a href="https://react.dev/">https://react.dev/</a>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### React im Umbruch?

* Bislang wurden und werden mit React Single-Page-Anwendungen (SPA) gebaut
* Mit Single-Page-Anwendungen l√§uft der Anwendungscode ausschlie√ülich im Browser
  * Man kann die Anwendung im (JavaScript-)Server vorrendern lassen (SSR)
* Seit M√§rz 2023 empfiehlt das React-Team ein "Fullstack Framework" wie Next.js zu verwenden
* Im Gegensatz zur "klassischen" Single-Page-Anwendung wird dabei ein Teil der Anwendung auf 
  einem (JavaScript-) Server ausgef√ºhrt
* Man kann aber weiterhin mit React SPAs bauen
* In dieser Schulung besch√§ftigen wir uns auch nur mit den SPAs
* Alles was wir sehen, w√§re auch Grundlage f√ºr Fullstack-Anwendungen 
  * Falls ihr also sp√§ter "Fullstack"-Anwendungen mit React bauen wollt, habt
  ihr auch daf√ºr schon die Grundlagen gelernt
  * Fullstack-Anwendungen bauen auf dem auf, was wir in uns in dieser Schulung ansehen
          </textarea>
        </section>

        <section>
          <h2>Unsere erste React-Komponente</h2>

          <ul>
            <li>
              <em>Sehen wir uns die wichtigsten Konzepte einer React-Komponente im Code an</em>
            </li>
            <li>Ihr k√∂nnt mir zugucken, √úbungen machen wir danach</li>
            <li>Schritt-f√ºr-Schritt (<code>react-intro/workspace</code>)</li>
          </ul>
        </section>

        <section id="interaktiv-hellomessage">
          <h3>Hello World React</h3>
          <code>PostEditor.js</code>
          <pre><code>
  import React from "react";
  
  export default function PostEditor() {
    const [title, setTitle] = React.useState("");
  
    return (
      &lt;div>
        &lt;label>
          Title
          &lt;input onChange={event => setTitle(event.target.value)} value={title} />
        &lt;/label>
      &lt;/div>
    );
  }
            </code></pre>
        </section>

        <section>
          <h3>Einbinden der Anwendung in die HTML-Seite</h3>
          <div>
            <p>
              <code>index.html</code>
            </p>
            <pre><code>
  &lt;html>
    &lt;-- ... -->
    &lt;body>
      <div id="root"></div>
    &lt;/body>
  &lt;/html>
  </code></pre>
          </div>
          <div>
            <p>
              <code>index.tsx</code>
            </p>
            <pre><code class="javascript">
  import React from 'react';

  import { createRoot } from 'react-dom/client';
  import PostEditor from './PostEditor';
  
  const root = createRoot(document.getElementById('root')!);
  root.render(&lt;PostEditor />);
  </code></pre>
            <p>Im Workspace ist die Root-Komponente die <code>App</code>-Komponente</p>
          </div>
        </section>

        <section>
          <h3>Der Trainingsworkspace</h3>
          <ul class="x-list">
            <li style="margin-bottom: 40px">
              <code>2024-09-16-react-einstieg.html</code>: Die Slides
            </li>
            <li style="margin-bottom: 40px">
              Der Code ist im <code><b>react-intro</b></code> Verzeichnis
            </li>

            <li style="margin-bottom: 40px">
              <code>react-intro/<b>workspace</b></code
              >: Verzeichnis f√ºr Eure √úbungen <br />üëâ&nbsp;<b>Empfehlung</b>: nur diesen Ordner in
              IDE/Editor √∂ffnen
            </li>
            <li>
              <code>react-intro/<b>steps</b></code
              >: Fertiger Source-Code nach jeder √úbung
            </li>
          </ul>
        </section>
        <section>
          <h2>√úbung #1: Hello-World</h2>
          <h3>
            <em>Mit Tools, Workspace und React vertraut machen</em>
          </h3>
        </section>
        <section>
          <h3>Schritt #1: Tool Chain starten</h3>
          <p>Gemeinsam, Schritt-f√ºr-Schritt:</p>
          <ol class="x-list" style="font-size: 85%">
            <li>Verzeichnis <code>react-intro/workspace</code> im Editor √∂ffnen</li>

            <li>
              <code>cd react-intro/workspace</code>
            </li>
            <li>
              <code>npm install</code>
            </li>
            <li>
              <code>npm run dev</code>
            </li>

            <li>
              Der Browser sollte automatisch
              <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>
              √∂ffnen
            </li>

            <li>Wenn Du "Hello, World" im Browser siehst, ist alles gut!</li>
            <li>Dann bitte in Teams "Hand heben" üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <p>
            <em
              >Ein kleiner Schritt f√ºr die PostEditor-Komponente, ein gro√üer Schritt f√ºr dich auf
              deinem Weg, React zu lernen!</em
            >
          </p>
          <ul>
            <li>Ersetze den "statischen" Code in <code>PostEditor.tsx</code></li>
            <li>Die Komponente soll <b>PostEditor</b> hei√üen</li>
            <li>
              Sie sollte einen Zustand/State (<code>title</code>) und ein Eingabefeld daf√ºr haben
            </li>
            <li>
              Als Hilfe kannst Du den Code aus den
              <a href="#interaktiv-hellomessage">vorherigen Slides</a> ansehen.
            </li>
            <li>
              Eine m√∂gliche L√∂sung findest Du auch in
              <code>react-intro/steps/02_hello_world_editor</code>
            </li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
## Hintergrund: Ein React Projekt beginnen

* Wenn ihr Single-Page-Anwendungen mit React bauen wollt, habt ihr zwei M√∂glichkeiten, euer Projekt aufzusetzen:
  * [Vite](https://vitejs.dev/) mit dem `react-ts` Template
  * [Create React App (CRA)](https://create-react-app.dev/). 
    * Das war lange das Standard-Tool zum Aufsetzen von React-Projekten, wird aber kaum noch weiterentwickelt
    * Wenn ihr bestehende React-Projekte seht, ist die Wahrscheinlichkeit aber hoch, dass das CRA aufgesetzt wurde
  * üëâ vite ist das Mittel der Wahl und wird auch hier im Workspace verwendet
  </textarea
          >
        </section>

        <section id="t2">
          <h1>Teil II</h1>
          <h2>React Komponenten und Hooks API</h2>
        </section>

        <section>
          <h3>React: JSX</h3>
          <ul>
            <li style="font-size: 80%">
              Wird wie HTML hingeschrieben, inkl Attribute:
              <pre><code class="xml"  >
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Achtung! <code>class</code>-Attribut hei√üt <code>className</code>:
              <pre><code class="xml"  >
&lt;h1 className="title">...&lt;/h1>
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              Attribute, die keine Strings sind, m√ºssen in {} eingeschlossen werden:
              <pre><code class="xml"  >
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              CSS-Eigenschaften werden als Objekt √ºbergeben in Camel-Case-Notation:
              <pre><code class="xml"  >
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>React: JSX #2</h3>
          <ul>
            <li style="font-size: 80%">
              Fragmente (rendern selber kein Element in den DOM, nur ihre Kind-Elemente):
              <pre><code class="xml"  >
function Choice() { 
  return &lt;&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt;/>              
}  
                    </code></pre>
            </li>
            <li style="font-size: 80%">
              null oder boolean (false oder true), um nichts zu rendern:
              <pre><code class="xml"  >
function ErrorMessage() {
  const hasError = someCondition(); // returns true or false

  return <div>
    {hasError && "Error!"}
    {hasError || "Everything fine"}
  </div>
}              
                    </code></pre>
            </li>

            <li style="font-size: 80%">
              Kommentare
              <pre><code class="xml"  >
  function MyComponent() {
    return <div>
      { /* hier ist javascript, deswegen block-kommentare erlaubt */ }
    </div>;
  }              
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Zustand einer Komponente und der useState-Hook (Zusammenfassung)</h3>
          <ul class="fragement">
            <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server, Menu offen oder zu</li>
            <li><b>Werte</b> √ºblicherweise immutable</li>
            <li>Arbeiten mit Zustand √ºber <b>useState</b>-Hook</li>
            <li>
              useState liefert Array mit zwei Werten zur√ºck: aktuellen Zustand, und setter-Funktion
              um Zustand zu ver√§ndern
            </li>
            <li>
              <pre><code class="javascript"  >
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  return &lt;input onChange={e => setTitle(e.target.value) value={title} />;
}
                  </code></pre>
            </li>

            <li>
              Aufruf des Setters <b>l√∂st erneutes rendern der <i>gesamten</i> Komponente aus</b>
            </li>
            <li>
              Es k√∂nnen mehrere States erzeugt werden, durch Verwendung mehrerer useState-Aufrufe
            </li>
            <li><b>Zustand</b> ist eines der <b>zentralen</b> Konzepte von React</li>
          </ul>
        </section>

        <section data-markdown="">
          <textarea data-template>
### useState: Komplexer Zustand
* Ihr k√∂nnt in einer Komponente mehrere useState-Aufrufe machen
* Dann k√∂nnt ihr die einzelnen Zust√§nde getrennt aktualisieren
* Wenn ihr "komplexen" Zustand habt, k√∂nnt ihr nat√ºrlich auch Objekte und Listen in einen Zustand aufnehmen
* ```typescript
  const [address, setAddress] = useState({ street: "Hauptstra√üe", city: "N√ºrnberg" });
  ```
* Dann aber bitte daran denken, dass der **Zustand immutable** ist.
* Das bedeutet, wenn ihr den Zustand √§ndert, m√ºsst ihr das Objekt/die Liste kopieren und dann die Kopie aktualisieren:
* ```typescript
  const onStreetChange = (newStreet) => {
    setAddress(
      // kopieren, bzw. alten Zustand hier einf√ºgen
      ...address,
      // neue Stra√üe setzen:
      street: newStreet
    );
  }
  ```
* Achtung! Der Spread-Operator macht eine flache Kopie. Bei Unterobjekten etc. m√ºsst ihr entsprechend mehr Kopieren.
* Eine gro√üe Hilfe bei komplexen Zustand ist die Bibliothek [Immer](https://immerjs.github.io/immer/)
---
### Ausblick: useReducer als Alternative zu useState
* Mit [useReducer](https://react.dev/reference/react/useReducer) k√∂nnt ihr die Verwaltung des Zustands von der Komponente trennen.
* Damit implementiert ihr eine "Reducer-Funktion", die React aufruft, wenn sich der Zustand √§ndern soll
* React √ºbergibt euch dann den aktuellen Zustand, sowie eine "Action", die beschreibt, was gerade passiert ist
  (z.B. Texteingabe erfolgt)
* In der Reducer-Funktion k√∂nnt ihr dann abh√§ngig vom bisherigen Zustand und der Action den neuen Zustand ermitteln
  </textarea
          >
        </section>

        <section>
          <h3>React Hooks API</h3>
          <em
            >Mit der React Hooks API kann sich eine Komponente in Zustand und Lebenszyklus
            "einhaken"</em
          >
          <ul>
            <li>
              Hooks sind "normale" Funktionen, m√ºssen aber mit <code>use</code> beginnen (useState,
              useEffect, ...)
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks API</h3>
          <em
            >Bei der Verwendung von Hooks gibt es einige Regeln ("Rules of Hooks") zu beachten Ô∏è</em
          >üëÆ‚Äç‚ôÄÔ∏è
          <p style="font-size: 75%; margin-top: 0">
            <a href="https://react.dev/reference/rules/rules-of-hooks"
              >(https://react.dev/reference/rules/rules-of-hooks)</a
            >
          </p>
          <div>
            <p>Einschr√§nkungen:</p>
            <ul>
              <li>
                Hooks k√∂nnen nur in Funktionskomponenten (und anderen Hooks) aufgerufen werden
              </li>
              <li>
                Hooks m√ºssen immer in derselben Reihenfolge und auf Top-Level-Ebene verwendet werden
                <ul>
                  <li>Verboten z.B. in Schleifen, if-Abfragen oder in anderen Funktionen</li>
                </ul>
              </li>
              <li>
                Es gibt ein
                <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint Plug-in</a>
                zur korrekten Verwendung der Hooks
              </li>
              <li>
                <em
                  >Der Hooks-Mechanismus basiert intern darauf, dass React sich die Reihenfolge der
                  <code>useXyz</code>-Aufrufe merkt!</em
                >
              </li>
            </ul>
          </div>
        </section>
        <section>
          <h3>React Hooks</h3>

          <em>Beispiele f√ºr korrekte und unerlaubte Verwendung</em>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const [name, setName] = React.useState("");
  // ...
}
                                </code></pre>

          <pre><code class="javascript"  >
// ERLAUBT:
function HelloWorld() {
  const [greeting, setGreeting] = React.useState("");
  const uppercaseGreeting = greeting.toUpperCase(); 
  const [name, setName] = React.useState("");
  // ...
}
                                                      </code></pre>

          <pre><code class="javascript"  >
// VERBOTEN:
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  function onSaveClick() {
    const [loading, setIsLoading] = React.useState(true);
    // ...
  }

  // ...
}
                                                      </code></pre>
        </section>

        <section>
          <h2>√úbung: Post-Editor f√ºr unsere Anwendung</h2>
          <em><b>Erweitere deine Komponente um neue Features</b></em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li>
              Zus√§tzlich zum "title", sollte es einen weiteren Zustand und eine Textarea geben:
              <code>body</code>. Ein <code>textarea</code>-Element hat dieselbe API wie ein
              <code>input</code>-Feld, du kannst also auch hier mit <code>onChange</code> und
              <code>value</code> arbeiten.
            </li>

            <li>
              F√ºge einen "Clear"-Button hinzu, der beide Eingabefeld leert. Das Property auf dem
              Button ist <code>onClick</code>.
            </li>
            <li>
              Der "Clear"-Button soll <b>disabled</b> sein, wenn beide Eingabefelder leer sind
            </li>
            <li>
              Optional: f√ºge unter beiden Feldern eine Fehler-Meldung hinzu, wenn das jeweilige Feld
              leer ist (z.B. "Please fill in Xyz")
            </li>
            <li>M√∂gliche L√∂sung: <code>steps/03_post_editor</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
### Ausblick: Formulare mit React

* Wenn ihr viel mit Formularen arbeitet, lohnt sich ein Blick auf spezialisierte Bibliotheken daf√ºr
* Eine verbreitete Bibliothek ist [React Hook Form](https://react-hook-form.com/)
* Die bringt auch fortgeschrittene Features mit:
    - Validierung der Daten
    - Fehlerzust√§nde
    - Tracking, welche Felder ausgef√ºhrt bzw. fokussiert wurden
* In React 19 wird es einen neuen Hook geben: [useActionState](https://19.react.dev/reference/react/useActionState)
  - Wahrscheinlich aber eher relevant wenn man auch serverseitig React verwendet
  </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-3-typescript" -->
# Teil 3
## React Anwendungen mit TypeScript
          </textarea>
        </section>

        <!-- ######################################################  -->
        <section>
          <h2>TypeScript</h2>
          <ol>
            <li><a href="#/t-typescript-grundlagen">Einf√ºhrung in TypeScript</a></li>
            <li><a href="#/t-typescript-react">React mit TypeScript</a></li>
          </ol>
        </section>

        <section id="t-typescript-grundlagen">
          <h2>Einf√ºhrung: Die Sprache TypeScript</h2>
          <p class="fragment">
            <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
            <a href="http://www.typescriptlang.org/" target="_blank"
              >http://www.typescriptlang.org/</a
            >)
          </p>
          <ul>
            <li class="fragment">Erweitert JavaScript um ein Typen System</li>
            <li class="fragment">
              Jeder g√ºltige JavaScript Code ist auch g√ºltiger TypeScript Code
            </li>
            <li class="fragment">
              Mittels des TypeScript Compilers wird aus TS Code JavaScript Code
            </li>
          </ul>
        </section>

        <section>
          <h3>TypeScript Grundlagen</h3>
          <p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Variablen k√∂nnen Typ-Informationen bekommen
  let foo: string;
  foo = 'yo';
  // Error: number: This type is incompatible with string
  foo = 10;
                 </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Funktionen
  function sayIt(what: string): string {
    return `Saying: ${what}`;
  }

  sayIt('Klaus'); // ok
  sayIt(10); // error
  </code></pre>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Arrow Funktionen
  const sayIt = (what: string): string => `Saying: ${what}`;

  sayIt('Moin');
  sayIt(123); // Error: Argument of type '123' is not assignable
              // to parameter of type 'string'.
  </code></pre>
        </section>

        <section>
          <h2>Eingebaute Typen</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // string
  let city: string = 'Hamburg';

  // boolean
  let isDone: boolean = false;

  // number
  let theAnswer: number = 42;

  // array (note the [])
  let cities: string[] = ['Hamburg', 'Barcelona'];
  // alternative:
  let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

  // void
  function log(s: string): void { /* ... */ }
              </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // any: kann alle Typen aufnehmen, Typ-Pr√ºfung ist ausgeschaltet
  let theUnknown: any = 'Who cares';
  theUnknown = 666; // ok
  theUnknown = true; // ok
  let a: number = theUnknown; // ok
  function loadData(): any { return "" // ok }
  let b:number = loadData(); // ok

              </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // unknown: kann ebefalls alle Typen aufnehmen, erzwingt aber vor der Verwendung Typ-Pr√ºfung
  function loadData(): unknown { return "" // ok }
  let b = loadData();
  b.toUpperCase(); // ERROR
  if (typeof b === "string") {
    // b ist jetzt string (typeof ist Laufzeitpr√ºfung!)
    b.toUpperCase(); // OK
  }
              </code></pre>
        </section>
        <section>
          <h2>Typen k√∂nnen abgeleitet (inferred) werden</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  let city = 'Hamburg'; // city ist ein String

  city = 42;
  // Fehler: [ts] Type '42' is not assignable to type 'string'.
  </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Explizite Angabe eines Types (parameter)
  // und abgeleiteter Typ (Return Type der Funktion)

  function sayIt(what: string) {
    return `Saying: ${what}`;
  }

  const said: string = sayIt('Hello TypeScript'); // ok
  const saidItWrong: number = sayIt('Hello TypeScript'); // error!


  </code></pre>
        </section>

        <section>
          <h2>Type Check ausschalten</h2>
          <p>
            Mit <code>@ts-ignore</code> (als Kommentar) kann wird die √úberpr√ºfung der n√§chsten Zeile
            ausgeschaltet:
          </p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = "Hamburg";

  city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

  // @ts-ignore
  city = 20259; // ok
  </code></pre>
          <p class="fragment">
            N√ºtzlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei
            Migration
          </p>
        </section>
        <section>
          <h2>null und undefined</h2>
          <div class="fragment">
            <p><code>null</code> muss explizit zugelassen werden <em>(strictNullChecks</em>):</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = null; //Type 'null' is not assignable to type 'string'.

  let optionalCity:string|null = null; // OK
              </code></pre>
          </div>
          <div class="fragment">
            <p><code>undefined</code> muss ebenfalls explizit zugelassen werden:</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
    let city:string = undefined; //Type 'undefined' is not assignable to type 'string'.

    let optionalCity:string|undefined = undefined; // OK
    let optionalCity:string|undefined|null = null; // OK
                </code></pre>
          </div>
          <div class="fragment">
            <p>
              Optionale Parameter k√∂nnen mit ? gekennzeichnet werden (erlauben dann auch
              <code>undefined</code>)
            </p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  function greet(name: string, greeting?: string) {
    console.log(`${greeting || 'Hello'}, {name}`);
  }

  greet('Susi', 'Moin')// Moin, Susi

  // 2. Parameter ist optional:
  greet('Klaus'); // Hello, Klaus

  greet('Peter', null); // Argument of type 'null' is not assignable
                        // to parameter of type 'string | undefined'.
              </code></pre>
          </div>
        </section>

        <section>
          <h2>Eigene Typen</h2>
          <p>
            Mit <code>interface</code> und <code>type</code>k√∂nnen eigene Typen (Objekt-Strukturen)
            definiert werden:
          </p>

          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
  // Komplexer Typ
  interface Person {
    name: string; // Pflicht
    livesIn?: string; // Optional
  }

  // Alternativ (interface und type fast synonym)
  type Person = { name: string; livesIn?: string; }

  const susi: Person = { // OK
    name: 'Klaus',
    livesIn: 'Hamburg'
  };
  const klaus: Person = { // OK (livesIn ist optional)
    name: 'Klaus'
  }

  const helmut: Person = {} // Error: Property 'name' is missing

  const lukas: Person = {
    name: 'Lukas',
    profession: 'Lokf√ºhrer'
  } // Error: 'profession' does not exist in type 'Person'.
                 </code></pre>
        </section>

        <section>
          <h2>Eigene Typen II</h2>
          <p>Eigene Objekt-Typen k√∂nnen sowohl "Attribute" als auch Funktionen enthalten:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
            // Komplexer Typ
            type Person {
              name: string; // Pflicht
              greet(greeting: string): string;
            }

            const p:Person = {
              name: "Klaus",
              greet(greeting: string) {
                return `${greeting}, ${this.name}`
              }
            }
            p.greet("Hello"); // OK
            p.greet(123); // ERR: Argument of type '123' is not
                          // assignable to parameter of type 'string'.

            const wrong:Person = {
              name: "Susi", // OK
              greet(greeting: number) {¬†return "hello" }
                // ERR: Type '(greeting: number) => string' is not assignable to
                //      type '(greeting: string) => string'.
                //      Types of parameters 'greeting' and 'greeting' are incompatible.
                //      Type 'string' is not assignable to type 'number'.
            }
                           </code></pre>
        </section>
        <section>
          <h2>Union Types</h2>
          <p>Variablen, Parameter etc. k√∂nnen mehr als einen Typ annehmen:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

function printNameOrTitle(obj: Person | Movie) {

  console.log(obj.title); // ERR: Property 'title' does not
                          // exist on type 'Person | Movie'

  if ("title" in obj) { // Abfrage ist ein "Type Guard"
    // obj ist Movie hier, title ist definiert
    console.log(obj.title);
  } else {
    // obj ist Person hier: name ist definiert
    console.log(obj.name);
  }
}

printNameOrTitle({name: "Klaus"}); //OK
printNameOrTitle({title: "Pulp Fiction"}); //OK
printNameOrTitle({label: "Save"}); // ERR

          </code></pre>
        </section>
        <section>
          <h2>Type Guards</h2>
          <p>Durch einen Type Guard k√∂nnen Typen "eingeengt" werden</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion true zurueckgibt, nimmt Typescript an,
// dass das √ºbergebene Argument vom Typ Movie ist
function isMovie(candidate: any): candidate is Movie {
  return ("title" in candidate);
}

function printNameOrTitle(obj: Person | Movie) {
  if (isMovie(obj)) {
    // movie
  }
}

          </code></pre>
        </section>
        <section>
          <h2>Type Assertions</h2>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion zurueckkehrt (kein Error geworfen wird) nimmt Typescript an,
// dass das √ºbergebene Argument vom Typ Movie  ist
function assertIsMovie(candidate: any): asserts candidate is  Movie {
  if ("title" in candidate) {
    return;
  }
  throw new Error("Candidate is not a movie!")
}

function printTitle(hopefullyAMovie: any) {
  assertPersonIsMovie(hopefullyAMovie)
  // hopefullyAMovie ist jetzt Movie
  hopefullyAMovie.title; // OK
}

          </code></pre>
        </section>
        <section>
          <h2>String Literal Types</h2>
          <p>Beispiel: String Aufz√§hlungstyp</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Beispiel:
type View = "POST_LIST" | "POST_EDITOR";

const s:View = "POST_LIST"; // OK
const t:View = "POST_LISTE" // FEHLER

function setView(v: VIEW) {
    if (v === "POST_LIST") { ... } // ok
    if (v === "POST_LISTE") { ... } // error: immer false
}

setView("POST_LIST"); //OK
setView("POST_LISTE"); // ERROR
          </code></pre>
        </section>

        <section>
          <h3>Typ-sicherheit in useState</h3>
          <ul>
            <li>Der Typ von useState wird grunds√§tzlich von TypeScript automatisch abgeleitet</li>
            <li>
              <pre><code class="line-numbers typescript" data-leftpad>
function PostEdior() {
  const [title, setTitle] = React.useState("");

  // greeting is string, because initial value is a string
  setGreeting("huhu"); // OK
  setGreeting(666); // ERROR (wrong Type)
  setGreeting(null); // ERROR (wrong Type)
  console.log(title.toUpperCase()); // OK
}
            </code></pre>
            </li>
            <li>Du kannst alternativ den Typen auch explizit setzen</li>
            <li>Das ist in einigen F√§llen sogar erforderlich:</li>
            <li>
              <ul>
                <li>Wenn du mehr als einen Typen angeben willst, z.B. null oder string</li>
                <li>
                  Wenn du eine Liste oder ein Objekt im Zustand hast, dessen Typ TypeScript nicht
                  ermitteln kann
                </li>
              </ul>
            </li>
            <li>
              <pre><code class="line-numbers typescript" data-leftpad>

function App() {
  const [error, setError] = React.useState&lt;null|string>(null);

  const [greetings, setGreetings] = React.useState&lt;string[]>([]);

  const [address, setAddress] = React.useState&lt;Address|undefined>();

  // ...
}
                            </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>√úbung: Hello, TypeScript!</h2>
          <h3>
            <em>Mach dich mit den Grundz√ºgen der Sprache TypeScript vertraut</em>
          </h3>

          <ol class="x-list">
            <li>Diese √úbung machen wir im TypeScript Playground!</li>
            <li>
              √ñffne dazu den TypeScript Playground im Browser: https://www.typescriptlang.org/play/
            </li>
            <li>
              Kopiere den Inhalt der Datei <code>material/ts-intro/uebung.ts</code> in den
              Playground-Editor
            </li>
            <li>Darin enthalten sind zahlreiche Compile-Fehler üò±</li>
            <li>
              Bitte erg√§nze die fehlenden Typ-Angaben, Hinweise und Todos findest du in der Datei
            </li>
            <li>M√∂gliche L√∂sung: <code>material/ts-intro/uebung_loesung.ts</code></li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="t4" -->
# Teil 4
## Komponenten-Hierarchien
* Themen:
  * [Properties von Komponenten](#/t4-properties)
  * [Kommunikation und Datenfluss](#/t4-komponenten-datenfluss)
  * [Listen mit JSX](#/t4-listen-mit-jsx)

  </textarea
          >
        </section>

        <!-- - - - - - - - - - - - - - - - PROPS HIER ERST - - - - - - - - - - - - - - -  -->
        <section id="t4-properties">
          <h3>React: Properties</h3>
          <p>Live: Die TagChooser-Komponente einbinden</p>
          <ul>
            <li>
              Mit <b>Properties</b> k√∂nnen einer Komponente von <b>au√üen</b> Werte und Eigenschaften
              √ºbergeben werden

              <pre><code class="javascript"  >
function PostEditor() {
    // type, onChange und value sind Properties!

    return (
      &lt;input type="text" onChange={() => setTitle("...")} value={title}&lt;/h1>
    );
  }
}
            </code></pre>
            </li>
            <li><b>Properties</b> k√∂nnen innerhalb der Komponente nicht ver√§ndert werden</li>
            <li>
              Zum Vergleich: <b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der
              Komponente (die ver√§ndert werden kann)
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties ("Props") einer Komponente</h3>
          <ul>
            <li>Komponenten k√∂nnen beliebig eigene Properties definieren</li>
            <li>
              Bei der Angabe der Properties bei der Verwendung einer Komponente werden die
              Properties wie von HTML gewohnt in der Notiation
              <code>name=value</code> hingeschrieben
            </li>
            <li>
              <pre><code class="javascript"  >
&lt;TagChooser title="Select tags for your post" availableTags={["JS", "Web Development" ]} />
               </code></pre>
            </li>
            <li>
              ...alle angegebenen Properties werden von React "gesammelt" und in
              <b>einem Objekt</b> an die Komponente √ºbergeben
            </li>
            <li>Das Objekt ist immer das <b>erste Funktionsargument</b> einer Komponente</li>
            <li>
              <pre><code class="javascript"  >
function TagChooser(props) {
    // props:
    //  {
    //     title: "Select tags for your post",
    //     availableTags: ["JS", "Web Development" ]
    // }

    return ...;
}
              </code></pre>
            </li>
            <li>
              <pre><code class="javascript"  >
// Mit Destructuring
function PostEditor( {title, availableTags} ) {

    return ...;
}
                                </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Properties mit TypeScript
<!-- .slide: class="left" -->
- Der erste Parameter einer Komponente ist immer ein `object`
- Mit TypeScript kannst du beschreiben, welche Properties deine Komponente darin erwartet und von welchem Typ die sind
  - Daran ist aus TypeScript-Sicht nichts React-spezifisch
- Dazu musst du mit `type` (oder `interface`) das `props`-Objekt beschreiben
- Wie du den Typen nennst, spielt keine Rolle.
  - In der Regel ist die Konvention entweder nur `Props` oder `KomponentenNameProps`
  * ```typescript
    type TagChooserProps = {
      // optionales Property:
      title?: string;

      // Liste mit Strings:
      availableTags: string[]

      // Auch (Callback-)Funktionen sind erlaubt:
      onTagSelected(tag: string): void
    }
    ```

* In der Funktionssignatur eurer Komponente gebt ihr den Typen dann an:
  * ```typescript
    export default function TagChooser(props: TagChooserProps) { /* ... */ }
    ```
  * ```typescript
    // Mit Destructuring:
    export default function TagChooser({title, availableTags}: TagChooserProps) { /* ... */ }
    ```

          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Properties: Default-Werte</h3>

          <p>
            Mit dem Object Destructuring-Operator k√∂nnen <b>Default-Werte</b> angegeben werden, f√ºr
            Eigenschaften, die aus einem Objekt gelesen werden, aber dort nicht angegeben (bzw.
            undefined) sind:
          </p>
          <p>
            F√ºr den Aufrufer sind die Properties dann optional, innerhalb der Komponente wei√ü
            TypeScript aber, dass ein Wert vorhanden ist (und kennt auch dessen Typ)
          </p>

          <pre><code class="javascript">
function TagChooser({title = "Select Tag", availableTags}: TagChooserProps) {
  // 'title' ist hier in jedem Fall vom Typ 'string', auch wenn
  //  das vom Aufrufer nicht gesetzt wird

  // ...
}
          </code></pre>
          <pre><code class="javascript">
// title in der Komponente ist "Select Tag"
&lt;TagChooser availableTags={["JS", "React"]} />
          </code></pre>
        </section>

        <!--        <section>-->
        <!--          <h3>Virtual DOM</h3>-->
        <!--          <p>Beispiel: <code>react-intro/steps/2b-rendering</code></p>-->
        <!--        </section>-->

        <section data-markdown>
          <textarea data-template>
<!-- .slide: class="left" -->
<!-- .slide: id="t4-listen-mit-jsx" -->
### Listen in React

* JSX hat keine eigene Syntax zum Erzeugen von Listen-Darstellungen (im Gegensatz zu anderen Template-Sprachen, z.B. `ng:for` in Angular)
* Stattdessen verwendet man das normale [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) um Listen mit "Daten" auf Listen mit "UI" abzubilden
* ```typescript
  // Beispiel: eine Liste mit Tags
  const availableTags = [ "JavaScript", "React" ];
  ```
* ```typescript
  // Beispiel JavaScript: Mappen von Werten auf neue Werte
  const t = availableTags.map( t => t.toUpperCase());
    // t: [ "JAVASCRIPT", "REACT" ]
  ```
* Beim Erzeugen von Listen in React muss jedes Element ein [`key`-Property](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) bekommen, das innerhalb der Liste eindeutig sein muss

* ```typescript
  // Beispiel: In React zur Erzeugung von Listen:
  const list = availableTags.map(t => <li key={t}>Tag: {t}</li>
    // <li key="JavaScript">Tag: JavaScript</li>
    // <li key="React">Tag: React</li>
  ```
* ```typescript
  // Komplettes Beispiel:
  function TagChooser({availableTags}: TagChooserProps) {
    // ...
    return <ul>
      {availableTags.map(t => <li key={t}>Tag: {t}</li>}
    </ul>;
  }
  ```

* Doku: https://react.dev/learn/rendering-lists

  </textarea
          >
        </section>

        <section>
          <h2>√úbung: Ein TagChooser</h2>
          <em>Schritt 1 f√ºr den TagChooser: Darstellung der "available" Tags</em>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="xx-list">
            <li>In <code>TagChooser.tsx</code> gibt es bereits eine TagChooser-Komponente.</li>
            <li>Diese Komponente musst du um Properties erweitern</li>
            <li>Au√üerdem musst du darin die √ºbergebenen (<code>availableTags</code>) anzeigen</li>
            <li>Du findest dazu Hinweise direkt in der Datei.</li>

            <li>M√∂gliche L√∂sung: <code>steps/05_props</code></li>
            <li>Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <section>
          <h3>Hintergrund: Virtual DOM</h3>
          <p>"Rendern" hat leider doppelte Bedeutung!</p>
          <img src="slides/images/vdom.png" style="height: 650px" />
        </section>

        <section>
          <h2>React Devtools</h2>
          <em>React Developer Tools f√ºr Chrome und Firefox</em>
          <p>Untersuchen der React Anwendung zur Laufzeit</p>
          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/"
                target="_blank"
                >Firefox</a
              >
            </li>
          </ul>

          <p><img src="slides/images/screenshot-react-dev-tools.png" /></p>
        </section>
        <!-- <section>
          <h3>Render Zyklus</h3>
          <img src="slides/images/render-cycle.png" height="550px" />
        </section> -->

        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="t4-komponenten-datenfluss" -->
## Datenfluss: Wie k√∂nnen Komponenten untereinander kommunizieren?
* üëâ `PostEditor` und `TagChooser`
          </textarea>
        </section>

        <!--        <section>-->
        <!--          <h3>Smart und Dumb-Komponenten #1</h3>-->

        <!--          <p>-->
        <!--            Zur Erinnerung: in React bauen wir Komponenten. Komponenten bestehen aus Logik, Zustand-->
        <!--            und UI (HTML-Elemente und Styling)-->
        <!--          </p>-->
        <!--          <p>-->
        <!--            Ein bekanntes Muster ist, die Komponenten in zwei Arten aufzuteilen:-->
        <!--            <b>Smart (oder Controller)</b>- und <b>Dumb oder (Presentation-)</b>-Komponenten-->
        <!--          </p>-->
        <!--          <p>Technisch sind die Komponenten identisch, also "normale" React-Komponenten</p>-->
        <!--          <p>Nur ihre <b>Aufgabe</b> ist anders definiert...</p>-->
        <!--        </section>-->

        <section>
          <h3>Datenfluss in React-Anwendungen</h3>
          <p>
            <em
              >In React erfolgt der Datenfluss zwischen Komponenten
              <b>immer von oben nach unten</b>:</em
            >
          </p>
          <ol>
            <li>
              Eine Parent-Komponente hat <b>Zustand (State)</b> und ggf. Logik, um mit dem Zustand
              zu arbeiten
            </li>
            <li>
              Die Parent-Komponente reicht Daten per Properties an ihre Kind-Komponenten weiter
              (z.B. Daten aus dem Zustand)
            </li>
            <li>
              Au√üerdem gibt die Parent-Komponente <b>Callback-Funktionen als Properties</b> an ihre
              Kind-Komponenten (als eine Art Event-Handler)
            </li>
            <li>
              Bei einem Ereignis (zum Beispiel neues Tag ausgew√§hlt) ruft die Kind-Komponente die
              Callback-Funktion der Parent-Komponente auf
            </li>
            <li>
              In der Callback-Funktion findet dann die fachliche Verarbeitung des Events statt.
              Dabei kann die Parent-Komponente zum Beispiel ihren <b>State aktualisieren</b>
            </li>
            <li>
              Das √Ñndern des States triggert das <b>erneute Rendern der Komponenten-Hierarchie</b>,
              so dass sowohl Parent- als auch Kind-Komponente ihre Darstellung gem√§√ü den
              aktualisierten Daten anzeigen k√∂nnen
            </li>
          </ol>
          <ul>
            <li>
              Dieses Verhalten haben wir bei der eingebauten <code>input</code>-Komponente bereits
              gesehen. (<code>value</code> und <code>onChange</code>-Property)
            </li>
            <li>
              üëâ Durch das pauschale neurendern auch aller Kind-Komponenten kann es nicht zu
              <b>Inkonsistenzen</b> in der Darstellung durch "vergessenes" Rendern kommen.
            </li>
          </ul>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Kontrollierte" und "unkontrollierte" Komponenten
* Komponenten, die von einer anderen Komponente "kontrolliert" werden, werden **controlled components** in React genannt
* Diese Komponenten verlassen sich darauf, dass ihre Parent-Komponente den Zustand verwalten
* Beispiele f√ºr `controlled components`:
    * `input` (mit `onChange` und `value`): Oberkomponenten h√§lt den Inhalt des Eingabefelds und steuert, wann bzw. wie dieser ge√§ndert werden soll.
    * `TagChooser` (mit `selectedTags` und `onSelectionChange`): PostEditor kontrolliert, welche Tags ausgew√§hlt sind und was passieren soll, wenn sich die Auswahl √§ndert
    (PostEditor k√∂nnte sich zum Beispiel entschliessen, eine Auswahl zu ignorieren, oder unabh√§ngig vom TagChooser die Tags zur√ºckzusetzen)
* Beispiel f√ºr eine unkontrollierte Komponente:
    * `TagChooser` (in der bisherigen Form mit lokalem Zustand): Der PostEditor hat keinen Einfluss auf die Auswahl der Tags
    * `PostEditor`
  </textarea
          >
        </section>

        <section>
          <h3>Komponenten-Hierarchie mit Properties und Callback-Funktionen</h3>
          <img src="slides/images/posteditor-tagchooser-hierarchy.png" height="1000px" />
        </section>
        <section data-markdown="">
          <textarea data-template>
### Beispiel: PostEditor und TagChooser
* Der PostEditor enth√§lt die Liste aller Tags, sowie die aktuell f√ºr den neuen Post ausgew√§hlten Tags
* Der PostEditor gibt die ausgew√§hlten Tags an die TagChooser-Komponenten
* Der PostEditor gibt au√üerdem eine Callback-Funktion an den TagChooser
* Der TagChooser ruft diese Callback-Funktion auf, sobald sich die Auswahl der Tags ge√§ndert hat
* ```typescript
  function PostEditor() {
    const [tags, setTags] = useState<string[]>([]);

    return <>
      { /* ... */ }
      <TagChooser selectedTags={tags} onSelectionChange={setTags} />
    </>
  }
  function TagChooser({selectedTags, onSelectionChange}) {
    // kein State mehr!

    const handleTagClick = () => {
      // wenn ein Tag angeklickt wird, neue Auswahl ermitteln
      // und damit die Oberkomponente informieren
      const newSelectedTags = ...;

      onSelectionChange(newSelectedTags);
    }

    return /* ... */;
  }

  ```
  </textarea
          >
        </section>

        <section>
          <h2>√úbung: Mache den TagChooser zu einer "kontrollierten" Komponente</h2>
          <p>
            <em> Der PostEditor soll die Liste der ausgew√§hlten Tags verwalten </em>
          </p>
          <ol class="xx-list">
            <li>
              In <code>react-intro/material/06_hierarchien</code> findest du eine
              <code>TagChooser.tsx</code>-Datei
            </li>
            <li>In dieser Datei findest du eine Beschreibung der erforderlichen Schritte</li>
            <li>
              Du kannst die √Ñnderungen entweder an deinem eigenen TagChooser im Workspace
              vornehmen...
            </li>
            <li>
              ...oder du kopierst dir die <code>TagChooser.tsx</code>-Datei in einen Workspace als
              Ausgangsbasis
            </li>
            <li>M√∂gliche L√∂sung: <code>steps/06-hierarchien</code></li>
            <li>Wenn Du fertig bist, bitte in Teams "Hand heben" üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section data-markdown="">
          <textarea data-template>
### "Lifting State up"
* Der Zustand ist an eine Komponente und deren Lebenszyklus gebunden
* Wenn eine Komponente von React aus dem DOM entfernt wird ("unmount"), geht auch deren Zustand verloren
* Wenn der PostEditor also entfernt wird gehen auch alle Eingaben und die ausgew√§hlten Tags verloren
* Dazu ein Beispiel
* <!-- .element: class="demo" --> PostPreview in 07_exkurs_lifting_state_up
---
### "Lifting State up"
* Wenn ihr Zustand ben√∂tigt, der das Entfernen einer Komponente √ºberlebt, m√ºsst ihr den Zustand in der Komponente nach oben schieben
* Dasselbe gilt auch, wenn ihr Zustand habt, der von mehr als einer Komponente verwendet werden soll
  * Erinnerung: Kommunikation erfolgt immer von oben nach unten, nie auf gleicher Ebene
* Soweit nach oben, bis ihr zu einer Komponente kommt, die √ºber den Komponenten steht, die den Zustand ben√∂tigen
* Dieses Pattern wird als ["Lifting State up"](https://react.dev/learn/sharing-state-between-components#lifting-state-up-by-example) bezeichnet
* Im `PostPreview`-Beispiel wird der Zustand aus dem `PostEditor` auch in `PostPreview` ben√∂tigt und wird dem entsprechend in
            `PostEditorPage` hochgeschoben
* <img src="slides/images/lifting-state-up.png" height="500px"/>

          </textarea>
        </section>
        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="#/t5-data-fetching" -->
# Teil 5
## Data Fetching
* *Lesen und Schreiben von Daten von einem Backend (REST/HTTP)*
---
## Data Fetching
* Themen
  * [Ausf√ºhren von HTTP Requests mit "ky"](#/ky)
  * [Hintergrund: Asynchroner Code mit JavaScript Promises](#/t-promises)
  * [TanStack Query](#/ts-query)
  * [Daten lesen mit useQuery](#/ts-use-query)
  * [Mutations](#/ts-query-mutations)
---
## Data Fetching
* <!-- .element: class="demo" --> Schritt-f√ºr-Schritt Demo:
  * `react-intro/steps/20_data_fetching`
  * `react-intro/steps/25_mutations`
          </textarea>
        </section>

        <!-- =================================================================================================== -->
        <!-- ==   Promises und Speichern                                                                                          == -->
        <!-- =================================================================================================== -->
        <section>
          <h2>Server-Zugriffe</h2>
          <ul class="x-list">
            <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
            <li>
              In der Regel braucht man zwei Dinge:
              <ol>
                <li>Eine (low-level) Bibliothek zum Ausf√ºhren der eigentlichen Requests</li>
                <li>
                  Eine (high-level) Bibliothek zum Arbeiten mit den Daten mit erweiterten Features
                  wie Caching und Fehlerbehandlung
                </li>
              </ol>
            </li>
            <li>
              H√§ufig in React verwendet: <b>fetch</b> API
              <ul>
                <li>Browser-API zum Ausf√ºhren von HTTP Requests</li>
                <li>
                  Dokumentation:
                  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"
                    >Fetch API (MDN)</a
                  >
                </li>
              </ul>
            </li>
            <li>
              Im Workshop verwenden wir <a href="https://github.com/sindresorhus/ky">ky</a>
              <ul>
                <li>Kleine Bibliothek, die auf fetch basiert</li>
                <li>
                  Abstraktion f√ºr typische Anwendungsf√§lle macht die Bedienung etwas einfacher
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Die ky Bibliothek
<!-- .slide: id="ky" -->
* Auf dem `ky`-Objekt sind Funktionen definiert, mit denen ihr Requests mit unterschiedlichen HTTP Methoden machen k√∂nnt (`get`, `post`, ...)
* Die Methoden haben jeweils zwei Parameter:
  1. Die Methoden erwarten die URL, die ihr aufrufen wollt
  2. (optional) Ein Objekt mit weiteren Einstellungen f√ºr einen Request, z.B. der Payload
* Die Funktionen liefern jeweils ein Promise mit einem `Response`-Objekt zur√ºck
  * Dabei handelt es sich um eine Erweiterung des standardisierten [Response-Objektes des Browsers](https://developer.mozilla.org/en-US/docs/Web/API/Response).
  * In ky gibt es darauf noch Hilfsmethoden, die es vereinfachen mit dem Payload der Antwort zu arbeiten
* Als Typ-Argument kann jeweils der erwartete R√ºckgabe-Typ in TypeScript definiert werden
  * Achtung! Nur Build-Zeit-Pr√ºfung, zur Laufzeit findet keine Pr√ºfung statt, ob die Antwort vom Server dem angegebenen
    Typen entspricht.

* ```typescript
  // HTTP GET Request
  const blogPosts = await ky
          .get<BlogPost[]>(`http://localhost:7000/posts`)
          .json();
  // ...
  ```
* ```typescript
  // HTTP POST Request mit Objekt als Body
  const newBlogPost = await ky.post<BlogPost>("http://localhost:7000/posts", {
          json: { title, body, tags }
  // ...
  });
  ```
  </textarea
          >
        </section>

        <section data-state="exkurs" id="t-promises">
          <h3>Hintergrund: Promises in JavaScript</h3>

          <p class="fragment">
            Ein Promise liefert einen "Versprechen" auf einen Wert zur√ºck, der evtl. erst in der
            Zukunft ermittelt werden kann
          </p>
          <p class="fragment">
            Damit k√∂nnen wir asynchrones Verhalten in JavaScript Applikation abbilden
          </p>
          <pre class="fragment"><code class="javascript" contenteditable>
// "getNameAsync" ist eine ausgedachte Funktion, 
// die ein Promise zur√ºckliefert, 
// das "irgendwann" den String "Klaus" zur√ºckgibt
const promise = getNameAsync();
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise.then(name => console.log(name));
// Ausgabe "irgendwann": "Klaus"
  </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>Promises</h3>
          <p>Promises k√∂nnen verkettet werden</p>
          <pre><code class="javascript" contenteditable>
// Annahme: 'getNameAsync' liefert "irgendwann" den String "Klaus" zur√ºck
const promise = getNameAsync()

// Wird mit dem ersten Wert aufgerufen und gibt neuen Wert zur√ºck
.then(name => getGreetingAsync(name)) 

// wird mit dem zweiten Wert (aus vorherigem then) aufgerufen
.then(greeting => console.log(greeting));

// Ausgabe "irgendwann": 
// "Hello, Klaus"

  </code></pre>
          <p class="fragment">
            Die <code>then</code>-Funktion gibt <b>immer</b> ein Promise zur√ºck
          </p>
        </section>

        <section data-state="exkurs">
          <h3>Fehlerbehandlung</h3>
          <h4>Mit <code>catch()</code> kann man Fehler fangen und darauf reagieren</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
  const promise = getNameAsync()

    .then(name => { if (name === null) throw new Error("No name found") })

    .then(greeting => console.log(greeting));

    .catch(error => console.error(`Greeting failed: ${error}`))
  
    // Wenn 'getNameAsync' null zur√ºckliefert ist die Ausgabe:
    //   Greeting failed: No name found
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section data-state="exkurs">
          <h3>Finally</h3>

          <p class="fragment">
            Eine <code>finally</code>-Callback-Funktion wird nach dem letzten <code>then</code> bzw.
            <code>catch</code>-Block ausgef√ºhrt.
          </p>

          <p class="fragment">
            Die finally-Funktion wird <b>immer</b> ausgef√ºhrt (unabh√§ngig davon, ob vorher ein
            Fehler aufgetreten ist oder nicht
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              const promise = getNameAsync();

                .then(name => { if (name === null) throw new Error("No name found") })

                .then(greeting => console.log(greeting));

                .catch(error => console.error(`Greeting failed: ${error}`))

                .finally( () => console.log("Goodbye!") );
              
                // Output (error): Greeting failed: No name found
                // Output (log): Goodbye!
                </code></pre>
        </section>

        <section data-state="exkurs">
          <h2>async / await</h2>
          <p>"Wrapper" um Promises</p>
          <p>Erlaubt es, asynchronen Code "linear" hinzuschreiben</p>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>await</code> wartet bis ein Promise aufgel√∂st wird</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }
    
    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);
    
      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section data-state="exkurs">
          <h3>async / await</h3>
          <p><code>async</code> machen eine Funktion zu einer "async function"</p>
          <p class="fragment">
            Eine <code>async</code> Funktion gibt &nbsp; <b>immer</b> ein Promise zur√ºck
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }
  
  const greeting = greet('Klaus');
  
  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> Funktion als Fat Arrow Funktionen:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;                
    
  const greeting = greet('Klaus');
    
  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-state="exkurs">
          <h3>async / await</h3>
          <p>
            Anstatt <code>then</code> oder <code>catch</code>-Ketten kannst Du einfach mehrere
            <code>await</code> Statements verwenden und try/catch f√ºr die Fehlerbehandlung:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};
  
  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
                      </code></pre>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Daten laden mit ky
* In einer ganz einfachen Variante k√∂nnen wir wie folgt Daten vom Backend in unsere Komponente laden:
* ```typescript
  export default function PostList() {
    const [posts, setPosts] = useState<BlogPost[]>([]);

    const handleLoadPosts = async () => {

      // Achtung! get() bzw. json() liefert Promise zur√ºck!
      //   -> mit await warten!
      const receivedPosts = await ky.get<BlogPost[]>("http://localhost:7000/posts")
            .json();

      // geladene Posts in den State packen:
      setPosts(receivedPosts);
    }

    return <div>
      <button onClick={handleLoadPosts}>Load Posts</button>
      // ...Posts rendern...
      </div>
  }
  ```
* Hier fehlen aber wichtige Features:
  * Fehlerhandling
  * Verhindern doppelter Requests
  * Caching
  * Zugriff auf die Daten in weiteren Komponenten
* üëâ deswegen verwendet man fetch bzw. ky √ºblicherweise mit einer Data Fetching Bibliothek
---
<!-- .slide: id="ts-query" -->
## Data Fetching Bibliotheken
* Es gibt spezialisierte Bibliotheken f√ºr React, die typische Anwendungsf√§lle und Probleme beim Lesen von Daten adressieren
  * [TanStack Query](https://tanstack.com/query/latest): Prominenteste Bibliothek zum Laden/Speichern von Daten inklusive Cache-Funktion
  * [SWR](https://swr.vercel.app/)
  * [Redux Toolkit Query](https://redux-toolkit.js.org/rtk-query/overview): Arbeiten mit APIs in Redux-Anwendungen
  * [Apollo GraphQL Client](https://www.apollographql.com/docs/react/): Client f√ºr GraphQL APIs mit Cache und Statemanagement M√∂glichkeiten
* Diese Bibliotheken haben alle √§hnliche Konzepte:
  * Hooks zum Laden/Speichern von Daten
  * globales Caching von Daten (auch zur Sicherstellung der konsistenten Darstellung)
    * Strategien zur Aktualisierung von Daten (auch automatisch im Hintergrund)
  * Unterst√ºtzung f√ºr das [Suspense-Feature von React](https://react.dev/reference/react/Suspense) (mit Ausnahme von RTK Query)

---
## TanStack Query
### Schritt-f√ºr-Schritt: Laden von Daten mit "TanStack Query"

* üëâ `PostListPage`

---
### Der QueryClient

* Zentrales Konfigurationsobject: `QueryClient`
* React-unabh√§ngig
* Wird beim Starten der Anwendung initialisiert
* Oft reichen Default-Einstellung
* Es k√∂nnen aber z.B. globale Refetch-Policies eingestellt werden
* Das Objekt wird per QueryClientProvider in die Anwendung gereicht
* ```typescript
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false
      }
    }
  });

  root.render(
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  );
  ```
* In unserem Workspace wird der QueryClient in `create-query-client.ts` erzeugt

---
### Laden von Daten: useQuery
<!-- .slide: id="ts-use-query" -->
* [Queries](https://tanstack.com/query/latest/docs/react/guides/queries) werden mit dem `useQuery`-Hook ausgef√ºhrt
* [Der `useQuery`-Hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) erwartet ein Konfigurationsobjekt
  * `queryKey`: Array mit Query Keys (zur Interaktion mit dem Cache)
  * `queryFn`: Funktion zum Laden der Daten
  * Weitere Konfigurationen (optional)
* ```typescript
  import { useQuery } from "react-query";

  function BlogListPage() {

    const result = useQuery({
            queryKey: ['posts'],
            queryFn() { /* ... */ }
    );

    // ...
  }
  ```
---
### Query Function

* `useQuery` erwartet eine [Query-Function](https://tanstack.com/query/latest/docs/react/guides/query-functions), die den eigentlichen Request ausf√ºhrt
* Diese Funktion m√ºsst ihr selbst implementieren, z.B. mit ky oder fetch
* Die Funktion muss ein Promise mit den gelesenen Daten zur√ºckliefern
* Wenn es einen Fehler gab, muss die Funktion einen Fehler werfen
  * Wenn ihr `ky` benutzt, passiert das automatisch bei allen HTTP Status Codes die nicht im 200er-Bereich liegen
  * Wenn ihr `fetch` benutzt, m√ºsst ihr selber den Status Code √ºberpr√ºfen und ggf. einen Fehler werden
* Aus dem R√ºckgabe-Typ der Query-Funktion leitet `useQuery` den TypeScript-Typ f√ºr die gelesenen Daten ab.
* ```typescript
  import { useQuery } from "react-query";

  function BlogListPage() {

    const result = useQuery({
        queryKey: ['posts'],
        queryFn(): {
          return ky.get("http://...").json();
        }
    );

    // ...
  }
  ```

---

### R√ºckagebwert von `useQuery` (Query Ergebnis)

* `useQuery` liefert ein Objekt zur√ºck, das u.a. folgende Informationen umfasst:
  * `isLoading`: Der Query l√§dt noch (und es sind keine Daten im Cache)
  * `isSuccess`: Daten sind geladen
  * `isError`: Es ist ein Fehler aufgetreten
  * `data` enth√§lt die geladenen Daten (wenn `isSuccess` `true` ist)
  * `error`: Fehlerobjekt aus der Query-Funktion (wenn `isError` auf `true` gesetzt ist)
* Weitere [siehe Doku](https://tanstack.com/query/latest/docs/react/reference/useQuery)

---
### Query Keys

* [Query Keys](https://tanstack.com/query/latest/docs/react/guides/query-keys) werden verwendet, um das Ergebnis eines Queries identifizieren und cachen zu k√∂nnen
* Ein Query Key besteht aus einem Array von Werten
* √úblicherweise ist es ein Name (z.B. "posts") und dann ggf. weitere Parameter, zum Beispiel die Id eines Posts ("P1")
  oder die Sortierreihenfolge
  * Also alle Daten, die den Query exakt beschreiben
* ```typescript
  import { useQuery } from "react-query";

  function BlogPage({postId}) {

    // F√ºr jeden Aufruf mit einer neuen postId
    //  wird das Ergebnis separat in den Cache gelegt
    const result = useQuery({
      queryKey: ['blogPost', postId],
      queryFn: () => ky.get(`http://localhost:7000/posts/${postId}`).json()
    });

    // ...
  }
  ```
* Wenn ein Query mit denselben Query Keys in mehr als einer Komponente ausgef√ºhrt wird...
  * ...stellt TanStack Query sicher, dass der Query nur einmal ausgef√ºhrt wird
  * ...wenn sich das Ergebnis √§ndert, werden alle Komponenten, die den Query verwenden, automatisch aus dem Cache aktualisiert
---
### TanStack Query: Mutations
<!-- .slide: id="ts-query-mutations" -->

* [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) werden verwendet, um Daten auf dem Server zu *ver√§ndern* (speichern, l√∂schen)
* √úblicherweise werden dabei HTTP POST, PATCH, PUT oder DELETE Requests ausgef√ºhrt
* Der entsprechende Hook hei√üt [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
* Dessen API ist vergleichbar mit `useQuery`
* Auch der `useMutation`-Hook liefert Informationen √ºber den Zustand der Mutation zur√ºck
* ```typescript
  import { useMutation } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const mutation = useMutation({
      mutationFn() { ky.post("http://....", {json: { title, body } } ) },
      onSuccess() {
        // optional: wird aufgerufen, wenn die Mutation erfolgreich war
        // ...
      }
    });

    if (mutation.isSuccess) {
      return <h1>Blog Post saved!</h1>;
    }

    if (mutation.isError) {
      return <h1>Error: {mutation.error.toString()}</h1>;
    }

    // ...
  }
  ```
---
### TanStack Query: Mutations
* Im Gegensatz zu `useQuery` wird eine Mutation aber nicht automatisch ausgef√ºhrt, sondern wird explizit gestartet
* Dazu liefert `useMutation` die Funktion `mutate` zur√ºck
* √úbergeben wird der Funktion die zu schreibenden Daten
* ```typescript
  function PostEditor() {
    const [title, setTitle]  = useState("");

    const mutation = useMutation(/* ... */ );

    function saveBlogPost(newPost: NewBlogPost) {
      mutation.mutate();
    }

    // ...
  }
  ```
---
### Parameter f√ºr die Mutations
* Es gibt Szenarien, in denen ben√∂tigt eine Mutation Daten, die erst bei der Ausf√ºhrung von `mutate()` feststehen
  * Informationen, die beim Aufruf von `useMutation()` noch nicht vorliegen
* Dazu kann der `mutate`-Funktion genau **ein** Parameter √ºbergeben werden
* Wie dieser aussieht bestimmt ihr in der Definition der Mutation selbst
* Dieser Parameter entspricht n√§mlich dem ersten Parameter der `mutationFn`:
  * ```typescript
    const addPostMutation = useMutation({
      mutationFn(newBlogPost: NewBlogPost) { /* ... */ }
    })
    ```
* Wenn ihr mehr als einen "logischen" Parameter ben√∂tigt, m√ºsst ihr ein Objekt verwenden:
* ```typescript
  type AddCommentParam = { postId: string, comment: string };

  const addCommentMutation = useMutation({
    mutationFn(param: AddCommentParam) {
      const url = `/api/posts/${postId}/comments;
      return ky.post(url, { json: { comment: param.comment } });
    }
  });
  ```

---
### Arbeiten mit dem Ergebnis

* Wenn eine Mutation ausgef√ºhrt wurde, bekommt ihr `data` bzw. `error` zur√ºck
* Damit k√∂nnt ihr - wie bei `useQuery` - nach der Ausf√ºhrung einer Mutation die UI aktualisieren, um zum Beispiel Fehlermeldungen anzuzeigen
* ```typescript
  function PostEditor() {
    const savePostMutation = useMutation(/*...*/);

    return <form>
      { /* ... */}

      {saveMutation.isError && <p>Fehler beim Speichern des Posts: {String(saveMutation.error)}</p>}
      {saveMutation.isSuccess && <p>Der Blogpost wurde erfolgreich gespeichert!</p>}
    </form>
  }
  ```
---
### Aktionen nach einer Mutation ausf√ºhren
* Um direkt nach Beendingung einer Mutation weitere Aktionen auszuf√ºhren, gibt es zwei Wege:
  1.  [`mutateAsync`](https://tanstack.com/query/latest/docs/framework/react/guides/mutations#promises) statt `mutate` zum Ausf√ºhren der Mutation nutzewn
  2.  `on`-Callback-Funktionen verwenden
* Mit `mutateAsync` k√∂nnt ihr _in einer Komponente_ auf das Ergebnis der Mutation warten. Das ist sinnvoll, wenn man Komponenten-spezfische Aktionen ausf√ºhren m√∂chte.
  * `mutateAsync` liefert ein Promise mit den Daten der Mutation zur√ºck.
  * Schl√§gt die Mutation fehl, wird das Promise verworfen (rejected)
* Beispiel:
* ```typescript
  function PostEditor() {
    const navigate = useNavigate(); // vom React Router

    const savePostMutation = useMutation({ /* ... */ });

    async function savePost(newPost: NewPost) {
      const result = await savePostMutation.mutate(newPost);
      // result ist hier das Ergebnis der (erfolgreichen) Mutation

      navigate("/"); // nach erfolgreicher Mutation zur√ºck auf die Landingpage
    }

    // ...

  }
  ```
---
### Manuelles Aktualisieren von Queries

* Queries k√∂nnen per API manuell erneut ausgef√ºhrt werden
* Das kann zum Beispiel nach einer Mutation sinnvoll sein, um die ge√§nderten/gespeicherten Daten im Cache zu aktualisieren
* Dazu wird die Funktion [`invalidateQueries`](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientinvalidatequeries) vom `QueryClient` verwendet
* √úbergeben werden die Query Keys, deren Queries erneut ausgef√ºhrt werden sollen
* ```typescript
  import { useMutation, useQueryClient } from "react-query";

  function PostEditorPage() {
    const queryClient = useQueryClient();
    const mutation = useMutation({
      mutationFn() { /* ... */ },
      onSuccess() {
        // PostListPage-Query erneut ausf√ºhren, wenn Mutation erfolgreich war
        queryClient.invalidateQueries(['posts']);
      }
    });

    // ...
  }
  ```

---
### Zur√ºcksetzen einer Mutation

* Wenn eine Mutation ausgef√ºhrt wurde, ist `status`, `data`, `error` usw. gesetzt
* Mit `reset` kann man diese Informationen zur√ºcksetzen
* Das kann zum Beispiel nach einem Fehler sinnvoll sein, um die Fehlermeldung wieder verschwinden zu lassen
  * Zum Beispiel nach einer Benutzer-Interaktion
* Dann ist die Mutation "wie neu"
* ```typescript
  function PostEditor() {
    const addPostMutation = useMutation(/* ... */);

    return <form>
      { /* ... */ }

      <input onChange={e => {
        addPostMutaton.reset();
        // ...
      }} />

      { /* ... */ }
    </form>
  }
  ```
---
### √úbung: TanStack Query
- Implementiere das Laden der Blog Posts sowie das Speichern eines neuen Blog Posts
- Vorbereitung:
  - Bitte zuerst das "Backend starten
  - Dazu im Verzeichnis `backend` ausf√ºhren: `npm install` und  `npm start`
  - Der "Blog-Server" l√§uft dann unter http://localhost:3000
- Damit die Anwendung einfach bleibt, zeigen wir die Blog-Liste und den PostEditor gemeinsam auf einer Seite an
- Das **Lesen der Blog-Posts** musst du in der Komponenten `PostListPage` implementieren
  - dort findest du weitere Hinweise
  - m√∂gliche L√∂sung: `steps/20_data_fetching`
- Zum **Speichern des neuen Blog-Posts** musst du die Komponente `PostEditor` erweitern
  - im Verzeichnis `material/25_mutions` findest du eine `PostEditor`-Komponente mit weiteren Informationen dazu
  - du kannst die Anpassungen in deinem eigenen PostEditorm machen oder du kopierst `PostEditor.tsx` in deinen Workspace
  - m√∂gliche L√∂sung: `steps/25_mutation`
---
<!-- .slide: id="t6-routing" -->
# Teil 6
## Clientseitiges Routing
---
## Clientseitiges Routing

* Themen:
  * URLs auf Komponenten abbilden
  * (Interne) Links, die die Anwendung neu rendern, ohne zum Server zu gehen

---

## Der React Router

* React bringt (im Gegensatz zu Angular) keinen Router mit
* In der Regel wird der **React Router** verwendet
* Homepage: [https://reactrouter.com/](https://reactrouter.com/)
* Aktuelle Version v6
* Alternative (aber noch ganz neues Projekt): [TanStack Router](https://tanstack.com/router/latest/docs/framework/react/overview)
  - √úberragender TypeScript Support
  - Sehr komfortables Arbeiten mit Search Params
  - Code Generator und File-basierte Routen
---

### Der React Router
* <!-- .element: class="demo" --> Schritt-f√ºr-Schritt Demo
  * `createBrowserRouter`
  * Routen f√ºr PostListPage und PostEditorPage
  * Layout-Komponente

---
### React Router: Beispiel f√ºr Konfiguration

```tsx
const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    children: [
      {
        index: true,
        element: <PostListPage />
      },
      {
        path: "/editor",
        element: <PostEditorPage />
      },

      { path: "*", element: <NotFoundPage /> }
    ]
  }
]);

export default function App() {
  return <RouterProvider router={router} />;
}
```

---

### Der BrowserRouter

* Es gibt mehrere Implementierungen des Routers, der Stadard ist der `BrowserRouter`
* Beim navigieren wird dabei der Pfad im Browser ver√§ndert (analog zum normalen Browser-Verhalten bei serverseitigen Anwendungen)
* üëâ Demo im Browser, Netzwerkverkehr untersuchen
* Wenn ihr den Router in Produktion verwendet, m√ºsst ihr euren Webserver so konfigurieren, dass bei allen angefragten Routen
            jeweils die `index.html`-Datei ausgeliefert wird

---

### Konfiguration der Routen: Welche Komponente soll f√ºr welche Route angezeigt werden?

* Mit dem `Route`-Objekt wird die Konfiguration beschrieben, welche Pfade es in Eurer Anwendung gibt, und welche Komponenten jeweils gerendert werden sollen.
* Es gibt zwei Notationen, eine Objekt- und eine Komponenten-Form
  * Beide sind identisch
  * Wenn ihr die Komponenten-Form verwendet, m√ºsst ihr die Komponenten an die Funktion `createRoutesFromElements` √ºbergeben
---
### Routen als Objekt

```typescript
  const routerConfig = createBrowserRouter([
    {
      path: "/",
      element: <RootLayout />,
      children: [
        {
          index: true,
          element: <PostListPage />
        },

        {
          path: "post/:postId",
          element: <PostPage />
        },
      ]
    }
  ]);
```
---
### Routen als Komponenten

```typescript
  const routerConfig = createBrowserRouter(
    createRoutesFromElements(
      &lt;Route path="/" element={&lt;RootLayout />}>

        &lt;Route index element={&lt;BlogListPage /> } />

        &lt;Route path="post/:postId" element={&lt;PostPage />}>

      &lt;/Route>
    )
  );
```

---
### Outlet

* Eine Komponente f√ºr eine Route kann die Komponenten f√ºr die Unter-Routen einbinden
* Auf diese Weise kann eine Oberkomponente zum Beispiel ein gemeinsames Layout implementieren
* Die Oberkomponente muss dann jeweils die Unterkomponenten rendern
  * Das funktioniert mit der [`<Outlet />`](https://reactrouter.com/en/main/components/outlet)-Komponente
  * ```javascript
    function App() {
      return &lt;div className="App">
        &lt;h1>Blog App</h1>
        &lt;Outlet />
      &lt;/div>
  }
```

---

### Index Routes

* Bei verschachtelten Routen muss f√ºr die Ober-Route eine Index Route gerendert werden
* Beispiel:
* ```typescript
  export const router = createBrowserRouter([
    {
      path: "/",
      element: <Layout />,
      children: [
        { path: "/editor",  element: <PostEditor /> }
      ]
    }
  ]);
  ```
* Hier wird `Blog` als `Outlet` in `App` f√ºr `/blog` gesetzt. Aber kein Outlet f√ºr `/`
* Dazu muss eine Index-Route definiert werden. Die wird unterhalb der Ober-Route eingesetzt und
  wird dann gerendert, wenn genau der Pfad der Ober-Route aufgerufen wird
* Statt `path` wird darin einfach `index` angegeben:
* ```typescript
  export const router = createBrowserRouter([
    {
      path: "/",
      element: <Layout />,
      children: [
        // "Index-Route" f√ºr /:
        { element: <PostListPage />, index: true },
        { path: "/editor",  element: <PostEditor /> }
      ]
    }
  ]);
  ```

---

### Fallback Route

* Mit `path="*"` kann eine Fallback-Route angegeben werden, die aktiv ist, wenn keine andere Route passt
* Beispiel:
* ```javascript
    &lt;Route path="/" element={&lt;App />}>
      &lt;Route path="blog" element={&lt;Blog />} />

      &lt;Route path="*" element={&lt;NotFound />} /> &lt;!-- F√ºr alle Route, au√üer / und /blog -->
    &lt;/Route>
  ```

---

### Links

* Links m√ºssen mit der [`Link`](https://reactrouter.com/docs/en/v6/components/link)-Komponente gerendert werden
* ```javascript
  function PostTeaser({post}) {
    return &lt;div>
      &lt;h1>{post.title}&lt;/h1>
      &lt;Link to={`/post/${post.id}`}>Read more&lt;/Link>
    &lt;/div>
  }
```
* Die `Link`-Komponente rendert ein `a`-Element, verhindert aber, dass der Browser Serveraufrufe durchf√ºhrt,
  wenn darauf geklickt wird
* Das gilt nur f√ºr interne Links, externe Links wie gewohnt mit HTML `a`-Element
* Alternative: [`NavLink`](https://reactrouter.com/docs/en/v6/components/nav-link) wei√ü, ob der `to`-Pfad
  der gerade aktiven Route entspricht und kann sich dann anders darstellen ("Aktiver Link", "Aktiver Tab", ...)
  * ```javascript
    function NavBar() {
      return &lt;div>
        &lt;NavLink to={`/home}`} className={active => active ? "Tab--active":"Tab--default" }>Home&lt;/Link>
        &lt;NavLink to={`/about}`} className={active => active ? "Tab--active":"Tab--default" }>About&lt;/Link>
        &lt;NavLink to={`/profile}`} className={active => active ? "Tab--active":"Tab--default" }>Profile&lt;/Link>
      &lt;/div>
    }
```
* Mit `className` und `style` k√∂nnen Callback-Funktionen √ºbergeben werden, die das konkrete Styling/CSS Klasse je nach Zustand
  (active bzw not-active) zur√ºckliefern.

---

### Navigation per API

* Die [`Navigate`](https://reactrouter.com/docs/en/v6/components/navigate)-Komponente kann gerendert werden,
  wenn eine Komponente beim Rendern einen Redirect machen m√∂hcte
* ```javascript
  function BlogPost() {
    const result = useQuery({ /* ... */ });

    if (result.isError) {
      return &lt;Navigate to="/error" />
    }

    return &lt;BlogPost post={post} />
  }
  ```
* Mit [`useNavigate`](https://reactrouter.com/en/6.16.0/hooks/use-navigate) kann auch per API, z.B. in einem Event Handler, ein Redirect gemacht werden:
* ```javascript
  function LogoutButton() {
    const useNaviate = useNavigate();

    function handleClick() {
      navigate("/");
    }

    return &lt;button onClick={handleClick}>Logout&lt;/button>
  }
  ```

---
### √úbung: Router

* **Stelle die Anwendung auf den React Router um**
* Die beiden bekannten Seiten (Post Liste und Post Editor) sollen jeweils eine Route werden
* Au√üerdem soll es ein globales "Layout" geben, das den Anwendungstitel sowie zwei Links anzeigt
* Schreibe daf√ºr die Router-Definition in `create-router.tsx`. Dort findest du auch weitere Informationen
* Eine m√∂gliche L√∂sung findest Du in `30_router`



</textarea
          >
        </section>

        <section data-markdown="">
          <textarea data-template>
<!-- .slide: id="seiteneffekte" -->
# Seiteneffekte

  </textarea
          >
        </section>

        <section>
          <h3>Seiteneffekte</h3>
          <ul>
            <li>
              Als <b>Side effect</b> bzw. <b>Seiteneffekt</b> (k√∂nnte im deutschen auch mit
              "Nebenwirkung" √ºbersetzt werden) wird in React Code bezeichnet, der Dinge au√üerhalb
              der umschlie√üenden Komponenten-Funktion ver√§ndert.
            </li>
            <li>
              Beispiele sind: Manipulation des nativen DOM (z.B. Fenster-Titel setzen), einen Timer
              starten oder einen Server-Aufruf durchf√ºhren
            </li>
            <li>Seiteneffekte sind in der <b>Renderphase</b> einer Komponente verboten! üö®</li>
          </ul>
        </section>

        <section>
          <h3>useEffekt-Hook</h3>
          <p>
            <em
              >Mit useEffekt kann eine Funktion registriert werden, die nach dem Rendern der
              Komponente ausgef√ºhrt wird</em
            >
          </p>
          <p>
            Diese <b>Effekt-Callback</b>-Funktion wird beim <em>commit</em> der Komponente
            ausgef√ºhrt
          </p>

          <div>
            <pre><code class="javascript"  >
            function App(props) {
              React.useEffect(
                () => console.log("I will run on EACH commit")
              );
            }
          </code></pre>
          </div>
          <div>
            2. Parameter (leeres Array) gibt an, dass die Funktion nur einmal ausgef√ºhrt werden soll
            <pre><code class="javascript"  >
              function App(props) {
                React.useEffect(
                  () => console.log("I will run only on 1st commit"),
                  []
                );
              }
            </code></pre>
          </div>
        </section>

        <section>
          <h3>useEffect Hook</h3>

          <p>Zwei Parameter:</p>
          <ol>
            <li>
              Callback-Funktion, die aufgerufen wenn entsprechendes Ereignis eintritt (z.B.
              initiales Rendern abgeschlossen)
            </li>
            <li>
              Ein Array mit Abh√§ngigkeiten:
              <ul>
                <li>
                  Wenn kein Array angegeben wird, wird der Effekt nach jedem Rendern ausgef√ºhrt
                  (achtung! Endlosschleife m√∂glich)
                </li>
                <li>
                  Wenn ein leeres Array angegeben wird, wird der Effekt nur nach dem 1. Rendern
                  ausgef√ºhrt
                </li>
                <li>
                  Wenn Werte angegeben werden, wird der Effekt ausgef√ºhrt, wenn sich mind 1 Wert
                  ver√§ndert hat
                </li>
                <li>
                  <b>Wichtig!</b> <em>Alle</em> Werte im Dependency-Array angeben, die darin
                  verwendet werden (Werte aus Props, State, ...)
                </li>
              </ul>
            </li>
          </ol>
        </section>
        <section data-markdown>
          <textarea data-template>
### useEffect Hook: Clean-up Funktion

* Um auf das Entfernen der Komponente aus dem DOM zu reagieren (z.B Resourcen
freigeben), kann die Callback-Funktion als R√ºckgabe eine "Clean-Up"-Funktion zur√ºckliefern:
  * ```javascript
    function HelloEffect() {
      React.useEffect(
        () => {
          console.log("Ich bin gemounted worden");
          return () => console.log("Ich bin entfernt worden")
        },
        [])
      );
    }
  ```
* Die Clean-Up-Funktion wird immer ausgef√ºhrt, wenn die Komponente aus dem DOM entfernt wird
              und bevor der Effekt erneut ausgef√ºhrt wird.
* Mit der Clean-up-Funktion kann also immer die letzte Ausf√ºhrung des Effekt-Callbacks "aufger√§umt" werden
  * ```javascript
    function PostEditor() {
      const [title, setTitle] = useState("");

      React.useEffect(
        () => {
          let currentTitle = title;
          console.log("Title: ", currentTitle);
          return () => console.log("Title war beim Commit:", currentTitle)
        },
        [ title ])
      );
    }
    ```

</textarea
          >
        </section>

        <section>
          <h3>Beispiel: Aktualisieren des Browsertitels</h3>

          <div>
            <p>Der eingegebene Post-Titel soll auch in der Titelzeile des Browsers erscheinen.</p>
            <pre><code class="javascript"  >
                function PostEditor() {
                  const [title, setTitle] = React.useState("");
                  const [body, setBody] = React.useState("");

                  React.useEffect(() => {
                    // Aktuellen Titel merken
                    const currentTitle = window.document.title;
                    window.document.title = `New Post ${title}`;

                    // Nach dem Unmount bzw. erneuten Ausf√ºhrung des Effekts
                    // Titel wieder auf urspr√ºnglichen Wert zur√ºcksetzen
                    return () => window.document.title = currentTitle;


                  }, [title]);

                  return <div>...</div>

                }

                </code></pre>
          </div>
        </section>

        <section data-markdown="">
          <textarea data-template>
---
<!-- .slide: id="t-zod" -->
# Validieren von Daten
## ...am Beispiel von zod

---
### Validieren von Daten
* <!-- .element: class="demo" --> Au√üerhalb des Projektes, in einer TypeScript-Datei:
* <!-- .element: class="demo" --> json()-Ergebnis von ky ist 'unknown' in TypeScript
* <!-- .element: class="demo" --> Noch schlimmer w√§re any
* <!-- .element: class="demo" --> zod
---
### Validieren von Daten
<!-- .slide: class="left" -->
- Das Ergebnis von `json()` in der `ky` API ist ein Promise von `unknown`.
- Ohne explizite Typangabe schl√§gt der Compiler fehl üò¢:
* ```typescript
  async function queryFn() {
    const data = await ky
      .get(`http://localhost:7000/posts`)
      .json();

    data.map({ /* ... */}); // ERROR: TS18046: data is of type 'unknown'
  }
  ```
* Mit expliziter Typ-Angabe gibt es keinen Compile-Fehler:
* ```typescript
  async function queryFn() {
    const data = await ky
      .get<IBlogPost[]>(`http://localhost:7000/posts`)
      .json();

    data.map({ /* ... */}); // data ist jetzt BlogPost[]  üòä
  }
  ```
* Damit f√ºhren wir eine Art "Type Cast" durch
  * ...aber: stimmt das auch zur Laufzeit? ü§î
  * ...welche Probleme kann es geben? ü§î
* Die Typ-Pr√ºfung findet nur zur Build-Zeit statt!
---
### Typecast vs. Validierung
<!-- .slide: class="left" -->
- Mit einem Typecast sagen wir TypeScript welchen Typ eine Variablen haben soll
* Das kann richtig oder falsch sein:
* ```typescript
  const s:string = "Hallo";
  let y:any = s;
  let x:number = y as number; üôÄ
  ```
- Entspricht ungef√§hr in Java:
* ```java
  String s = "Hallo";
  Object y = s;
  Integer x = (Integer) y;
  ```
- In unserem Beispiel sind wir uns ja sicher, dass `data` eine Liste von `BlogPost`-Objekten ist.
- Deswegen k√∂nnen wir uns auf den Type Cast verlassen.
* Oder? ü§î
---
### Validierung
<!-- .slide: class="left" -->
* Die Daten, die von einem Server (oder auch aus Benutzereingaben) kommen, k√∂nnen von TypeScript nicht √ºberpr√ºft werden
* TypeScript ist zu Laufzeit "weg"
* Wenn der Server also Daten schickt die - entgegen unserer Erwartung - nicht zu dem passen, was wir als TypeScript-Typ definiert haben, merken wir das nicht
  * (abgesehen davon, dass die Anwendung irgendwann in Fehler l√§uft)
* Besser w√§re bei solchen Daten eine echte Laufzeit-Validierung
* Dabei werden die gelesen Daten nach dem Empfang √ºberpr√ºft:
* ```typescript
  async function queryFn(): Promise<BlogPost[]> {
    const data = await ky.get<BlogPost[]>("...").json();
    if (!Array.isArray(data)) {
      // Fehler, Antwort muss eine Liste sein
    }

    data.forEach(p => {
      if (!"title" in p) { throw new Error("Kein title"); }
      if (!"body" in p) { throw new Error("Kein body"); }
      // ... weitere Pr√ºfungen ...
    });

    // ok: data hier ziemlich sicher BlogPost-Liste
    return data;
  }
  ```
* Ist das sch√∂n?
---
### Probleme mit manueller Validierung

* Validierung kann viel Code in Anspruch nehmen
* Au√üerdem redundant:
  * wir m√ºssen den Code zur Validierung schreiben (Laufzeit)
  * wir m√ºssten den TypeScript-Code schreiben (Buildzeit)
---
### Validierungsbibliothek: zod
<!-- .slide: class="left" -->
- Mit [zod](https://zod.dev) gibt es eine Validierungsbibliothek, die beides verbindet
- Mit (JavaScript)-Code, der auch zur Laufzeit ausgef√ºhrt wird, wird ein **Schema** beschrieben
- Dieses Schema kann zur Laufzeit verwendet werden, um ein beliebiges Objekt zu validieren
- Au√üerdem kann aus dem Schema ein TypeScript-Type f√ºr die Build-Zeit abgeleitet werden
* ```typescript
  import { z } from "zod";

  const UserSchema = z.object({
    // String:
    username: z.string(),

    // String mit Format:
    email: z.email(),

    // Optionaler String (kann null oder undefined sein):
    nickname: z.string().nullish(),

    // Zahl:
    age: z.number(),

    // Liste von Strings:
    roles: z.string().array();
  });
  ```
---
### Validierungsbibliothek: zod
<!-- .slide: class="left" -->
* Die definierten Schema lassen sich kombinieren:
* ```typescript
  // "Primitiver" Wert mit definiertem Format
  const Password = z.string()
            .min(10)
            .regex(/^(?=.*[a-zA-Z])(?=.*\d).+$/);

  const UserSchema = z.object({
    // ...
    password: Password
  });

  // Liste mit definiertem Inhalt (UserSchema)
  const GetUserApiResponse = UserSchema.array();

  ```
* ```typescript
  // Erweiterung des UserSchema:
  const EditorSchema = UserSchema.extend({
    mainTopic: z.string()
  });
  ```
* ```typescript
  // Verwenden von Schemas
  const Article = z.object({
    // writtenBy muss EditorSchema entsprechen (weder null noch undefined)
    writtenBy: EditorSchema,

    // reviewedBy darf Editor oder null sein (nicht undefined)
    reviewedBy: EditorSchema.nullable(),

    // Optionale Liste von Usern (darf undefined, aber nicht null sein)
    commentedBy: UserSchema.array().optional()
  })
  ```
---
### Zod
* Mit dem `z`-Objekt lassen sich Typen (einfache und komplexe) beschreiben
* Objekte werden mit [`z.object`](https://zod.dev/?id=objects) beschrieben
* Dabei kann man nicht nur Typen angeben ([`string`, `number`](https://zod.dev/?id=primitives), `email`, ....) sondern auch Wertebeschr√§nkungen
  * [Mindestl√§nge, Maximall√§nge](https://zod.dev/?id=minmaxlength), erlaubte Zeichen etc.
* Mit der [`parse`-Methode](https://zod.dev/?id=parse) am `Schema`-Objekt kann dann ein beliebiges Objekt validiert werden.
* Wenn das Objekt nicht dem Schema entspricht, wird ein Fehler geworfen
* Wenn alles in Ordnung ist, kommt das validierte Objekt zur√ºck
* ```typescript
  const potentialUser = await loadUser("U1");

  const user = UserSchema.parse(potentialUser);
  ```
* Dadurch ist auch TypeScript der Typ bekannt!
* ```typescript
  type User = { username: string; email: string; nickname?: string | null };
  const user: User = UserSchema.parse(potentialUser);
                     // ^--- ok

  ```
---
### Zod: Ableiten des TypeScript-Typen
* Den TypeScript-Typen m√ºssen wir gar nicht selber schreiben, dass kann zod f√ºr uns machen:
* ```typescript
  export const UserSchema = z.object({ /* ... */ });

  export type User = z.infer<typeof UserSchema>;
  ```
* üëâ Damit sind wir sicher, dass unser TypeScript-Type und die Validierungsregeln √ºbereinstimmen
  * Wir vermeiden Redundanzen
  * Wir haben Sicherheit zur Build- und zur Laufzeit
---
### √úbung: zod

* In `types.ts` ist der `BlogPost`-Typ als TypeScript-Typ definiert
* Schreibe zwei zod-Typen:
  1. als "Ersatz" f√ºr den `BlogPost`-Typen. Dieser soll genau dem bisherigen `BlogPost`-Typen entsprechen
  2. einen Typen f√ºr die Antwort vom Server, also eine Liste von `BlogPost`-Objekten
* Verwende den zod-Typen in der Anwendung um die gelesenen Daten zu validieren.
* Mehr Hinweise findest du direkt in `types.ts`
* M√∂gliche L√∂sung: `60_zod`


  </textarea
          >
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p><a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p><a href="https://www.linkedin.com/in/nils-hartmann-2a5738252/">LinkedIn</a></p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>

        <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
        <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
        <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
        <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
        <script src="slides/revealjs/config.js"></script>
      </div>
    </div>
  </body>
</html>
